import {
  require_jsx_runtime
} from "./chunk-RLMGAKMB.js";
import {
  require_react_dom
} from "./chunk-SVG7M4VJ.js";
import {
  __commonJS,
  __export,
  __toESM,
  require_react
} from "./chunk-2YIMICFJ.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment14 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement3(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment14;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement3;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/color-swatch/index.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/cx.js
var cx = (...classNames) => classNames.filter(Boolean).map((r) => r.trim()).join(" ");

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/create-context.js
var import_react = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(
        errorMessage ?? getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@chakra-ui/react/dist/esm/utils/call-all.js
function callAll(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn == null ? void 0 : fn(...args));
  };
}

// node_modules/@chakra-ui/react/dist/esm/merge-props.js
var clsx = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var eventRegex = /^on[A-Z]/;
function mergeProps(...args) {
  let result = {};
  for (let props25 of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props25[key] === "function") {
        result[key] = callAll(result[key], props25[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props25[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props25[key] ?? {});
        continue;
      }
      result[key] = props25[key] !== void 0 ? props25[key] : result[key];
    }
    for (let key in props25) {
      if (result[key] === void 0) {
        result[key] = props25[key];
      }
    }
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/empty.js
var EMPTY_STYLES = Object.freeze({});
var EMPTY_SLOT_STYLES = Object.freeze(
  {}
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props25, children, length2) {
  return { value, root, parent, type, props: props25, children, line, column, length: length2, return: "" };
}
function copy(root, props25) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props25);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props25 = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset3:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index, offset3, rules, points, type, props25 = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root, reference, reference, props25, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props25 = [], length2), children), rules, children, length2, points, rule ? props25 : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset3, rules, points, type, props25, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size3; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props25[k++] = z;
  return node(value, root, parent, offset3 === 0 ? RULESET : type, props25, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection2) {
  var length2 = sizeof(collection2);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection2[i](element, index, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache2 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache2.has(arg)) {
      return cache2.get(arg);
    }
    var ret = func(arg);
    cache2.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      // fallthrough
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
  return function(element, index, children) {
    if (element.type !== "rule" || cache2.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node2 = commentContainer[i];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var getSourceMap;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
  getSourceMap = function getSourceMap2(styles) {
    var matches = styles.match(sourceMapPattern);
    if (!matches) return;
    return matches[matches.length - 1];
  };
}
var sourceMapPattern;
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache2.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (getSourceMap) {
        var sourceMap = getSourceMap(serialized.styles);
        if (sourceMap) {
          currentSheet = {
            insert: function insert2(rule) {
              sheet.insert(rule + sourceMap);
            }
          };
        }
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match5, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i4 = 0; _i4 < value.length; _i4++) {
            if (isProcessableValue(value[_i4])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i4]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      if (templateStringsArr[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match5;
  while ((match5 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match5[1];
  }
  var name = murmur2(styles) + identifierName;
  {
    var devStyles = {
      name,
      styles,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var EmotionCacheContext = React2.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
{
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react2.forwardRef)(function(props25, ref2) {
    var cache2 = (0, import_react2.useContext)(EmotionCacheContext);
    return func(props25, cache2, ref2);
  });
};
var ThemeContext = React2.createContext({});
{
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var hasOwn = {}.hasOwnProperty;
var getLastPart = function getLastPart2(functionName) {
  var parts32 = functionName.split(".");
  return parts32[parts32.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match5 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match5) return getLastPart(match5[1]);
  match5 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match5) return getLastPart(match5[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
  return identifier2.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace) return void 0;
  var lines = stackTrace.split("\n");
  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]);
    if (!functionName) continue;
    if (internalReactFunctionNames.has(functionName)) break;
    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props25) {
  if (typeof props25.css === "string" && // check if there is a css declaration
  props25.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props25.css + "`");
  }
  var newProps = {};
  for (var _key in props25) {
    if (hasOwn.call(props25, _key)) {
      newProps[_key] = props25[_key];
    }
  }
  newProps[typePropName] = type;
  if (typeof globalThis !== "undefined" && !!globalThis.EMOTION_RUNTIME_AUTO_LABEL && !!props25.css && (typeof props25.css !== "object" || !("name" in props25.css) || typeof props25.css.name !== "string" || props25.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props25, cache2, ref2) {
  var cssProp = props25.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props25[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props25.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props25.className);
  } else if (props25.className != null) {
    className = props25.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props25[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props25) {
    if (hasOwn.call(props25, _key2) && _key2 !== "css" && _key2 !== typePropName && _key2 !== labelPropName) {
      newProps[_key2] = props25[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React2.createElement(WrappedComponent, newProps));
});
{
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js
var React3 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var isDevelopment3 = true;
var pkg = {
  name: "@emotion/react",
  version: "11.14.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  types: "dist/emotion-react.cjs.d.ts",
  exports: {
    ".": {
      types: {
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        worker: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        browser: {
          module: "./dist/emotion-react.browser.development.esm.js",
          "import": "./dist/emotion-react.browser.development.cjs.mjs",
          "default": "./dist/emotion-react.browser.development.cjs.js"
        },
        module: "./dist/emotion-react.development.esm.js",
        "import": "./dist/emotion-react.development.cjs.mjs",
        "default": "./dist/emotion-react.development.cjs.js"
      },
      "edge-light": {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      worker: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      workerd: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      browser: {
        module: "./dist/emotion-react.browser.esm.js",
        "import": "./dist/emotion-react.browser.cjs.mjs",
        "default": "./dist/emotion-react.browser.cjs.js"
      },
      module: "./dist/emotion-react.esm.js",
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      types: {
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
        },
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
      },
      module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      types: {
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        worker: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        browser: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
        },
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
      },
      "edge-light": {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      worker: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      workerd: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      browser: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
      },
      module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      types: {
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
        },
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
      },
      module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  imports: {
    "#is-development": {
      development: "./src/conditions/true.ts",
      "default": "./src/conditions/false.ts"
    },
    "#is-browser": {
      "edge-light": "./src/conditions/false.ts",
      workerd: "./src/conditions/false.ts",
      worker: "./src/conditions/false.ts",
      browser: "./src/conditions/true.ts",
      "default": "./src/conditions/is-browser.ts"
    }
  },
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/css-prop.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.13.5",
    "@emotion/cache": "^11.14.0",
    "@emotion/serialize": "^1.3.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
    "@emotion/utils": "^1.4.2",
    "@emotion/weak-memoize": "^0.4.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.13.5",
    "@emotion/css-prettifier": "1.2.0",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.14.0",
    "@types/hoist-non-react-statics": "^3.3.5",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^5.4.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.ts",
      "./jsx-runtime.ts",
      "./jsx-dev-runtime.ts",
      "./_isolated-hnrs.ts"
    ],
    umdName: "emotionReact",
    exports: {
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props25) {
  var args = arguments;
  if (props25 == null || !hasOwn.call(props25, "css")) {
    return React3.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props25);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React3.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props25, cache2) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  ("className" in props25 && props25.className || "css" in props25 && props25.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props25.styles;
  var serialized = serializeStyles([styles], void 0, React3.useContext(ThemeContext));
  var sheetRef = React3.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
{
  Global.displayName = "EmotionGlobal";
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var Insertion3 = function Insertion4(_ref) {
  var cache2 = _ref.cache, serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache2, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props25, cache2) {
  var hasRendered = false;
  var serializedArr = [];
  var css2 = function css3() {
    if (hasRendered && isDevelopment3) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache2.registered);
    serializedArr.push(serialized);
    registerStyles(cache2, serialized, false);
    return cache2.key + "-" + serialized.name;
  };
  var cx2 = function cx3() {
    if (hasRendered && isDevelopment3) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache2.registered, css2, classnames(args));
  };
  var content = {
    css: css2,
    cx: cx2,
    theme: React3.useContext(ThemeContext)
  };
  var ele = props25.children(content);
  hasRendered = true;
  return React3.createElement(React3.Fragment, null, React3.createElement(Insertion3, {
    cache: cache2,
    serializedArr
  }), ele);
});
{
  ClassNames.displayName = "EmotionClassNames";
}
{
  isBrowser3 = typeof document !== "undefined";
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser3 && !isTestEnv) {
    globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser3 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var React5 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/merge-refs.js
function assignRef(ref2, value) {
  if (ref2 == null) return;
  if (typeof ref2 === "function") {
    ref2(value);
    return;
  }
  try {
    ref2.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref2}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref2) => {
      assignRef(ref2, node2);
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/compact.js
function compact(object) {
  const clone3 = Object.assign({}, object);
  for (let key in clone3) {
    if (clone3[key] === void 0) delete clone3[key];
  }
  return clone3;
}

// node_modules/@chakra-ui/react/dist/esm/utils/interop.js
function interopDefault(mod2) {
  return mod2.default || mod2;
}

// node_modules/@chakra-ui/react/dist/esm/utils/ref.js
var React4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/is.js
var isObject = (v) => v != null && typeof v === "object" && !Array.isArray(v);
var isCssVar = (v) => /^var\(--.+\)$/.test(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";

// node_modules/@chakra-ui/react/dist/esm/utils/ref.js
function getElementRef(el) {
  var _a8;
  const version2 = React4.version;
  if (!isString(version2)) return el == null ? void 0 : el.ref;
  if (version2.startsWith("18.")) return el == null ? void 0 : el.ref;
  return (_a8 = el == null ? void 0 : el.props) == null ? void 0 : _a8.ref;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/provider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var [ChakraContextProvider, useChakraContext] = createContext({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props25) {
  const { value: sys, children } = props25;
  return (0, import_jsx_runtime.jsxs)(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && (0, import_jsx_runtime.jsx)(Global, { styles: sys.layers.atRule }),
    (0, import_jsx_runtime.jsx)(Global, { styles: sys._global }),
    children
  ] });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/split-props.js
var splitProps = (props25, keys) => {
  const descriptors = Object.getOwnPropertyDescriptors(props25);
  const dKeys = Object.keys(descriptors);
  const split = (k) => {
    const clone3 = {};
    for (let i = 0; i < k.length; i++) {
      const key = k[i];
      if (descriptors[key]) {
        Object.defineProperty(clone3, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone3;
  };
  const fn = (key) => split(Array.isArray(key) ? key : dKeys.filter(key));
  return [keys].map(fn).concat(split(dKeys));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-resolved-props.js
var htmlProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function isHtmlProp(prop) {
  return typeof prop === "string" && htmlProps.has(prop);
}
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props25 } = inProps;
  const result = (0, import_react4.useMemo)(() => {
    const [forwardedProps, restProps_B] = splitProps(
      props25,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props25, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = (0, import_react4.useMemo)(() => {
    const variantProps = { ...result.variantProps };
    if (!cvaRecipe.variantKeys.includes("colorPalette")) {
      variantProps.colorPalette = props25.colorPalette;
    }
    if (!cvaRecipe.variantKeys.includes("orientation")) {
      variantProps.orientation = props25.orientation;
    }
    return cvaRecipe(variantProps);
  }, [cvaRecipe, result.variantProps, props25.colorPalette, props25.orientation]);
  const styles = (0, import_react4.useMemo)(() => {
    return css2(cvaStyles, ...toArray(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      children
    }
  };
}
var toArray = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/factory.js
var isPropValid2 = interopDefault(isPropValid);
var testOmitPropsOnStringTag = isPropValid2;
var testOmitPropsOnComponent = (key) => key !== "theme";
var composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var isBrowser2 = typeof document !== "undefined";
var Insertion5 = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser2 && rules !== void 0) {
    let serializedNames = serialized.name;
    let next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames = cx(serializedNames, next2.name);
      next2 = next2.next;
    }
    return (0, import_jsx_runtime2.jsx)(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
var createStyled = (tag, configOrCva = {}, options = {}) => {
  if (true) {
    if (tag === void 0) {
      throw new Error(
        "You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it."
      );
    }
  }
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles = [];
  const Styled = withEmotionCache((inProps, cache2, ref2) => {
    var _a8;
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props26) => {
      return (prop, variantKeys) => {
        if (props26.includes(prop)) return true;
        return !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = React5.useMemo(
      () => Object.assign({}, options.defaultProps, compact(inProps)),
      [inProps]
    );
    const { props: props25, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props25;
    if (props25.theme == null) {
      mergedProps = {};
      for (let key in props25) {
        mergedProps[key] = props25[key];
      }
      mergedProps.theme = React5.useContext(ThemeContext);
    }
    if (typeof props25.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props25.className
      );
    } else if (props25.className != null) {
      className = cx(className, props25.className);
    }
    const serialized = serializeStyles(
      styles.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props25.as || baseTag;
    let finalProps = {};
    for (let prop in props25) {
      if (shouldUseAs && prop === "as") continue;
      if (isHtmlProp(prop)) {
        const nativeProp = prop.replace("html", "").toLowerCase();
        finalProps[nativeProp] = props25[prop];
        continue;
      }
      if (shouldForwardProp(prop)) {
        finalProps[prop] = props25[prop];
      }
    }
    finalProps.className = className.trim();
    finalProps.ref = ref2;
    const forwardAsChild = options.forwardAsChild || ((_a8 = options.forwardProps) == null ? void 0 : _a8.includes("asChild"));
    if (props25.asChild && !forwardAsChild) {
      const child = React5.Children.only(props25.children);
      FinalTag = child.type;
      finalProps.children = null;
      Reflect.deleteProperty(finalProps, "asChild");
      finalProps = mergeProps(finalProps, child.props);
      finalProps.ref = mergeRefs(ref2, getElementRef(child));
    }
    if (finalProps.as && forwardAsChild) {
      finalProps.as = void 0;
      return (0, import_jsx_runtime2.jsxs)(React5.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)(
          Insertion5,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        (0, import_jsx_runtime2.jsx)(FinalTag, { asChild: true, ...finalProps, children: (0, import_jsx_runtime2.jsx)(props25.as, { children: finalProps.children }) })
      ] });
    }
    return (0, import_jsx_runtime2.jsxs)(React5.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        Insertion5,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      (0, import_jsx_runtime2.jsx)(FinalTag, { ...finalProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      if (targetClassName === void 0 && true) {
        return "NO_COMPONENT_SELECTOR";
      }
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
var styledFn = createStyled.bind();
var cache = /* @__PURE__ */ new Map();
var chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el) {
    if (!cache.has(el)) {
      cache.set(el, styledFn(el));
    }
    return cache.get(el);
  }
});
var chakra = chakraImpl;
var mergeCva = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-recipe.js
var import_react6 = __toESM(require_react(), 1);
function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react6.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-recipe-context.js
var upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider62, usePropsContext2] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  function useRecipeResult6(props25) {
    const { unstyled, ...restProps } = props25;
    const recipe = useRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = recipe.splitVariantProps(restProps);
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return {
      styles,
      className: recipe.className,
      props: otherProps
    };
  }
  const withContext60 = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react7.forwardRef)((inProps, ref2) => {
      const props25 = mergeProps(usePropsContext2(), inProps);
      const { styles, className, props: localProps } = useRecipeResult6(props25);
      return (0, import_jsx_runtime3.jsx)(
        SuperComponent,
        {
          ...localProps,
          ref: ref2,
          css: [styles, props25.css],
          className: cx(className, props25.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  function withPropsProvider2() {
    return PropsProvider62;
  }
  return {
    withContext: withContext60,
    PropsProvider: PropsProvider62,
    withPropsProvider: withPropsProvider2,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult6
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var Grid = (0, import_react8.forwardRef)(
  function Grid2(props25, ref2) {
    const {
      templateAreas,
      column: column2,
      row,
      autoFlow,
      autoRows,
      templateRows,
      autoColumns,
      templateColumns,
      inline: inline2,
      ...rest
    } = props25;
    return (0, import_jsx_runtime4.jsx)(
      chakra.div,
      {
        ...rest,
        ref: ref2,
        css: [
          {
            display: inline2 ? "inline-grid" : "grid",
            gridTemplateAreas: templateAreas,
            gridAutoColumns: autoColumns,
            gridColumn: column2,
            gridRow: row,
            gridAutoFlow: autoFlow,
            gridAutoRows: autoRows,
            gridTemplateRows: templateRows,
            gridTemplateColumns: templateColumns
          },
          props25.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/color-swatch/index.js
var { withPropsProvider, useRecipeResult } = createRecipeContext({
  key: "colorSwatch"
});
var ColorSwatch = (0, import_react9.forwardRef)(
  function ColorSwatch2(props25, ref2) {
    const { value, ...restProps } = props25;
    const { styles, className, props: localProps } = useRecipeResult(restProps);
    return (0, import_jsx_runtime5.jsx)(
      chakra.span,
      {
        ...localProps,
        ref: ref2,
        "data-value": value,
        css: [styles, { "--color": value }, props25.css],
        className: cx(className, props25.className)
      }
    );
  }
);
var ColorSwatchPropsProvider = withPropsProvider();
var ColorSwatchMix = (props25) => {
  const { items, ...restProps } = props25;
  if (items.length > 4) {
    throw new Error("ColorSwatchMix doesn't support more than 4 colors");
  }
  const isThreeColors = items.length === 3;
  return (0, import_jsx_runtime5.jsx)(ColorSwatch, { overflow: "hidden", ...restProps, value: "transparent", children: (0, import_jsx_runtime5.jsx)(Grid, { templateColumns: "var(--swatch-size) var(--swatch-size)", children: items.map((item, index) => {
    const isLast = index === items.length - 1;
    return (0, import_jsx_runtime5.jsx)(
      ColorSwatch,
      {
        size: "inherit",
        rounded: "none",
        value: item,
        boxShadow: "none",
        gridColumn: isThreeColors && isLast ? "span 2 / span 2" : void 0,
        width: isThreeColors && isLast ? "unset" : void 0
      },
      item
    );
  }) }) });
};

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/dom-query/dist/index.mjs
var clamp = (value) => Math.max(0, Math.min(1, value));
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop = () => void 0;
var isObject2 = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject2(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject2(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject2(el) && el === el.window;
var getNodeName = (node2) => {
  if (isHTMLElement(node2)) return node2.localName || "";
  return "#document";
};
function isRootElement(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
var isNode = (el) => isObject2(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!(el == null ? void 0 : el.matches("a[href]"));
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  var _a8;
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  const rootNode = (_a8 = child.getRootNode) == null ? void 0 : _a8.call(child);
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) return true;
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  var _a8;
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement == null ? void 0 : activeElement.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") return node2;
  const result = node2.assignedSlot || node2.parentNode || isShadowRoot(node2) && node2.host || getDocumentElement(node2);
  return isShadowRoot(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getDataUrl(svg, opts) {
  const { type, quality = 0.92, background } = opts;
  if (!svg) throw new Error("[zag-js > getDataUrl]: Could not find the svg element");
  const win = getWindow(svg);
  const doc = win.document;
  const svgBounds = svg.getBoundingClientRect();
  const svgClone = svg.cloneNode(true);
  if (!svgClone.hasAttribute("viewBox")) {
    svgClone.setAttribute("viewBox", `0 0 ${svgBounds.width} ${svgBounds.height}`);
  }
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svgClone);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString).then((str) => {
      svgClone.remove();
      return str;
    });
  }
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  if (type === "image/jpeg" || background) {
    context.fillStyle = background || "white";
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  return new Promise((resolve) => {
    image.onload = () => {
      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL(type, quality));
      svgClone.remove();
    };
  });
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version: version2 }) => `${brand}/${version2}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  var _a8, _b7, _c6;
  return ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? ((_c6 = (_b7 = event.nativeEvent) == null ? void 0 : _b7.composedPath) == null ? void 0 : _c6.call(_b7));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node2 = typeof target === "function" ? target() : target;
  node2 == null ? void 0 : node2.addEventListener(eventName, handler, options);
  return () => {
    node2 == null ? void 0 : node2.removeEventListener(eventName, handler, options);
  };
};
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  var _a8;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, value);
  }
  el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
  var _a8;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form == null ? void 0 : form.addEventListener("reset", onReset, { passive: true });
  return () => form == null ? void 0 : form.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups2 = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups2.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
}
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el) => parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getTabIndex(node2) {
  if (node2.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node2.localName) || isEditableElement(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node2 = null;
  node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node2 || (node2 = root == null ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
  if (!node2) {
    const tabbables = getTabbables(root);
    node2 = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node2 || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set22 = /* @__PURE__ */ new Set();
  function raf22(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set22.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf22(() => raf22(fn));
  return function cleanup() {
    set22.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id);
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec2, true);
    cb();
  });
  const exec2 = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec2, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node2, options) {
  if (!node2) return;
  const { attributes, callback: fn } = options;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node2, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function observeChildrenImpl(node2, options) {
  const { callback: fn } = options;
  if (!node2) return;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node2, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeChildrenImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function clickIfLink(el) {
  const click = () => el.click();
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset3 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset3.x / width), y: clamp(offset3.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset3, percent, getPercentValue: getPercentValue2 };
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn == null ? void 0 : fn(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn == null ? void 0 : fn(false);
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof target === "function" ? target() : target;
      cleanups2.push(disableTextSelectionImpl({ ...restOptions, target: node2 }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups2 = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups2.forEach((cleanup) => cleanup());
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop;
  let removeEndListeners = noop;
  let removeAccessibleListeners = noop;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart == null ? void 0 : onPressStart(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd == null ? void 0 : onPressEnd(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress == null ? void 0 : onPress(getInfo(endEvent));
      } else {
        onPressEnd == null ? void 0 : onPressEnd(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, { passive: !onPressEnd });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress == null ? void 0 : onPress(info);
        onPressEnd == null ? void 0 : onPressEnd(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = getNextTabbable(body, triggerElement);
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups2.push(proxyTabFocusImpl(node2, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
function createScope(methods) {
  const dom28 = {
    getRootNode: (ctx) => {
      var _a8;
      return ((_a8 = ctx.getRootNode) == null ? void 0 : _a8.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom28.getRootNode(ctx)),
    getWin: (ctx) => dom28.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom28.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom28.getActiveElement(ctx),
    getById: (ctx, id) => dom28.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      setElementValue(elem, value.toString());
    }
  };
  return { ...dom28, ...methods };
}
var sanitize = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  var _a8;
  return sanitize(((_a8 = el.dataset) == null ? void 0 : _a8.valuetext) ?? el.textContent ?? "");
};
var match2 = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match2(getValueText(item), text));
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      var _a8;
      (_a8 = elementCleanups.get(key)) == null ? void 0 : _a8();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element) return () => {
  };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set(element, "style", setup);
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next2 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next2;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups2 = [];
  queries == null ? void 0 : queries.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var collatorCache = i18nCache(Intl.Collator);
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix3 = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix3.length - 1));
  const _unit = prefix3[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react10 = __toESM(require_react(), 1);
function getErrorMessage2(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext3(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react10.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react10.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage2(hookName, providerName));
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext3({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var FormatByte = (props25) => {
  const { value, ...intlOptions } = props25;
  const { locale } = useLocaleContext();
  const text = (0, import_react11.useMemo)(() => formatBytes(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: text });
};
FormatByte.displayName = "FormatByte";

// node_modules/@ark-ui/react/dist/components/format/format-number.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var FormatNumber = (props25) => {
  const { value, ...intlOptions } = props25;
  const { locale } = useLocaleContext();
  const text = (0, import_react12.useMemo)(() => formatNumber(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: text });
};
FormatNumber.displayName = "FormatNumber";

// node_modules/@ark-ui/react/dist/components/format/format.js
var format_exports = {};
__export(format_exports, {
  Byte: () => FormatByte,
  Number: () => FormatNumber
});

// node_modules/@chakra-ui/react/dist/esm/components/format/index.js
var FormatNumber2 = format_exports.Number;
var FormatByte2 = format_exports.Byte;

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node2) => {
    for (const ref2 of refs) {
      setRef(ref2, node2);
    }
  };
}

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL = Symbol();
var GET_ORIGINAL_SYMBOL = Symbol();
var AFFECTED_PROPERTY = "a";
var IS_TARGET_COPIED_PROPERTY = "f";
var PROXY_PROPERTY = "p";
var PROXY_CACHE_PROPERTY = "c";
var TARGET_CACHE_PROPERTY = "t";
var HAS_KEY_PROPERTY = "h";
var ALL_OWN_KEYS_PROPERTY = "w";
var HAS_OWN_KEY_PROPERTY = "o";
var KEYS_PROPERTY = "k";
var newProxy = (target, handler) => new Proxy(target, handler);
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var isObject3 = (x) => typeof x === "object" && x !== null;
var needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
var copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
var createProxyHandler = (origObj, isTargetCopied) => {
  const state2 = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state2[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state2[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set21 = used[type];
        if (!set21) {
          set21 = /* @__PURE__ */ new Set();
          used[type] = set21;
        }
        set21.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state2[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state2];
};
var getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
var createProxy = (obj, affected, proxyCache, targetCache3) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache3 && targetCache3.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache3 === null || targetCache3 === void 0 ? void 0 : targetCache3.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache3;
  return handlerAndState[1][PROXY_PROPERTY];
};
var isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k, i) => k !== nextKeys[i]);
};
var isChanged = (prevObj, nextObj, affected, cache2, isEqual3 = Object.is) => {
  if (isEqual3(prevObj, nextObj)) {
    return false;
  }
  if (!isObject3(prevObj) || !isObject3(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache2) {
    const hit = cache2.get(prevObj);
    if (hit === nextObj) {
      return false;
    }
    cache2.set(prevObj, nextObj);
  }
  let changed = null;
  for (const key of used[HAS_KEY_PROPERTY] || []) {
    changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
    if (changed)
      return changed;
  }
  if (used[ALL_OWN_KEYS_PROPERTY] === true) {
    changed = isAllOwnKeysChanged(prevObj, nextObj);
    if (changed)
      return changed;
  } else {
    for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
      const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
      const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
      changed = hasPrev !== hasNext;
      if (changed)
        return changed;
    }
  }
  for (const key of used[KEYS_PROPERTY] || []) {
    changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual3);
    if (changed)
      return changed;
  }
  if (changed === null)
    throw new Error("invalid used");
  return changed;
};
var trackMemo = (obj) => {
  if (isObjectToTrack(obj)) {
    return TRACK_MEMO_SYMBOL in obj;
  }
  return false;
};
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/store/dist/index.mjs
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g = glob();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x && "props" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x) => typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);
var isObject4 = (x) => x !== null && typeof x === "object";
var canProxy = (x) => isObject4(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
var isDev = () => true;
function set2(obj, key, val) {
  if (typeof val.value === "object" && !canProxy(val.value)) val.value = clone(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function clone(x) {
  if (typeof x !== "object") return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(Object.getPrototypeOf(x) || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(clone(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(clone(key), clone(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(clone(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str === "[object Blob]") {
    tmp = x.slice();
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set2(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;
      set2(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version2) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject4(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove2 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove2]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a8;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a8 = entry[1]) == null ? void 0 : _a8.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove2 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove2]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove2], prop) => {
          if (remove2) {
            remove2();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a8;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject4(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a8 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a8.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set22 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set22) {
      desc.set = (newValue) => set22(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}

// node_modules/@zag-js/utils/dist/index.mjs
var fromLength = (length2) => Array.from(Array(length2).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var addOrRemove = (v, item) => {
  if (has(v, item)) return remove(v, item);
  return add(v, item);
};
function clear(v) {
  while (v.length > 0) v.pop();
  return v;
}
var isArrayLike = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b[i])) return false;
  }
  return true;
};
var isEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike(a) && isArrayLike(b)) {
    return isArrayEqual(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b[key])) return false;
  }
  return true;
};
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var noop2 = () => {
};
var callAll2 = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
var tryCatch = (fn, fallback3) => {
  var _a8;
  try {
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, tryCatch);
    }
    return fallback3 == null ? void 0 : fallback3();
  }
};
var isDev2 = () => true;
var isArray = (v) => Array.isArray(v);
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject5 = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var isNull = (v) => v == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike(v) || baseGetTag(v) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};
var { floor, abs: abs2, round, min, max, pow, sign } = Math;
var isNaN2 = (v) => Number.isNaN(v);
var nan = (v) => isNaN2(v) ? 0 : v;
var mod = (v, m) => (v % m + m) % m;
var wrap2 = (v, vmax) => (v % vmax + vmax) % vmax;
var getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];
var isValueAtMax = (v, vmax) => nan(v) >= vmax;
var isValueAtMin = (v, vmin) => nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;
var roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step) => {
  let rv = v;
  let ss = step.toString();
  let pi = ss.indexOf(".");
  let p = pi >= 0 ? ss.length - pi : 0;
  if (p > 0) {
    let pw = pow(10, p);
    rv = round(rv * pw) / pw;
  }
  return rv;
};
var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var snapValueToStep = (v, vmin, vmax, step) => {
  vmin = Number(vmin);
  vmax = Number(vmax);
  let remainder = (v - (isNaN2(vmin) ? 0 : vmin)) % step;
  let sv = roundToStepPrecision(
    abs2(remainder) * 2 >= step ? v + sign(remainder) * (step - abs2(remainder)) : v - remainder,
    step
  );
  if (!isNaN2(vmin)) {
    if (sv < vmin) {
      sv = vmin;
    } else if (!isNaN2(vmax) && sv > vmax) {
      sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
    }
  } else if (!isNaN2(vmax) && sv > vmax) {
    sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
  }
  return roundToStepPrecision(sv, step);
};
var setValueAtIndex = (vs, i, v) => {
  if (vs[i] === v) return vs;
  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];
};
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getClosestValueIndex = (vs, t) => {
  let i = vs.findIndex((v) => t - v < 0);
  if (i === 0) return i;
  if (i === -1) return vs.length - 1;
  let vLeft = vs[i - 1];
  let vRight = vs[i];
  if (abs2(vLeft - t) < abs2(vRight - t)) return i - 1;
  return i;
};
var getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({
  min: i === 0 ? vmin : vs[i - 1] + gap,
  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
  value: v
}));
var getValueTransformer = (va, vb) => {
  const [a, b] = va;
  const [c, d] = vb;
  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);
};
var toFixedNumber = (v, d = 0, b = 10) => {
  const pow2 = Math.pow(b, d);
  return round(v * pow2) / pow2;
};
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
};
var decimalOp = (a, op, b) => {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
function compact2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function splitProps2(props25, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props25) {
    if (keySet.has(key)) {
      result[key] = props25[key];
    } else {
      rest[key] = props25[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props25) {
    return splitProps2(props25, keys);
  };
};
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}

// node_modules/@zag-js/core/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact2(obj);
    for (const key in target) {
      if (isPlainObject(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function toEvent(event) {
  const obj = isString2(event) ? { type: event } : event;
  return obj;
}
function toArray2(value) {
  if (!value) return [];
  return isArray(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject5(value) && value.predicate != null;
}
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a8;
    if (isString2(guard)) {
      return !!((_a8 = guardMap[guard]) == null ? void 0 : _a8.call(guardMap, ctx, event, meta));
    }
    if (isFunction2(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or, and, not, stateIn };
function choose(actions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      var _a8;
      return (_a8 = actions.find((def) => {
        const guard = def.guard ?? Truthy;
        return exec(guardMap, ctx, event, meta)(guard);
      })) == null ? void 0 : _a8.actions;
    }
  };
}
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString2(guard)) {
      const value = guardMap[guard];
      return isFunction2(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy2(config) {
  var _a8, _b7;
  const computedContext = config.computed ?? cast({});
  const initialContext = config.context ?? cast({});
  const initialTags = config.initial ? (_b7 = (_a8 = config.states) == null ? void 0 : _a8[config.initial]) == null ? void 0 : _b7.tags : [];
  const state2 = proxy({
    value: config.initial ?? "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a9, _b8;
      const stateEvents = ((_b8 = (_a9 = config.states) == null ? void 0 : _a9[this.value]) == null ? void 0 : _b8["on"]) ?? {};
      const globalEvents = (config == null ? void 0 : config.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue) return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state2);
}
function determineDelayFn(delay2, delaysMap) {
  return (context, event) => {
    if (isNumber(delay2)) return delay2;
    if (isFunction2(delay2)) {
      return delay2(context, event);
    }
    if (isString2(delay2)) {
      const value = Number.parseFloat(delay2);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay2];
        invariant(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay2}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction2(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString2(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray2(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config, options) {
    var _a8, _b7, _c6, _d6, _e6;
    __publicField(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField(this, "state");
    __publicField(this, "initialState");
    __publicField(this, "initialContext");
    __publicField(this, "id");
    __publicField(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField(this, "removeStateListener", noop2);
    __publicField(this, "parent");
    __publicField(this, "children", /* @__PURE__ */ new Map());
    __publicField(this, "guardMap");
    __publicField(this, "actionMap");
    __publicField(this, "delayMap");
    __publicField(this, "activityMap");
    __publicField(this, "sync");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "_created", () => {
      if (!this.config.created) return;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions(this.config.created, event);
    });
    __publicField(this, "start", (init) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray2(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject5(init) ? init.value : init;
      const context = isObject5(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next2 = this.getNextStateInfo(transition, event);
      this.initialState = next2;
      this.performStateChangeEffects(this.state.value, next2, event);
      return this;
    });
    __publicField(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch) return;
      let prev2 = snapshot(this.state.context);
      const cleanup = subscribe(this.state.context, () => {
        var _a9;
        const next2 = snapshot(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual3 = ((_a9 = this.options.compareFns) == null ? void 0 : _a9[key]) ?? Object.is;
          if (isEqual3(prev2[key], next2[key])) continue;
          this.executeActions(fn, this.state.event);
        }
        prev2 = next2;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField(this, "stop", () => {
      if (this.status === "Stopped") return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField(this, "stopActivities", (state2) => {
      var _a9, _b8;
      if (state2) {
        (_a9 = this.activityEvents.get(state2)) == null ? void 0 : _a9.forEach((stop) => stop());
        (_b8 = this.activityEvents.get(state2)) == null ? void 0 : _b8.clear();
        this.activityEvents.delete(state2);
      } else {
        this.activityEvents.forEach((state22) => {
          state22.forEach((stop) => stop());
          state22.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField(this, "spawn", (src, id) => {
      const actor = runIfFn(src);
      if (id) actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref(actor));
    });
    __publicField(this, "stopActivity", (key) => {
      var _a9;
      if (!this.state.value) return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      (_a9 = cleanups2 == null ? void 0 : cleanups2.get(key)) == null ? void 0 : _a9();
      cleanups2 == null ? void 0 : cleanups2.delete(key);
    });
    __publicField(this, "addActivityCleanup", (state2, key, cleanup) => {
      var _a9;
      if (!state2) return;
      if (!this.activityEvents.has(state2)) {
        this.activityEvents.set(state2, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        (_a9 = this.activityEvents.get(state2)) == null ? void 0 : _a9.set(key, cleanup);
      }
    });
    __publicField(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray2(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField(this, "setContext", (context) => {
      if (!context) return;
      deepMerge(this.state.context, compact2(context));
    });
    __publicField(this, "setOptions", (options2) => {
      const opts = compact2(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField(this, "getStateNode", (state2) => {
      var _a9;
      if (!state2) return;
      return (_a9 = this.config.states) == null ? void 0 : _a9[state2];
    });
    __publicField(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField(this, "getAfterActions", (transition, delay2) => {
      let id;
      const current = this.state.value;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next2 = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(current, next2, this.state.event);
          }, delay2);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField(this, "getDelayedEventActions", (state2) => {
      const stateNode = this.getStateNode(state2);
      const event = this.state.event;
      if (!stateNode || !stateNode.after) return;
      const entries = [];
      const exits = [];
      if (isArray(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition) return;
        if (!hasProp(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject5(stateNode.after)) {
        for (const delay2 in stateNode.after) {
          const transition = stateNode.after[delay2];
          const determineDelay = determineDelayFn(delay2, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField(this, "executeActions", (actions, event) => {
      var _a9;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray2(pickedActions)) {
        const fn = isString2(action) ? (_a9 = this.actionMap) == null ? void 0 : _a9[action] : action;
        warn(
          isString2(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event, this.meta);
      }
    });
    __publicField(this, "executeActivities", (event, activities, state2) => {
      var _a9;
      for (const activity of activities) {
        const fn = isString2(activity) ? (_a9 = this.activityMap) == null ? void 0 : _a9[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString2(activity) ? activity : activity.name || uuid();
          this.addActivityCleanup(state2 ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField(this, "createEveryActivities", (every, callbackfn) => {
      if (!every) return;
      if (isArray(every)) {
        const picked = toArray2(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked) return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay2 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay2);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay2 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay2);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event));
    });
    __publicField(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "") return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray2(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
      this.delayedEvents.delete(currentState);
    });
    __publicField(this, "performEntryEffects", (next2, event) => {
      const stateNode = this.getStateNode(next2);
      const activities = toArray2(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray2(pickedActions);
      const afterActions = this.getDelayedEventActions(next2);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next2, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition == null ? void 0 : transition.actions, event);
    });
    __publicField(this, "performStateChangeEffects", (current, next2, event) => {
      this.setEvent(event);
      const changed = next2.changed || next2.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next2.transition, event);
      this.setState(next2.target);
      if (changed) {
        this.performEntryEffects(next2.target, event);
      }
    });
    __publicField(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField(this, "sendParent", (evt) => {
      var _a9;
      if (!this.parent) {
        invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      (_a9 = this.parent) == null ? void 0 : _a9.send(event);
    });
    __publicField(this, "log", (...args) => {
      if (isDev2() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField(this, "transition", (state2, evt) => {
      var _a9, _b8;
      const stateNode = isString2(state2) ? this.getStateNode(state2) : state2 == null ? void 0 : state2.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state2}, \`event\`: ${event.type}`;
        warn(msg);
        return;
      }
      const transitions = (
        // @ts-expect-error - Fix this
        ((_a9 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a9[event.type]) ?? ((_b8 = this.config.on) == null ? void 0 : _b8[event.type])
      );
      const next2 = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next2, event);
      return next2.stateNode;
    });
    __publicField(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    this.config = clone(config);
    this.options = clone(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = ((_a8 = this.options) == null ? void 0 : _a8.guards) ?? {};
    this.actionMap = ((_b7 = this.options) == null ? void 0 : _b7.actions) ?? {};
    this.delayMap = ((_c6 = this.options) == null ? void 0 : _c6.delays) ?? {};
    this.activityMap = ((_d6 = this.options) == null ? void 0 : _d6.activities) ?? {};
    this.sync = ((_e6 = this.options) == null ? void 0 : _e6.sync) ?? false;
    this.state = createProxy2(this.config);
    this.initialContext = snapshot(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        var _a8;
        return ((_a8 = self2.initialState) == null ? void 0 : _a8.target) ?? "";
      }
    };
  }
  get meta() {
    var _a8;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a8 = this.initialState) == null ? void 0 : _a8.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
  getHydrationState() {
    const state2 = this.getState();
    return {
      value: state2.value,
      tags: state2.tags
    };
  }
};
var createMachine = (config, options) => new Machine(config, options);
var isMachine = (value) => {
  return value instanceof Machine || (value == null ? void 0 : value.type) === "machine";
};
var clsx2 = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize2 = (style) => {
  const res = {};
  let match5;
  while (match5 = CSS_REGEX.exec(style)) {
    res[match5[1]] = match5[2];
  }
  return res;
};
var css = (a, b) => {
  if (isString2(a)) {
    if (isString2(b)) return `${a};${b}`;
    a = serialize2(a);
  } else if (isString2(b)) {
    b = serialize2(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps2(...args) {
  let result = {};
  for (let props25 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props25[key] === "function") {
        result[key] = callAll2(props25[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx2(result[key], props25[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props25[key]);
        continue;
      }
      result[key] = props25[key] !== void 0 ? props25[key] : result[key];
    }
    for (let key in props25) {
      if (result[key] === void 0) {
        result[key] = props25[key];
      }
    }
  }
  return result;
}

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react13 = __toESM(require_react());
function getRef(element) {
  var _a8, _b7;
  let getter = (_a8 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a8.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b7 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b7.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react13.memo)(
    (0, import_react13.forwardRef)((props25, ref2) => {
      const { asChild, children, ...restProps } = props25;
      if (!asChild) {
        return (0, import_react13.createElement)(Component, { ...restProps, ref: ref2 }, children);
      }
      const onlyChild = import_react13.Children.only(children);
      if (!(0, import_react13.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0, import_react13.cloneElement)(onlyChild, {
        ...mergeProps2(restProps, onlyChild.props),
        ref: ref2 ? composeRefs(ref2, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps2 = () => (props25, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props25 }]
);

// node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js
var splitPresenceProps = (props25) => createSplitProps2()(props25, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps = () => (props25) => Array.from(new Set(props25));

// node_modules/@zag-js/presence/dist/index.mjs
function connect(state2, send, _normalize) {
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !state2.context.initial && present,
    present,
    setNode(node2) {
      if (!node2) return;
      send({ type: "NODE.SET", node: node2 });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function machine(ctx) {
  return createMachine(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial", "cleanupNode"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          after: {
            // Fallback to timeout to ensure we exit this state even if the `animationend` event
            // did not get trigger
            ANIMATION_DURATION: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          },
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      delays: {
        ANIMATION_DURATION(ctx2) {
          var _a8, _b7;
          return parseMs((_a8 = ctx2.styles) == null ? void 0 : _a8.animationDuration) + parseMs((_b7 = ctx2.styles) == null ? void 0 : _b7.animationDelay) + ANIMATION_TIMEOUT_MARGIN;
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        cleanupNode(ctx2) {
          ctx2.node = null;
          ctx2.styles = null;
        },
        invokeOnExitComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onExitComplete) == null ? void 0 : _a8.call(ctx2);
        },
        setNode(ctx2, evt) {
          ctx2.node = ref(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          var _a8;
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          if (!ctx2.present && ((_a8 = ctx2.node) == null ? void 0 : _a8.ownerDocument.visibilityState) === "hidden") {
            send({ type: "UNMOUNT", src: "visibilitychange" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            var _a9, _b7;
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ((_a9 = ctx2.styles) == null ? void 0 : _a9.display) === "none" || ((_b7 = ctx2.styles) == null ? void 0 : _b7.animationDuration) === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node2 = ctx2.node;
          if (!node2) return;
          const onStart = (event) => {
            var _a8, _b7;
            const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
            if (target === node2) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            var _a8, _b7;
            const animationName = getAnimationName(ctx2.styles);
            const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
            if (target === node2 && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node2.addEventListener("animationstart", onStart);
          node2.addEventListener("animationcancel", onEnd);
          node2.addEventListener("animationend", onEnd);
          return () => {
            node2.removeEventListener("animationstart", onStart);
            node2.removeEventListener("animationcancel", onEnd);
            node2.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function parseMs(value) {
  return parseFloat(value || "0") * 1e3;
}
var ANIMATION_TIMEOUT_MARGIN = 16.667;
var props = createProps()(["onExitComplete", "present", "immediate"]);

// node_modules/@zag-js/react/dist/index.mjs
var import_react14 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var normalizeProps = createNormalizer((v) => v);
var isArrayLike2 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual2 = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual2(a[i], b[i])) return false;
  }
  return true;
};
var isEqual2 = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike2(a) && isArrayLike2(b)) {
    return isArrayEqual2(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual2(a[key], b[key])) return false;
  }
  return true;
};
var isDev3 = () => true;
var fnToString2 = Function.prototype.toString;
fnToString2.call(Object);
function compact3(obj) {
  if (!isPlainObject3(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact3(value);
    }
  }
  return filtered;
}
var isPlainObject3 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = (0, import_react14.useRef)(false);
  const effect = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && effect.current;
    if (run) {
      return callback();
    }
    effect.current = true;
  }, deps);
  (0, import_react14.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var targetCache = globalRef("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context, sync: notifyInSync } = options ?? {};
  const lastSnapshot = (0, import_react14.useRef)(void 0);
  const lastAffected = (0, import_react14.useRef)(void 0);
  const currSnapshot = (0, import_react14.useSyncExternalStore)(
    (0, import_react14.useCallback)((callback) => subscribe(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot(service.state);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch {
      }
      return nextSnapshot;
    },
    () => snapshot(service.state)
  );
  service.setOptions({ actions });
  const ctx = (0, import_react14.useMemo)(() => compact3(context ?? {}), [context]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual2(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react14.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, import_react14.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state2 = useSnapshot(service);
  return [state2, service.send];
}
function useConstant(fn) {
  const ref2 = (0, import_react14.useRef)(void 0);
  if (!ref2.current) ref2.current = { v: fn() };
  return ref2.current.v;
}
var useSafeLayoutEffect = typeof document !== "undefined" ? import_react14.useLayoutEffect : import_react14.useEffect;
function useService(machine27, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine27 === "function" ? machine27() : machine27;
    if (context) instance.setContext(context);
    instance._created();
    return instance;
  });
  const snapshotRef = (0, import_react14.useRef)(void 0);
  useSafeLayoutEffect(() => {
    const stateInit = hydratedState ?? snapshotRef.current;
    service.start(stateInit);
    return () => {
      if (isDev3()) {
        snapshotRef.current = service.getHydrationState();
      }
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine27, options) {
  const service = useService(machine27, options);
  const state2 = useSnapshot(service, options);
  return [state2, service.send, service];
}

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var import_react17 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-event.js
var import_react15 = __toESM(require_react(), 1);
function useEvent(callback, opts = {}) {
  const { sync: sync5 = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0, import_react15.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a8;
      if (sync5) return queueMicrotask(() => {
        var _a9;
        return (_a9 = callbackRef.current) == null ? void 0 : _a9.call(callbackRef, ...args);
      });
      return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
    },
    [sync5, callbackRef]
  );
}
function useLatestRef(value) {
  const ref2 = (0, import_react15.useRef)(value);
  ref2.current = value;
  return ref2;
}

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var usePresence = (props25) => {
  const { lazyMount, unmountOnExit, present, ...rest } = props25;
  const wasEverPresent = (0, import_react17.useRef)(false);
  const context = {
    ...rest,
    present,
    onExitComplete: useEvent(props25.onExitComplete)
  };
  const [state2, send] = useMachine(machine(context), { context });
  const api = connect(state2, send, normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var Presence = (0, import_react18.forwardRef)((props25, ref2) => {
  const [presenceProps, localProps] = splitPresenceProps(props25);
  const presence = usePresence(presenceProps);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime9.jsx)(
    ark.div,
    {
      ...localProps,
      ...presence.getPresenceProps(),
      "data-scope": "presence",
      "data-part": "root",
      ref: composeRefs(presence.ref, ref2)
    }
  );
});
Presence.displayName = "Presence";

// node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js
var [PresenceProvider, usePresenceContext] = createContext3({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// node_modules/@chakra-ui/react/dist/esm/components/presence/index.js
var Presence2 = chakra(Presence);

// node_modules/@chakra-ui/react/dist/esm/components/theme.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var Theme = (0, import_react19.forwardRef)(
  function Theme2(props25, ref2) {
    const {
      appearance,
      style,
      className,
      hasBackground = true,
      ...rest
    } = props25;
    return (0, import_jsx_runtime10.jsx)(
      chakra.div,
      {
        color: "fg",
        bg: hasBackground ? "bg" : void 0,
        colorPalette: "gray",
        ...rest,
        className: cx("chakra-theme", appearance, className),
        style: { ...style, colorScheme: appearance },
        ref: ref2
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/hooks/use-callback-ref.js
var import_react20 = __toESM(require_react(), 1);
function useCallbackRef(callback, deps = []) {
  const callbackRef = (0, import_react20.useRef)(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  (0, import_react20.useInsertionEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react20.useCallback)((...args) => {
    var _a8;
    return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
  }, deps);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-controllable-state.js
var import_react21 = __toESM(require_react(), 1);
function useControllableProp(prop, state2) {
  const controlled = typeof prop !== "undefined";
  const value = controlled ? prop : state2;
  return (0, import_react21.useMemo)(() => [controlled, value], [controlled, value]);
}
function useControllableState(props25) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev2, next2) => prev2 !== next2
  } = props25;
  const onChangeProp = useCallbackRef(onChange);
  const shouldUpdateProp = useCallbackRef(shouldUpdate);
  const [uncontrolledState, setUncontrolledState] = (0, import_react21.useState)(defaultValue);
  const controlled = valueProp !== void 0;
  const value = controlled ? valueProp : uncontrolledState;
  const setValue = useCallbackRef(
    (next2) => {
      const setter = next2;
      const nextValue = typeof next2 === "function" ? setter(value) : next2;
      if (!shouldUpdateProp(value, nextValue)) {
        return;
      }
      if (!controlled) {
        setUncontrolledState(nextValue);
      }
      onChangeProp(nextValue);
    },
    [controlled, onChangeProp, value, shouldUpdateProp]
  );
  return [value, setValue];
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-disclosure.js
var import_react22 = __toESM(require_react(), 1);
function useDisclosure(props25 = {}) {
  const { onClose: onCloseProp, onOpen: onOpenProp, open: openProp } = props25;
  const handleOpen = useCallbackRef(onOpenProp);
  const handleClose = useCallbackRef(onCloseProp);
  const [openState, setopen] = (0, import_react22.useState)(props25.defaultOpen || false);
  const open = openProp !== void 0 ? openProp : openState;
  const isControlled = openProp !== void 0;
  const onClose = (0, import_react22.useCallback)(() => {
    if (!isControlled) {
      setopen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = (0, import_react22.useCallback)(() => {
    if (!isControlled) {
      setopen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = (0, import_react22.useCallback)(() => {
    if (open) {
      onClose();
    } else {
      onOpen();
    }
  }, [open, onOpen, onClose]);
  return {
    open,
    onOpen,
    onClose,
    onToggle
  };
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-media-query.js
var import_react23 = __toESM(require_react(), 1);
function listen(query2, callback) {
  try {
    query2.addEventListener("change", callback);
    return () => query2.removeEventListener("change", callback);
  } catch (e) {
    query2.addListener(callback);
    return () => query2.removeListener(callback);
  }
}
function useMediaQuery(query2, options) {
  const { fallback: _fallback, ssr = true, getWindow: getWindow3 } = options;
  const getWin = useCallbackRef(getWindow3);
  const queries = Array.isArray(query2) ? query2 : [query2];
  const fallback3 = _fallback == null ? void 0 : _fallback.filter((v) => v != null);
  const [value, setValue] = (0, import_react23.useState)(() => {
    return queries.map((query22, index) => {
      if (!ssr) {
        const { media, matches } = ((getWindow3 == null ? void 0 : getWindow3()) ?? window).matchMedia(query22);
        return { media, matches };
      }
      return { media: query22, matches: !!fallback3[index] };
    });
  });
  (0, import_react23.useEffect)(() => {
    const win = getWin() ?? window;
    setValue((prev2) => {
      const current = queries.map((query22) => {
        const { media, matches } = win.matchMedia(query22);
        return { media, matches };
      });
      return prev2.every(
        (v, i) => v.matches === current[i].matches && v.media === current[i].media
      ) ? prev2 : current;
    });
    const mql = queries.map((query22) => win.matchMedia(query22));
    const handler = (evt) => {
      setValue((prev2) => {
        return prev2.slice().map((item) => {
          if (item.media === evt.media) return { ...item, matches: evt.matches };
          return item;
        });
      });
    };
    const cleanups2 = mql.map((v) => listen(v, handler));
    return () => cleanups2.forEach((fn) => fn());
  }, [getWin]);
  return value.map((item) => item.matches);
}

// node_modules/@chakra-ui/react/dist/esm/hooks/use-breakpoint.js
function useBreakpoint(options = {}) {
  var _a8;
  options.fallback || (options.fallback = "base");
  const sys = useChakraContext();
  let fallbackPassed = false;
  const allBreakpoints = sys.breakpoints.values;
  const breakpoints2 = allBreakpoints.map(({ min: min4, name: breakpoint }) => {
    const item = {
      breakpoint,
      query: `(min-width: ${min4})`,
      fallback: !fallbackPassed
    };
    if (breakpoint === options.fallback) {
      fallbackPassed = true;
    }
    return item;
  }).filter(({ breakpoint }) => {
    var _a9;
    return !!((_a9 = options.breakpoints) == null ? void 0 : _a9.includes(breakpoint));
  });
  const fallback3 = breakpoints2.map(({ fallback: fallback22 }) => fallback22);
  const values = useMediaQuery(
    breakpoints2.map((bp) => bp.query),
    { fallback: fallback3, ssr: options.ssr }
  );
  const index = values.lastIndexOf(true);
  return ((_a8 = breakpoints2[index]) == null ? void 0 : _a8.breakpoint) ?? options.fallback;
}
function useBreakpointValue(value, opts) {
  const sys = useChakraContext();
  const normalized = sys.normalizeValue(value);
  const breakpoint = useBreakpoint({
    breakpoints: Object.keys(normalized),
    ...opts
  });
  return normalized[breakpoint];
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js
var colorMix = (value, token2) => {
  var _a8;
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token2(`colors.${rawColor}`);
  const opacityToken = (_a8 = token2.raw(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
var createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};

// node_modules/@chakra-ui/react/dist/esm/utils/clone.js
function clone2(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone2(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone2(obj[key]);
  }
  return _clone;
}

// node_modules/@chakra-ui/react/dist/esm/utils/merge.js
function merge2(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject(target[key]) && isObject(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject(source[key])) {
      merge2(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject(target[key][i]) && isObject(source[key][i])) {
          merge2(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge2(target, source);
  }
  return target;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/config.js
var defineConditions = (v) => v;
var defineRecipe = (v) => v;
var defineSlotRecipe = (v) => v;
var defineKeyframes = (v) => v;
var defineGlobalStyles = (v) => v;
var defineStyle = (v) => v;
var defineTextStyles = (v) => v;
var defineAnimationStyles = (v) => v;
var defineLayerStyles = (v) => v;
function createProxy3() {
  const identity = (v) => v;
  return new Proxy(identity, {
    get() {
      return identity;
    }
  });
}
var defineTokens = createProxy3();
var defineSemanticTokens = createProxy3();
var defineConfig = (v) => v;
var mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs.map(clone2));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js
var escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
var dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match5) => `-${match5.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback: fallback3 = "", prefix: prefix3 = "" } = options;
  const variable = dashCase(["-", prefix3, esc(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback3 ? `, ${fallback3}` : ""})`
  };
}

// node_modules/@chakra-ui/react/dist/esm/preset-base.js
var isCssVar2 = (v) => /^var\(--.+\)$/.test(v);
var wrap3 = (str, v) => v != null ? `${str}(${v})` : v;
var deg = (v) => {
  if (isCssVar2(v) || v == null) return v;
  const unitless = typeof v === "string" && !v.endsWith("deg");
  return typeof v === "number" || unitless ? `${v}deg` : v;
};
var createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token: token2 }) {
      const focusRingColor = token2("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
var divideColor = createColorMixTransform("borderColor");
var createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
var defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
var currentBgVar = cssVar("bg-currentcolor");
var isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
var colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
var defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj == null ? void 0 : styleObj.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj == null ? void 0 : styleObj.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: { values: "gradients", shorthand: ["bgImg", "bgImage"] },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderInlineEnd: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v) {
        if (v !== "auto") {
          return { filter: v };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v) => ({ "--blur": wrap3("blur", v) })
    },
    brightness: {
      transform: (v) => ({ "--brightness": wrap3("brightness", v) })
    },
    contrast: {
      transform: (v) => ({ "--contrast": wrap3("contrast", v) })
    },
    grayscale: {
      transform: (v) => ({ "--grayscale": wrap3("grayscale", v) })
    },
    hueRotate: {
      transform: (v) => ({ "--hue-rotate": wrap3("hue-rotate", deg(v)) })
    },
    invert: { transform: (v) => ({ "--invert": wrap3("invert", v) }) },
    saturate: {
      transform: (v) => ({ "--saturate": wrap3("saturate", v) })
    },
    sepia: { transform: (v) => ({ "--sepia": wrap3("sepia", v) }) },
    dropShadow: {
      transform: (v) => ({ "--drop-shadow": wrap3("drop-shadow", v) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v) {
        if (v !== "auto") {
          return { backdropFilter: v };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v) => ({ "--backdrop-blur": wrap3("blur", v) })
    },
    backdropBrightness: {
      transform: (v) => ({
        "--backdrop-brightness": wrap3("brightness", v)
      })
    },
    backdropContrast: {
      transform: (v) => ({ "--backdrop-contrast": wrap3("contrast", v) })
    },
    backdropGrayscale: {
      transform: (v) => ({
        "--backdrop-grayscale": wrap3("grayscale", v)
      })
    },
    backdropHueRotate: {
      transform: (v) => ({
        "--backdrop-hue-rotate": wrap3("hue-rotate", deg(v))
      })
    },
    backdropInvert: {
      transform: (v) => ({ "--backdrop-invert": wrap3("invert", v) })
    },
    backdropOpacity: {
      transform: (v) => ({ "--backdrop-opacity": wrap3("opacity", v) })
    },
    backdropSaturate: {
      transform: (v) => ({ "--backdrop-saturate": wrap3("saturate", v) })
    },
    backdropSepia: {
      transform: (v) => ({ "--backdrop-sepia": wrap3("sepia", v) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v) => ({ "--focus-ring-offset": v })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v) => ({ "--focus-ring-width": v })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v) => ({ "--focus-ring-style": v })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v) => ({ width: v, height: v })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token: token2 }) => {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token: token2 }) {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v) {
        switch (v) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v) => ({ "--scroll-snap-strictness": v })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v) => ({ "--ring-inset": v })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing", shorthand: ["mt"] },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v = value;
        if (value === "auto") {
          v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v };
      }
    },
    skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
    skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
    scaleX: { transform: (v) => ({ "--scale-x": v }) },
    scaleY: { transform: (v) => ({ "--scale-y": v }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v) => ({ "--translate-x": v })
    },
    translateY: {
      values: "spacing",
      transform: (v) => ({ "--translate-y": v })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
var srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};

// node_modules/@pandacss/is-valid-prop/dist/index.mjs
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo2(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = memo2((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});

// node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (getKey == null ? void 0 : getKey(prop, child)) ?? prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        const next2 = inner(child, childPath);
        if (isNotNullish(next2)) {
          result[key] = next2;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}

// node_modules/@chakra-ui/react/dist/esm/utils/flatten.js
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token2, paths) => {
      if (token2) {
        result[paths.join(".")] = token2.value;
      }
    },
    { stop }
  );
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/utils/memo.js
var memo3 = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get(...args) {
    const key = JSON.stringify(args);
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js
var BASE_FONT_SIZE = 16;
var UNIT_PX = "px";
var UNIT_EM = "em";
var UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit == null ? void 0 : unit[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get(name) {
    return values[name];
  }
  function only(name) {
    return build(get(name));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name) => {
      const value = get(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min4, max4]) => {
        const minValue = get(min4);
        const maxValue2 = get(max4);
        return [
          `${min4}To${capitalize(max4)}`,
          build({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get(name).min });
  }
  function down(name) {
    return build({ max: adjust(get(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min4], index, entries2) => {
    var _a8;
    let max4 = null;
    if (index <= entries2.length - 1) {
      max4 = (_a8 = entries2[index + 1]) == null ? void 0 : _a8[1];
    }
    if (max4 != null) {
      max4 = adjust(max4);
    }
    return [name, { name, min: toRem(min4), max: max4 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next2 = values[idx];
    while (next2) {
      result.push([current, next2]);
      idx++;
      next2 = values[idx];
    }
  });
  return result;
}
function build({ min: min4, max: max4 }) {
  if (min4 == null && max4 == null) return "";
  return [
    "@media screen",
    min4 && `(min-width: ${min4})`,
    max4 && `(max-width: ${max4})`
  ].filter(Boolean).join(" and ");
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js
var mapEntries = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
var createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v) => v !== "base").sort((a, b) => {
      const aa = has2(a);
      const bb = has2(b);
      if (aa && !bb) return 1;
      if (!aa && bb) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js
var createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
var widthRegex = createMediaQueryRegex("width");
var heightRegex = createMediaQueryRegex("height");
var createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
var { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
var { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
var lengthExec = /(\d)/;
var maxValue = Number.MAX_VALUE;
var multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query2) {
  const length2 = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
  if (!length2) return maxValue;
  if (length2[0] === "0") return 0;
  const number = parseFloat(length2[1]);
  const unit = length2[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
}
function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b), isPrintOnlyB = isPrintOnly.test(b);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a.localeCompare(b);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
var sortAtParams = memo3((a, b) => {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b) || isMinHeight(b), maxB = isMaxWidth(b) || isMaxHeight(b);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a), lengthB = getQueryLength(b);
  if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a.localeCompare(b);
});

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js
function sortQueries(queries) {
  return queries.sort(([a], [b]) => sortAtParams(a, b));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/css.js
var importantRegex = /\s*!(important)?/i;
var isImportant = (v) => isString(v) ? importantRegex.test(v) : false;
var withoutImportant = (v) => isString(v) ? v.replace(importantRegex, "").trim() : v;
function createCssFn(context) {
  const { transform: transform2, conditions, normalize: normalize2 } = context;
  const mergeFn = mergeCss(context);
  return memo3((...styleArgs) => {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize2(styles);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v) => isString(v) && important ? `${v} !important` : v,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  mergeWith(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => isObject(style) && Object.keys(compact(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo3((...styles) => {
    return mergeWith({}, ...resolve(styles));
  });
}

// node_modules/@chakra-ui/react/dist/esm/utils/omit.js
function omit(object, keysToOmit = []) {
  const clone3 = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone3) {
      delete clone3[key];
    }
  }
  return clone3;
}

// node_modules/@chakra-ui/react/dist/esm/utils/uniq.js
var uniq = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js
var defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize2, layers } = options;
  function cva(config = {}) {
    const { base, variants: variants3, defaultVariants: defaultVariants3, compoundVariants } = defaults(config);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize2,
      transform(prop, value) {
        var _a8;
        return (_a8 = variants3[prop]) == null ? void 0 : _a8[value];
      }
    });
    const resolve = (props25 = {}) => {
      const variantSelections = normalize2({
        ...defaultVariants3,
        ...compact(props25)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants3);
    const splitVariantProps = (props25) => {
      const restProps = omit(props25, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props25.colorPalette || defaultVariants3.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props25.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props25) => css2(resolve(props25));
    return Object.assign(cvaFn, {
      className: config.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva2(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva2(opts) {
  const { css: css2 } = opts;
  return function mergeCva22(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants3 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants3 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants3,
      defaultVariants: defaultVariants3,
      compoundVariants
    };
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js
var defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
var layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config) {
  const layers = config.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a, b) => layerOrder[a] - layerOrder[b]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js
function createNormalizeFn(context) {
  const { utility, normalize: normalize2 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return walkObject(styles, normalize2, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
      acc[k] = { [selector]: v };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize3(styles) {
    return walkObject(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char2 = selector[i];
    if (char2 === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char2;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char2;
      continue;
    }
    if (char2 === "(") {
      parenCount++;
    } else if (char2 === ")") {
      parenCount--;
    }
    if (char2 === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char2;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js
var getSlotRecipes = (config = {}) => {
  const init = (slot) => {
    var _a8;
    return {
      base: ((_a8 = config.base) == null ? void 0 : _a8[slot]) ?? {},
      variants: {},
      defaultVariants: config.defaultVariants ?? {},
      compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : []
    };
  };
  const slots = config.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a8;
        (_a8 = slotRecipe.variants)[variantsKey] ?? (_a8[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
var getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config = {}) {
    const slots = Object.entries(getSlotRecipes(config)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props25) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props25)]);
      return Object.fromEntries(result);
    }
    const variants3 = config.variants ?? {};
    const variantKeys = Object.keys(variants3);
    function splitVariantProps(props25) {
      var _a8;
      const restProps = omit(props25, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props25.colorPalette || ((_a8 = config.defaultVariants) == null ? void 0 : _a8.colorPalette);
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props25.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config.className) {
      classNameMap = Object.fromEntries(
        config.slots.map((slot) => [
          slot,
          `${config.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/create-props.js
var createProps2 = () => (props25) => Array.from(new Set(props25));

// node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
var fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint) return "\\" + ch;
  if (ch === "\0") return "�";
  if (ch === "-" && ch.length === 1) return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
var esc2 = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js
var expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state2 = "char";
  let tokenPath = "";
  let fallback3 = "";
  const currentStates = [];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state2 === "token") {
      if (char2 === ",") {
        if (str[index] === "") {
          index++;
        }
        state2 = "fallback";
        currentStates.push(state2);
        const resolved = resolve(tokenPath);
        if (resolved == null ? void 0 : resolved.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback3 = "";
        continue;
      }
    }
    if (state2 === "fallback") {
      const nextFallback = fallback3 + char2;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state2 = currentStates.pop() ?? state2;
        fallback3 = "";
        continue;
      }
    }
    if (state2 === "token" || state2 === "fallback") {
      index++;
      if (char2 === ")") {
        state2 = currentStates.pop() ?? state2 ?? "char";
        fallback3 += char2;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc2(tokenPath) : tokenPath;
        if (fallback3) {
          fallback3 = fallback3.slice(1).trim();
          if (!fallback3.startsWith("token(") && fallback3.endsWith(")")) {
            fallback3 = fallback3.slice(0, -1);
          }
          if (fallback3.includes("token(")) {
            const parsed = expandTokenReferences(fallback3, resolve);
            if (parsed) {
              fallback3 = parsed.slice(0, -1);
            }
          } else if (fallback3) {
            const resolvedFallback = resolve(fallback3);
            if (resolvedFallback) {
              fallback3 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback3) {
          if (lastChar == null ? void 0 : lastChar.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback3 + ")");
          } else {
            expanded += fallback3;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback3 = "";
        state2 = "char";
        continue;
      }
      if (state2 === "token") {
        tokenPath += char2;
      }
      if (state2 === "fallback") {
        fallback3 += char2;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state2 = "token";
      currentStates.push(state2);
      continue;
    }
    expanded += char2;
    index++;
  }
  return expanded;
};
var cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "(") {
      openedParenthesises.push(char2);
    } else if (char2 === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/references.js
var REFERENCE_REGEX = /({([^}]*)})/g;
var CURLY_REGEX = /[{}]/g;
var TOKEN_PATH_REGEX = /\w+\.\w+/;
var getReferences = (value) => {
  if (!isString(value)) return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches) return [];
  return matches.map((match5) => match5.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
var hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token2) {
  var _a8, _b7, _c6;
  if (!((_a8 = token2.extensions) == null ? void 0 : _a8.references)) {
    return ((_c6 = (_b7 = token2.extensions) == null ? void 0 : _b7.cssVar) == null ? void 0 : _c6.ref) ?? token2.value;
  }
  const references = token2.extensions.references ?? {};
  token2.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token2.value);
  delete token2.extensions.references;
  return token2.value;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js
function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add2 = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add2(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add: add2,
    subtract,
    multiply,
    divide,
    negate
  }
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix: prefix3, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token2) => {
      const originalPath = token2.path.slice();
      const originalVar = formatCssVar(originalPath, prefix3);
      if (isString(token2.value) && token2.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token2);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token2.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
var units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token2) => {
      return units.has(token2.extensions.category) && !token2.extensions.negative;
    });
    tokens.forEach((token2) => {
      Object.assign(token2.extensions, {
        pixelValue: toPx(token2.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token2) => {
      const { colorPalette } = token2.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        var _a8;
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token2);
        colorPalettes.set(name, colorPaletteList);
        if (token2.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token2 = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token2, "pre");
    });
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token2) => token2.value !== ""
    );
  }
};
var tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js
var addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token2, dictionary) {
    const { prefix: prefix3, formatCssVar } = dictionary;
    const { negative, originalPath } = token2.extensions;
    const path = negative ? originalPath : token2.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix3)
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token2, dictionary) {
    const { prefix: prefix3, formatCssVar } = dictionary;
    const refs = getReferences(token2.value);
    if (!refs.length) return token2.value;
    refs.forEach((ref2) => {
      const variable = formatCssVar(ref2.split("."), prefix3);
      token2.value = token2.value.replace(`{${variable.ref}}`, variable);
    });
    return token2.value;
  }
};
var addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token2) {
    return token2.extensions.category === "colors" && !token2.extensions.virtual;
  },
  transform(token2, dict) {
    let path = token2.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token2.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next2 = arr.slice(0, i + 1);
      acc.push(next2);
      return acc;
    }, []);
    const root = path[0];
    const value = dict.formatTokenName(path);
    const keys = token2.path.slice(token2.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
var tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js
var isToken = (value) => {
  return isObject(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix: prefix3 = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix22) => cssVar(path.join("-"), { prefix: prefix22 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token2, phase) {
    allTokens.push(token2);
    tokenNameMap.set(token2.name, token2);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token2);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry) ? { value: entry } : entry;
        const token2 = {
          value: t.value,
          originalValue: t.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;
        const token2 = {
          value: t.value.base || "",
          originalValue: t.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token2) {
    const { condition } = token2.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token2);
  }
  function buildCategoryMap(token2) {
    const { category, prop } = token2.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token2);
  }
  function buildCssVars(token2) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token2.value);
  }
  function buildFlatMap(token2) {
    const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap.set([category, prop].join("."), value);
  }
  function buildColorPalette(token2) {
    const { colorPalette, virtual, default: isDefault } = token2.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      var _a8;
      const name = formatTokenName(root);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token2.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token2.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token2.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token2) => {
      buildConditionMap(token2);
      buildCategoryMap(token2);
      buildCssVars(token2);
      buildFlatMap(token2);
      buildColorPalette(token2);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    var _a8;
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = (_a8 = getByName(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo3((value, fallback3) => {
    return flatMap.get(value) ?? fallback3;
  });
  const getCategoryValues = memo3((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo3((value) => {
    return expandTokenReferences(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix2(path, (v) => getVar(v));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path) ? esc2(path) : path;
    });
  });
  const dictionary = {
    prefix: prefix3,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token2) {
    if (token2.extensions.references) return;
    if (isFunction(transform2.match) && !transform2.match(token2)) return;
    const fn = (v) => transform2.transform(v, dictionary);
    const transformed = fn(token2);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token2.extensions, transformed);
        break;
      case transform2.type === "value":
        token2.value = transformed;
        break;
      default:
        token2[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware2) => {
      if (middleware2.enforce === enforce) {
        middleware2.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token2) => {
          transformToken(transform2, token2);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token2) => {
      const tokens2 = getConditionalTokens(token2);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token22) => {
        registerToken(token22);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref2) => getByName(ref2)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token2) => {
      if (!hasReference(token2.value)) return;
      const references = getTokenReferences(token2.value);
      token2.extensions.references = references.reduce((acc, ref2) => {
        acc[ref2.name] = ref2;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token2) => {
      expandReferences(token2);
    });
  }
  function build2() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build2();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item) => item !== "base");
}
function getConditionalTokens(token2) {
  if (!token2.extensions.conditions) return;
  const { conditions } = token2.extensions;
  const tokens = [];
  walkObject(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token2);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
var tokenCategories = createProps2()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);

// node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js
function normalize(config) {
  return config;
}
function normalizeConfig(config) {
  return Object.fromEntries(
    Object.entries(config).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config) {
    configs[property] = normalize(config);
    assignProperty(property, config);
  }
  const assignProperty = (property, config) => {
    const values = getPropertyValues(config);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config);
  };
  const assignProperties = () => {
    for (const [prop, config] of Object.entries(configs)) {
      if (!config) continue;
      assignProperty(prop, config);
    }
  };
  const assignShorthands = () => {
    for (const [property, config] of Object.entries(configs)) {
      const { shorthand } = config ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo3((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config) => {
    if (!config) return;
    const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set21 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      propTypes.set(property, set21.add(`CssProperties["${config.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set21 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set21, ...type]));
  };
  const getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  const getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn == null ? void 0 : resolveFn(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString(values)) {
      return (fn == null ? void 0 : fn(values)) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo3((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform2 = memo3((prop, raw) => {
    var _a8;
    const key = resolveShorthand(prop);
    if (isString(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config = configs[key];
    if (!config) {
      return defaultTransform(key, raw);
    }
    const value = (_a8 = propValues.get(key)) == null ? void 0 : _a8[raw];
    if (!config.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build2() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build2();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo3((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/system.js
function createSystem(...configs) {
  const config = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config;
  const layers = createLayers(config);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v) => isObject(v) && "value" in v
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo3(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue
  });
  const serialize3 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const cssObject = css2(serialize3({ [selector]: varsObj }));
      mergeWith(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize3(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props25) {
    return splitProps(props25, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback3) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.value) || fallback3;
  };
  tokenFn.var = (path, fallback3) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.variable) || fallback3;
  };
  function getRecipe(key, fallback3) {
    var _a8;
    return ((_a8 = theme.recipes) == null ? void 0 : _a8[key]) ?? fallback3;
  }
  function getSlotRecipe(key, fallback3) {
    var _a8;
    return ((_a8 = theme.slotRecipes) == null ? void 0 : _a8[key]) ?? fallback3;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config,
    _global,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token2) => {
    const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token2.value;
    map.set(token2.name, { value, variable: cssVar2.ref });
  });
  return map;
}
var isValidSystem = (mod2) => {
  return isObject(mod2) && !!Reflect.get(mod2, "$$chakra");
};

// node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js
var breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};

// node_modules/@chakra-ui/react/dist/esm/theme/global-css.js
var empty = "var(--chakra-empty,/*!*/ /*!*/)";
var globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.muted/80"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js
var layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js
var animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js
var badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js
var buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js
var checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js
var { variants, defaultVariants } = badgeRecipe;
var codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants,
  defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js
var colorSwatchRecipe = defineRecipe({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js
var containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js
var headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js
var iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js
var inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js
var inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js
var kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js
var linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js
var markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js
var radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js
var separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js
var skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js
var skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js
var spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js
var textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes.js
var recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe,
  colorSwatch: colorSwatchRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js
var semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js
var semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js
var semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-context.js
var [AccordionProvider, useAccordionContext] = createContext3({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "<AccordionProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-context.js
var AccordionContext = (props25) => props25.children(useAccordionContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts32 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts32)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts32, ...values]),
  rename: (newName) => createAnatomy(newName, parts32),
  keys: () => parts32,
  build: () => [...new Set(parts32)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var dom = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemContent) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemTrigger) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id))
});
function connect2(state2, send, normalize2) {
  const focusedValue = state2.context.focusedValue;
  const value = state2.context.value;
  const multiple = state2.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props25) {
    return {
      expanded: value.includes(props25.value),
      focused: focusedValue === props25.value,
      disabled: Boolean(props25.disabled ?? state2.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts.root.attrs,
        dir: state2.context.dir,
        id: dom.getRootId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts.item.attrs,
        dir: state2.context.dir,
        id: dom.getItemId(state2.context, props25.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation
      });
    },
    getItemContentProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts.itemContent.attrs,
        dir: state2.context.dir,
        role: "region",
        id: dom.getItemContentId(state2.context, props25.value),
        "aria-labelledby": dom.getItemTriggerId(state2.context, props25.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts.itemIndicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemTriggerProps(props25) {
      const { value: value2 } = props25;
      const itemState = getItemState(props25);
      return normalize2.button({
        ...parts.itemTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        id: dom.getItemTriggerId(state2.context, value2),
        "aria-controls": dom.getItemContentId(state2.context, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": state2.context.orientation,
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": dom.getRootId(state2.context),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            ArrowDown() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: state2.context.dir,
            orientation: state2.context.orientation
          });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and: and2, not: not2 } = guards;
function machine2(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: [],
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "coarseValue",
        multiple: "coarseValue"
      },
      created: "coarseValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNextTrigger"
            },
            "GOTO.PREV": {
              actions: "focusPrevTrigger"
            },
            "TRIGGER.CLICK": [
              {
                guard: and2("isExpanded", "canToggle"),
                actions: ["collapse"]
              },
              {
                guard: not2("isExpanded"),
                actions: ["expand"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirstTrigger"
            },
            "GOTO.LAST": {
              actions: "focusLastTrigger"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => ctx2.value.includes(evt.value)
      },
      actions: {
        collapse(ctx2, evt) {
          const next2 = ctx2.multiple ? remove(ctx2.value, evt.value) : [];
          set3.value(ctx2, ctx2.multiple ? next2 : []);
        },
        expand(ctx2, evt) {
          const next2 = ctx2.multiple ? add(ctx2.value, evt.value) : [evt.value];
          set3.value(ctx2, next2);
        },
        focusFirstTrigger(ctx2) {
          var _a8;
          (_a8 = dom.getFirstTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
        },
        focusLastTrigger(ctx2) {
          var _a8;
          (_a8 = dom.getLastTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
        },
        focusNextTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        focusPrevTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        setFocusedValue(ctx2, evt) {
          set3.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set3.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set3.value(ctx2, evt.value);
        },
        coarseValue(ctx2) {
          if (!ctx2.multiple && ctx2.value.length > 1) {
            warn(`The value of accordion should be a single value when multiple is false.`);
            ctx2.value = [ctx2.value[0]];
          }
        }
      }
    }
  );
}
var invoke = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: Array.from(ctx.value) });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, { value: ctx.focusedValue });
  }
};
var set3 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
var props2 = createProps()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
var splitProps3 = createSplitProps(props2);
var itemProps = createProps()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_react29 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-context.js
var [AccordionItemProvider, useAccordionItemContext] = createContext3({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react27 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/split-collapsible-props.js
var splitCollapsibleProps = (props25) => createSplitProps2()(props25, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy2 = createAnatomy("collapsible").parts("root", "trigger", "content");
var parts2 = anatomy2.build();
var dom2 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom2.getById(ctx, dom2.getRootId(ctx)),
  getContentEl: (ctx) => dom2.getById(ctx, dom2.getContentId(ctx)),
  getTriggerEl: (ctx) => dom2.getById(ctx, dom2.getTriggerId(ctx))
});
function connect3(state2, send, normalize2) {
  const visible = state2.matches("open", "closing");
  const open = state2.matches("open");
  const height = state2.context.height;
  const width = state2.context.width;
  const disabled = !!state2.context.disabled;
  const skip = !state2.context.initial && open;
  return {
    disabled,
    visible,
    open,
    measureSize() {
      send("SIZE.MEASURE");
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts2.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: state2.context.dir,
        id: dom2.getRootId(state2.context)
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts2.content.attrs,
        "data-collapsible": "",
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: dom2.getContentId(state2.context),
        "data-disabled": dataAttr(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts2.trigger.attrs,
        id: dom2.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": dom2.getContentId(state2.context),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "CLOSE" : "OPEN", src: "trigger.click" });
        }
      });
    }
  };
}
function machine3(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "collapsible",
      initial: ctx.open ? "open" : "closed",
      context: {
        ...ctx,
        height: 0,
        width: 0,
        initial: false,
        stylesRef: null,
        unmountAnimationName: null
      },
      watch: {
        open: ["setInitial", "computeSize", "toggleVisibility"]
      },
      exit: ["clearInitial", "cleanupNode"],
      states: {
        closed: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "computeSize", "invokeOnOpen"]
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackExitAnimation"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "invokeOnOpen"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnExitComplete"]
              },
              {
                target: "closed",
                actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
              }
            ],
            "ANIMATION.END": {
              target: "closed",
              actions: ["invokeOnExitComplete", "clearInitial"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEnterAnimation"],
          on: {
            "CONTROLLED.CLOSE": "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closing",
                actions: ["setInitial", "computeSize", "invokeOnClose"]
              }
            ],
            "SIZE.MEASURE": {
              actions: ["measureSize"]
            },
            "ANIMATION.END": {
              actions: ["clearInitial"]
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackEnterAnimation(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const target = getEventTarget(event);
              if (target === contentEl) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        },
        trackExitAnimation(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const win = contentEl.ownerDocument.defaultView || window;
              const animationName2 = win.getComputedStyle(contentEl).animationName;
              const target = getEventTarget(event);
              if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          raf(() => {
            ctx2.initial = false;
          });
        },
        cleanupNode(ctx2) {
          ctx2.stylesRef = null;
        },
        measureSize(ctx2) {
          const contentEl = dom2.getContentEl(ctx2);
          if (!contentEl) return;
          const { height, width } = contentEl.getBoundingClientRect();
          ctx2.height = height;
          ctx2.width = width;
        },
        computeSize(ctx2, evt) {
          var _a8;
          (_a8 = ctx2._rafCleanup) == null ? void 0 : _a8.call(ctx2);
          ctx2._rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            ctx2.stylesRef || (ctx2.stylesRef = ref({
              animationName: contentEl.style.animationName,
              animationDuration: contentEl.style.animationDuration
            }));
            if (evt.type === "CLOSE" || !ctx2.open) {
              const win = contentEl.ownerDocument.defaultView || window;
              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
            }
            const hidden = contentEl.hidden;
            contentEl.style.animationName = "none";
            contentEl.style.animationDuration = "0s";
            contentEl.hidden = false;
            const rect = contentEl.getBoundingClientRect();
            ctx2.height = rect.height;
            ctx2.width = rect.width;
            if (ctx2.initial) {
              contentEl.style.animationName = ctx2.stylesRef.animationName;
              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
            }
            contentEl.hidden = hidden;
          });
        },
        invokeOnOpen: (ctx2) => {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose: (ctx2) => {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnExitComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onExitComplete) == null ? void 0 : _a8.call(ctx2);
        },
        toggleVisibility: (ctx2, _evt, { send }) => {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE" });
        }
      }
    }
  );
}
var props3 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
var splitProps4 = createSplitProps(props3);

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var import_react25 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext3({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var useCollapsible = (props25 = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props25;
  const wasVisible = (0, import_react25.useRef)(false);
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react25.useId)(),
    dir,
    getRootNode,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    ...collapsibleProps
  };
  const context = {
    ...initialContext,
    open: props25.open,
    onOpenChange: useEvent(props25.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine3(initialContext), { context });
  const api = connect3(state2, send, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible-context.js
var [CollapsibleProvider, useCollapsibleContext] = createContext3({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var CollapsibleRoot = (0, import_react27.forwardRef)((props25, ref2) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props25);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps2(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime11.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime11.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
CollapsibleRoot.displayName = "CollapsibleRoot";

// node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, key + "", value);
var generateRGB_R = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_G = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_B = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateHSL_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSL_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "hsl(0, 0%, 50%)"
      ].join(",")
    }
  };
  return result;
};
var generateHSL_L = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      backgroundImage: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_B = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "#000"
      ].join(",")
    }
  };
  return result;
};
function getColorAreaGradient(color, options) {
  const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
  const { zChannel } = color.getColorAxes({ xChannel, yChannel });
  const zValue = color.getChannelValue(zChannel);
  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
  const orientation = ["top", dirProp === "rtl" ? "left" : "right"];
  let dir = false;
  let background = { areaStyles: {}, areaGradientStyles: {} };
  let alphaValue = (zValue - zMin) / (zMax - zMin);
  let isHSL = color.getFormat() === "hsla";
  switch (zChannel) {
    case "red": {
      dir = xChannel === "green";
      background = generateRGB_R(orientation, dir, zValue);
      break;
    }
    case "green": {
      dir = xChannel === "red";
      background = generateRGB_G(orientation, dir, zValue);
      break;
    }
    case "blue": {
      dir = xChannel === "red";
      background = generateRGB_B(orientation, dir, zValue);
      break;
    }
    case "hue": {
      dir = xChannel !== "saturation";
      if (isHSL) {
        background = generateHSL_H(orientation, dir, zValue);
      } else {
        background = generateHSB_H(orientation, dir, zValue);
      }
      break;
    }
    case "saturation": {
      dir = xChannel === "hue";
      if (isHSL) {
        background = generateHSL_S(orientation, dir, alphaValue);
      } else {
        background = generateHSB_S(orientation, dir, alphaValue);
      }
      break;
    }
    case "brightness": {
      dir = xChannel === "hue";
      background = generateHSB_B(orientation, dir, alphaValue);
      break;
    }
    case "lightness": {
      dir = xChannel === "hue";
      background = generateHSL_L(orientation, dir, zValue);
      break;
    }
  }
  return background;
}
var isEqualObject = (a, b) => {
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (let key in a) if (a[key] !== b[key]) return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    return getValuePercent(value, minValue, maxValue2);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue(percentToCheck, minValue, maxValue2, step);
    return snapValueToStep(percentValue, minValue, maxValue2, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    if (channel in this) {
      let clone3 = this.clone();
      clone3[channel] = clampValue(value, minValue, maxValue2);
      return clone3;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const value = snapValueToStep(
      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
      minValue,
      maxValue2,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor2 extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors2 = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors2.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
    }
    const match5 = value.match(/^rgba?\((.*)\)$/);
    if (match5 == null ? void 0 : match5[1]) {
      colors2 = match5[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
    }
    return colors2.length < 3 ? void 0 : new _RGBColor2(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min4;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const max4 = Math.max(red, green, blue);
    const lightness = (max4 + min4) / 2;
    const chroma = max4 - min4;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max4 + min4 : 2 - max4 - min4);
      switch (max4) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor2.colorChannels;
  }
};
__publicField2(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor2 extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor2.colorChannels;
  }
};
__publicField2(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor2 extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor2.colorChannels;
  }
};
__publicField2(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map.set(key, `#${val}`);
    if (key.includes("gray")) map.set(key.replace("gray", "grey"), `#${val}`);
  }
  return map;
};
var nativeColorMap = makeMap(nativeColors);
var parseColor = (value) => {
  var _a8;
  if (nativeColorMap.has(value)) {
    return parseColor(nativeColorMap.get(value));
  }
  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
  if (!result) {
    const error = new Error("Invalid color value: " + value);
    (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, parseColor);
    throw error;
  }
  return result;
};
var normalizeColor = (v) => {
  return typeof v === "string" ? parseColor(v) : v;
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset3 = clamp2(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node2) {
  if (isNode2(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node2) {
  var _ref;
  return (_ref = (isNode2(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement2(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName2(node2));
}
function getComputedStyle2(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node2) {
  if (getNodeName2(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot2(node2) && node2.host || // Fallback.
    getDocumentElement2(node2)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node2) {
  const parentNode = getParentNode2(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors2(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle2(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round2(rect.width) : rect.width) / width;
  let y = ($ ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL2(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL: isRTL2
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow2({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset2(({ placement }) => {
    var _a8, _b7;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a8 = opts.offset) == null ? void 0 : _a8.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b7 = opts.offset) == null ? void 0 : _b7.crossAxis) ?? shift22;
    return compact2({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip2({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift2({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift2()
  });
}
function getSizeMiddleware(opts) {
  return size2({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  var _a8;
  if (!opts.hideWhenDetached) return;
  return hide2({ strategy: "referenceHidden", boundary: ((_a8 = opts.boundary) == null ? void 0 : _a8.call(opts)) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware2 = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    var _a8;
    if (!reference || !floating) return;
    const pos = await computePosition2(reference, floating, {
      placement,
      middleware: middleware2,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached) {
      const isHidden = (_a8 = pos.middlewareData.hide) == null ? void 0 : _a8.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = getComputedStyle(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop2;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a8;
      for (let i = 0; i < ((_a8 = win.frames) == null ? void 0 : _a8.length); i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent == null ? void 0 : parent.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node2 of composedPath) {
    if (isHTMLElement(node2) && isFocusable(node2)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node2, event) {
  if (!isPointerEvent(event) || !node2) return false;
  const rect = node2.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node2, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node2) return;
  const doc = getDocument(node2);
  const win = getWindow(node2);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node2, target)) return false;
    if (isEventPointWithin(node2, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node2.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor(node2);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      var _a8;
      const func = defer ? raf : (v) => v();
      const composedPath = ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? [event.target];
      func(() => {
        if (!node2 || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll2(onPointerDownOutside, onInteractOutside);
          node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node2, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      if (!node2 || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll2(onFocusOutside, onInteractOutside);
        node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node2, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}

// node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node2, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent(getDocument(node2), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node2) {
    var _a8;
    const index = this.indexOf(node2);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a8 = this.topMostPointerBlockingLayer()) == null ? void 0 : _a8.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node2) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node2;
  },
  getNestedLayers(node2) {
    return Array.from(this.layers).slice(this.indexOf(node2) + 1);
  },
  isInNestedLayer(node2, target) {
    return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node2) {
    this.branches.push(node2);
  },
  remove(node2) {
    const index = this.indexOf(node2);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node2);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node2.style.removeProperty("--layer-index");
  },
  removeBranch(node2) {
    const index = this.branches.indexOf(node2);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node2) {
    return this.layers.findIndex((layer) => layer.node === node2);
  },
  dismiss(node2) {
    var _a8;
    (_a8 = this.layers[this.indexOf(node2)]) == null ? void 0 : _a8.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node: node2 }) => {
    node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
  });
}
function clearPointerEvent(node2) {
  node2.style.pointerEvents = "";
}
function disablePointerEventsOutside(node2, persistentElements) {
  const doc = getDocument(node2);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el) => {
      cleanups2.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node2, options) {
  if (!node2) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node: node2, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
    (_a8 = options.onPointerDownOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    (_a8 = options.onFocusOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a8;
    if (!layerStack.isTopMost(node2)) return;
    (_a8 = options.onEscapeKeyDown) == null ? void 0 : _a8.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a8;
    if (!node2) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a8 = options.persistentElements) == null ? void 0 : _a8.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node2, options.persistentElements) : void 0,
    trackEscapeKeydown(node2, onEscapeKeyDown),
    trackInteractOutside(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node2);
    assignPointerEventToLayers();
    clearPointerEvent(node2);
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node2, options));
    })
  );
  return () => {
    func(() => {
      cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    });
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node2) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node2);
      cleanups2.push(() => {
        layerStack.removeBranch(node2);
      });
    })
  );
  return () => {
    func(() => {
      cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    });
  };
}

// node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy3 = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts3 = anatomy3.build();
var dom3 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `color-picker:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `color-picker:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `color-picker:${ctx.id}:hidden-input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `color-picker:${ctx.id}:control`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `color-picker:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `color-picker:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `color-picker:${ctx.id}:positioner`;
  },
  getFormatSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.formatSelect) ?? `color-picker:${ctx.id}:format-select`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `color-picker:${ctx.id}:area`;
  },
  getAreaGradientId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
  },
  getAreaThumbId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
  },
  getChannelSliderTrackId: (ctx, channel) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderTrack) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  },
  getChannelSliderThumbId: (ctx, channel) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderThumb) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  },
  getContentEl: (ctx) => dom3.getById(ctx, dom3.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom3.getById(ctx, dom3.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom3.getById(ctx, dom3.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    const selector = `input[data-channel="${channel}"]`;
    return [
      ...queryAll(dom3.getContentEl(ctx), selector),
      ...queryAll(dom3.getControlEl(ctx), selector)
    ];
  },
  getFormatSelectEl: (ctx) => dom3.getById(ctx, dom3.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom3.getById(ctx, dom3.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom3.getById(ctx, dom3.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom3.getAreaEl(ctx);
    if (!areaEl) return;
    const { percent } = getRelativePoint(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom3.getById(ctx, dom3.getControlId(ctx)),
  getTriggerEl: (ctx) => dom3.getById(ctx, dom3.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom3.getById(ctx, dom3.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom3.getById(ctx, dom3.getChannelSliderTrackId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom3.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { percent } = getRelativePoint(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll(dom3.getContentEl(ctx), "input[data-channel]"),
      ...queryAll(dom3.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
function getChannelDisplayColor(color, channel) {
  switch (channel) {
    case "hue":
      return parseColor(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
    case "lightness":
    case "brightness":
    case "saturation":
    case "red":
    case "green":
    case "blue":
      return color.withChannelValue("alpha", 1);
    case "alpha": {
      return color;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
}
function getChannelValue(color, channel) {
  if (channel == null) return "";
  if (channel === "hex") {
    return color.toString("hex");
  }
  if (channel === "css") {
    return color.toString("css");
  }
  if (channel in color) {
    return color.getChannelValue(channel).toString();
  }
  const isHSL = color.getFormat() === "hsla";
  switch (channel) {
    case "hue":
      return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
    case "saturation":
      return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
    case "lightness":
      return color.toFormat("hsla").getChannelValue("lightness").toString();
    case "brightness":
      return color.toFormat("hsba").getChannelValue("brightness").toString();
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelValue(channel).toString();
    default:
      return color.getChannelValue(channel).toString();
  }
}
function getChannelRange(color, channel) {
  switch (channel) {
    case "hex":
      const minColor = parseColor("#000000");
      const maxColor = parseColor("#FFFFFF");
      return {
        minValue: minColor.toHexInt(),
        maxValue: maxColor.toHexInt(),
        pageSize: 10,
        step: 1
      };
    case "css":
      return void 0;
    case "hue":
    case "saturation":
    case "lightness":
      return color.toFormat("hsla").getChannelRange(channel);
    case "brightness":
      return color.toFormat("hsba").getChannelRange(channel);
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelRange(channel);
    default:
      return color.getChannelRange(channel);
  }
}
function getSliderBackgroundDirection(orientation, dir) {
  if (orientation === "vertical") {
    return "top";
  } else if (dir === "ltr") {
    return "right";
  } else {
    return "left";
  }
}
var getSliderBackground = (props25) => {
  const { channel, value, dir, orientation } = props25;
  const bgDirection = getSliderBackgroundDirection(orientation, dir);
  const { minValue, maxValue: maxValue2 } = value.getChannelRange(channel);
  switch (channel) {
    case "hue":
      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
    case "lightness": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let middle = value.withChannelValue(channel, (maxValue2 - minValue) / 2).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
    }
    case "saturation":
    case "brightness":
    case "red":
    case "green":
    case "blue":
    case "alpha": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
};
function connect4(state2, send, normalize2) {
  const value = state2.context.value;
  const areaValue = state2.context.areaValue;
  const valueAsString = state2.context.valueAsString;
  const disabled = state2.context.isDisabled;
  const interactive = state2.context.isInteractive;
  const dragging = state2.hasTag("dragging");
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const getAreaChannels = (props25) => {
    const channels = areaValue.getChannels();
    return {
      xChannel: props25.xChannel ?? channels[1],
      yChannel: props25.yChannel ?? channels[2]
    };
  };
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  function getSwatchTriggerState(props25) {
    const color = normalizeColor(props25.value).toFormat(state2.context.format);
    return {
      value: color,
      valueAsString: color.toString("hex"),
      checked: color.isEqual(value),
      disabled: props25.disabled || !interactive
    };
  }
  return {
    dragging,
    open,
    valueAsString,
    value,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: normalizeColor(value2), src: "set-color" });
    },
    getChannelValue(channel) {
      return getChannelValue(value, channel);
    },
    getChannelValueText(channel, locale) {
      return value.formatChannelValue(channel, locale);
    },
    setChannelValue(channel, channelValue) {
      const color = value.withChannelValue(channel, channelValue);
      send({ type: "VALUE.SET", value: color, src: "set-channel" });
    },
    format: state2.context.format,
    setFormat(format) {
      const formatValue2 = value.toFormat(format);
      send({ type: "VALUE.SET", value: formatValue2, src: "set-format" });
    },
    alpha: value.getChannelValue("alpha"),
    setAlpha(alphaValue) {
      const color = value.withChannelValue("alpha", alphaValue);
      send({ type: "VALUE.SET", value: color, src: "set-alpha" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts3.root.attrs,
        dir: state2.context.dir,
        id: dom3.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        style: {
          "--value": value.toString("css")
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts3.label.attrs,
        dir: state2.context.dir,
        id: dom3.getLabelId(state2.context),
        htmlFor: dom3.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-focus": dataAttr(focused),
        onClick(event) {
          event.preventDefault();
          const inputEl = query(dom3.getControlEl(state2.context), "[data-channel=hex]");
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts3.control.attrs,
        id: dom3.getControlId(state2.context),
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts3.trigger.attrs,
        id: dom3.getTriggerId(state2.context),
        dir: state2.context.dir,
        disabled,
        "aria-label": `select color. current color is ${valueAsString}`,
        "aria-controls": dom3.getContentId(state2.context),
        "aria-labelledby": dom3.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-placement": currentPlacement,
        "aria-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        type: "button",
        onClick() {
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "TRIGGER.BLUR" });
        },
        style: {
          position: "relative"
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts3.positioner.attrs,
        id: dom3.getPositionerId(state2.context),
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts3.content.attrs,
        id: dom3.getContentId(state2.context),
        dir: state2.context.dir,
        "data-placement": currentPlacement,
        "data-state": open ? "open" : "closed",
        hidden: !open
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts3.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused)
      });
    },
    getAreaProps(props25 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props25);
      const { areaStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize2.element({
        ...parts3.area.attrs,
        id: dom3.getAreaId(state2.context),
        role: "group",
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          const channel = { xChannel, yChannel };
          send({ type: "AREA.POINTER_DOWN", point, channel, id: "area" });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaStyles
        }
      });
    },
    getAreaBackgroundProps(props25 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props25);
      const { areaGradientStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize2.element({
        ...parts3.areaBackground.attrs,
        id: dom3.getAreaGradientId(state2.context),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaGradientStyles
        }
      });
    },
    getAreaThumbProps(props25 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props25);
      const channel = { xChannel, yChannel };
      const xPercent = areaValue.getChannelValuePercent(xChannel);
      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
      const xValue = areaValue.getChannelValue(xChannel);
      const yValue = areaValue.getChannelValue(yChannel);
      const color = areaValue.withChannelValue("alpha", 1).toString("css");
      return normalize2.element({
        ...parts3.areaThumb.attrs,
        id: dom3.getAreaThumbId(state2.context),
        dir: state2.context.dir,
        tabIndex: disabled ? void 0 : 0,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        role: "slider",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": xValue,
        "aria-label": `${xChannel} and ${yChannel}`,
        "aria-roledescription": "2d slider",
        "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
        style: {
          position: "absolute",
          left: `${xPercent * 100}%`,
          top: `${yPercent * 100}%`,
          transform: "translate(-50%, -50%)",
          touchAction: "none",
          forcedColorAdjust: "none",
          "--color": color,
          background: color
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "AREA.FOCUS", id: "area", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event);
          const keyMap2 = {
            ArrowUp() {
              send({ type: "AREA.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "AREA.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "AREA.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "AREA.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "AREA.PAGE_UP", channel, step });
            },
            PageDown() {
              send({ type: "AREA.PAGE_DOWN", channel, step });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getTransparencyGridProps(props25 = {}) {
      const { size: size3 = "12px" } = props25;
      return normalize2.element({
        ...parts3.transparencyGrid.attrs,
        style: {
          "--size": size3,
          width: "100%",
          height: "100%",
          position: "absolute",
          backgroundColor: "#fff",
          backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
          backgroundSize: "var(--size) var(--size)",
          inset: "0px",
          zIndex: "auto",
          pointerEvents: "none"
        }
      });
    },
    getChannelSliderProps(props25) {
      const { orientation = "horizontal", channel, format } = props25;
      return normalize2.element({
        ...parts3.channelSlider.attrs,
        "data-channel": channel,
        "data-orientation": orientation,
        role: "presentation",
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "CHANNEL_SLIDER.POINTER_DOWN", channel, format, point, id: channel, orientation });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none"
        }
      });
    },
    getChannelSliderTrackProps(props25) {
      const { orientation = "horizontal", channel, format } = props25;
      const normalizedValue = format ? value.toFormat(format) : areaValue;
      return normalize2.element({
        ...parts3.channelSliderTrack.attrs,
        id: dom3.getChannelSliderTrackId(state2.context, channel),
        role: "group",
        "data-channel": channel,
        "data-orientation": orientation,
        style: {
          position: "relative",
          forcedColorAdjust: "none",
          backgroundImage: getSliderBackground({
            orientation,
            channel,
            dir: state2.context.dir,
            value: normalizedValue
          })
        }
      });
    },
    getChannelSliderLabelProps(props25) {
      const { channel } = props25;
      return normalize2.element({
        ...parts3.channelSliderLabel.attrs,
        "data-channel": channel,
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          const thumbId = dom3.getChannelSliderThumbId(state2.context, channel);
          (_a8 = dom3.getById(state2.context, thumbId)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getChannelSliderValueTextProps(props25) {
      return normalize2.element({
        ...parts3.channelSliderValueText.attrs,
        "data-channel": props25.channel
      });
    },
    getChannelSliderThumbProps(props25) {
      const { orientation = "horizontal", channel, format } = props25;
      const normalizedValue = format ? value.toFormat(format) : areaValue;
      const channelRange = normalizedValue.getChannelRange(channel);
      const channelValue = normalizedValue.getChannelValue(channel);
      const offset3 = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);
      const placementStyles = orientation === "horizontal" ? { left: `${offset3 * 100}%`, top: "50%" } : { top: `${offset3 * 100}%`, left: "50%" };
      return normalize2.element({
        ...parts3.channelSliderThumb.attrs,
        id: dom3.getChannelSliderThumbId(state2.context, channel),
        role: "slider",
        "aria-label": channel,
        tabIndex: disabled ? void 0 : 0,
        "data-channel": channel,
        "data-disabled": dataAttr(disabled),
        "data-orientation": orientation,
        "aria-disabled": dataAttr(disabled),
        "aria-orientation": orientation,
        "aria-valuemax": channelRange.maxValue,
        "aria-valuemin": channelRange.minValue,
        "aria-valuenow": channelValue,
        "aria-valuetext": `${channel} ${channelValue}`,
        style: {
          forcedColorAdjust: "none",
          position: "absolute",
          background: getChannelDisplayColor(areaValue, channel).toString("css"),
          ...placementStyles
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "CHANNEL_SLIDER.FOCUS", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * channelRange.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CHANNEL_SLIDER.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "CHANNEL_SLIDER.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "CHANNEL_SLIDER.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "CHANNEL_SLIDER.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "CHANNEL_SLIDER.PAGE_UP", channel });
            },
            PageDown() {
              send({ type: "CHANNEL_SLIDER.PAGE_DOWN", channel });
            },
            Home() {
              send({ type: "CHANNEL_SLIDER.HOME", channel });
            },
            End() {
              send({ type: "CHANNEL_SLIDER.END", channel });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getChannelInputProps(props25) {
      const { channel } = props25;
      const isTextField = channel === "hex" || channel === "css";
      const channelRange = getChannelRange(value, channel);
      return normalize2.input({
        ...parts3.channelInput.attrs,
        dir: state2.context.dir,
        type: isTextField ? "text" : "number",
        "data-channel": channel,
        "aria-label": channel,
        spellCheck: false,
        autoComplete: "off",
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        readOnly: state2.context.readOnly,
        defaultValue: getChannelValue(value, channel),
        min: channelRange == null ? void 0 : channelRange.minValue,
        max: channelRange == null ? void 0 : channelRange.maxValue,
        step: channelRange == null ? void 0 : channelRange.step,
        onBeforeInput(event) {
          if (isTextField || !interactive) return;
          const value2 = event.currentTarget.value;
          if (value2.match(/[^0-9.]/g)) {
            event.preventDefault();
          }
        },
        onFocus(event) {
          if (!interactive) return;
          send({ type: "CHANNEL_INPUT.FOCUS", channel });
          event.currentTarget.select();
        },
        onBlur(event) {
          if (!interactive) return;
          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
          send({ type: "CHANNEL_INPUT.BLUR", channel, value: value2, isTextField });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (event.key === "Enter") {
            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
            send({ type: "CHANNEL_INPUT.CHANGE", channel, value: value2, isTextField });
            event.preventDefault();
          }
        },
        style: {
          appearance: "none",
          WebkitAppearance: "none",
          MozAppearance: "textfield"
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        type: "text",
        disabled,
        name: state2.context.name,
        tabIndex: -1,
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        id: dom3.getHiddenInputId(state2.context),
        style: visuallyHiddenStyle,
        defaultValue: valueAsString
      });
    },
    getEyeDropperTriggerProps() {
      return normalize2.button({
        ...parts3.eyeDropperTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        "aria-label": "Pick a color from the screen",
        onClick() {
          if (!interactive) return;
          send("EYEDROPPER.CLICK");
        }
      });
    },
    getSwatchGroupProps() {
      return normalize2.element({
        ...parts3.swatchGroup.attrs,
        role: "group"
      });
    },
    getSwatchTriggerState,
    getSwatchTriggerProps(props25) {
      const swatchState = getSwatchTriggerState(props25);
      return normalize2.button({
        ...parts3.swatchTrigger.attrs,
        disabled: swatchState.disabled,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `select ${swatchState.valueAsString} as the color`,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        "data-disabled": dataAttr(swatchState.disabled),
        onClick() {
          if (swatchState.disabled) return;
          send({ type: "SWATCH_TRIGGER.CLICK", value: swatchState.value });
        },
        style: {
          "--color": swatchState.valueAsString,
          position: "relative"
        }
      });
    },
    getSwatchIndicatorProps(props25) {
      const swatchState = getSwatchTriggerState(props25);
      return normalize2.element({
        ...parts3.swatchIndicator.attrs,
        dir: state2.context.dir,
        hidden: !swatchState.checked
      });
    },
    getSwatchProps(props25) {
      const { respectAlpha = true } = props25;
      const swatchState = getSwatchTriggerState(props25);
      const color = swatchState.value.toString(respectAlpha ? "css" : "hex");
      return normalize2.element({
        ...parts3.swatch.attrs,
        dir: state2.context.dir,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        style: {
          "--color": color,
          position: "relative",
          background: color
        }
      });
    },
    getFormatTriggerProps() {
      return normalize2.button({
        ...parts3.formatTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `change color format to ${getNextFormat(state2.context.format)}`,
        onClick(event) {
          if (event.currentTarget.disabled) return;
          const nextFormat = getNextFormat(state2.context.format);
          send({ type: "FORMAT.SET", format: nextFormat, src: "format-trigger" });
        }
      });
    },
    getFormatSelectProps() {
      return normalize2.select({
        ...parts3.formatSelect.attrs,
        "aria-label": "change color format",
        dir: state2.context.dir,
        defaultValue: state2.context.format,
        disabled,
        onChange(event) {
          const format = assertFormat(event.currentTarget.value);
          send({ type: "FORMAT.SET", format, src: "format-select" });
        }
      });
    }
  };
}
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
  const index = formats.indexOf(format);
  return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
  if (formatRegex.test(format)) return format;
  throw new Error(`Unsupported color format: ${format}`);
}
var parse2 = (colorString) => {
  return parseColor(colorString);
};
var { and: and3 } = guards;
function machine4(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "color-picker",
      initial: ctx.open ? "open" : "idle",
      context: {
        dir: "ltr",
        value: parse2("#000000"),
        format: "rgba",
        disabled: false,
        closeOnSelect: false,
        openAutoFocus: true,
        ...ctx,
        activeId: null,
        activeChannel: null,
        activeOrientation: null,
        fieldsetDisabled: false,
        restoreFocus: true,
        positioning: {
          ...ctx.positioning,
          placement: "bottom"
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        valueAsString: (ctx2) => ctx2.value.toString(ctx2.format),
        areaValue: (ctx2) => {
          const format = ctx2.format.startsWith("hsl") ? "hsla" : "hsba";
          return ctx2.value.toFormat(format);
        }
      },
      activities: ["trackFormControl"],
      watch: {
        value: ["syncInputElements"],
        format: ["syncFormatSelectElement"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "FORMAT.SET": {
          actions: ["setFormat"]
        },
        "CHANNEL_INPUT.CHANGE": {
          actions: ["setChannelColorFromInput"]
        },
        "EYEDROPPER.CLICK": {
          actions: ["openEyeDropper"]
        },
        "SWATCH_TRIGGER.CLICK": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              target: "focused",
              actions: ["setActiveChannel"]
            }
          }
        },
        focused: {
          tags: ["closed", "focused"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_INPUT.BLUR": {
              target: "idle",
              actions: ["setChannelColorFromInput"]
            },
            "TRIGGER.BLUR": {
              target: "idle"
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "AREA.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_SLIDER.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "AREA.ARROW_LEFT": {
              actions: ["decrementAreaXChannel"]
            },
            "AREA.ARROW_RIGHT": {
              actions: ["incrementAreaXChannel"]
            },
            "AREA.ARROW_UP": {
              actions: ["incrementAreaYChannel"]
            },
            "AREA.ARROW_DOWN": {
              actions: ["decrementAreaYChannel"]
            },
            "AREA.PAGE_UP": {
              actions: ["incrementAreaXChannel"]
            },
            "AREA.PAGE_DOWN": {
              actions: ["decrementAreaXChannel"]
            },
            "CHANNEL_SLIDER.ARROW_LEFT": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_RIGHT": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.HOME": {
              actions: ["setChannelToMin"]
            },
            "CHANNEL_SLIDER.END": {
              actions: ["setChannelToMax"]
            },
            "CHANNEL_INPUT.BLUR": {
              actions: ["setChannelColorFromInput"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "SWATCH_TRIGGER.CLICK": [
              {
                guard: and3("isOpenControlled", "closeOnSelect"),
                actions: ["setValue", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setValue", "invokeOnClose", "setReturnFocus"]
              },
              {
                actions: ["setValue"]
              }
            ]
          }
        },
        "open:dragging": {
          tags: ["open"],
          exit: ["clearActiveChannel"],
          activities: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "AREA.POINTER_MOVE": {
              actions: ["setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            "CHANNEL_SLIDER.POINTER_MOVE": {
              actions: ["setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const anchorEl = dom3.getTriggerEl(ctx2);
          const getPositionerEl = () => dom3.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom3.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            exclude: dom3.getTriggerEl(ctx2),
            defer: true,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        },
        trackFormControl(ctx2, _evt, { send, initialContext }) {
          const inputEl = dom3.getHiddenInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "VALUE.SET", value: initialContext.value, src: "form.reset" });
            }
          });
        },
        trackPointerMove(ctx2, evt, { send }) {
          return trackPointerMove(dom3.getDoc(ctx2), {
            onPointerMove({ point }) {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
              send({ type, point, format: evt.format });
            },
            onPointerUp() {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
              send({ type });
            }
          });
        },
        disableTextSelection(ctx2) {
          return disableTextSelection({ doc: dom3.getDoc(ctx2), target: dom3.getContentEl(ctx2) });
        }
      },
      actions: {
        openEyeDropper(ctx2) {
          const isSupported = "EyeDropper" in dom3.getWin(ctx2);
          if (!isSupported) return;
          const win = dom3.getWin(ctx2);
          const picker = new win.EyeDropper();
          picker.open().then(({ sRGBHex }) => {
            var _a8;
            const format = ctx2.value.getFormat();
            const color = parseColor(sRGBHex).toFormat(format);
            set4.value(ctx2, color);
            (_a8 = ctx2.onValueChangeEnd) == null ? void 0 : _a8.call(ctx2, { value: ctx2.value, valueAsString: ctx2.valueAsString });
          }).catch(() => void 0);
        },
        setActiveChannel(ctx2, evt) {
          ctx2.activeId = evt.id;
          if (evt.channel) ctx2.activeChannel = evt.channel;
          if (evt.orientation) ctx2.activeOrientation = evt.orientation;
        },
        clearActiveChannel(ctx2) {
          ctx2.activeChannel = null;
          ctx2.activeId = null;
          ctx2.activeOrientation = null;
        },
        setAreaColorFromPoint(ctx2, evt) {
          const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
          const { xChannel, yChannel } = evt.channel || ctx2.activeChannel;
          const percent = dom3.getAreaValueFromPoint(ctx2, evt.point);
          if (!percent) return;
          const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x);
          const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y);
          const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
          set4.value(ctx2, color);
        },
        setChannelColorFromPoint(ctx2, evt) {
          const channel = evt.channel || ctx2.activeId;
          const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
          const percent = dom3.getChannelSliderValueFromPoint(ctx2, evt.point, channel);
          if (!percent) return;
          const orientation = ctx2.activeOrientation || "horizontal";
          const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
          const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
          const color = normalizedValue.withChannelValue(channel, value);
          set4.value(ctx2, color);
        },
        setValue(ctx2, evt) {
          set4.value(ctx2, evt.value);
        },
        setFormat(ctx2, evt) {
          set4.format(ctx2, evt.format);
        },
        syncInputElements(ctx2) {
          sync.inputs(ctx2);
        },
        invokeOnChangeEnd(ctx2) {
          invoke2.changeEnd(ctx2);
        },
        setChannelColorFromInput(ctx2, evt) {
          const { channel, isTextField, value } = evt;
          const currentAlpha = ctx2.value.getChannelValue("alpha");
          let color;
          if (channel === "alpha") {
            let valueAsNumber = parseFloat(value);
            valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
            color = ctx2.value.withChannelValue("alpha", valueAsNumber);
          } else if (isTextField) {
            color = tryCatch(
              () => parse2(value).withChannelValue("alpha", currentAlpha),
              () => ctx2.value
            );
          } else {
            const current = ctx2.value.toFormat(ctx2.format);
            const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
            color = current.withChannelValue(channel, valueAsNumber);
          }
          sync.inputs(ctx2, color);
          set4.value(ctx2, color);
        },
        incrementChannel(ctx2, evt) {
          const color = ctx2.value.incrementChannel(evt.channel, evt.step);
          set4.value(ctx2, color);
        },
        decrementChannel(ctx2, evt) {
          const color = ctx2.value.decrementChannel(evt.channel, evt.step);
          set4.value(ctx2, color);
        },
        incrementAreaXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);
          set4.value(ctx2, color);
        },
        decrementAreaXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);
          set4.value(ctx2, color);
        },
        incrementAreaYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);
          set4.value(ctx2, color);
        },
        decrementAreaYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);
          set4.value(ctx2, color);
        },
        setChannelToMax(ctx2, evt) {
          const range2 = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range2.maxValue);
          set4.value(ctx2, color);
        },
        setChannelToMin(ctx2, evt) {
          const range2 = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range2.minValue);
          set4.value(ctx2, color);
        },
        focusAreaThumb(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getAreaThumbEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusChannelThumb(ctx2, evt) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getChannelSliderThumbEl(ctx2, evt.channel)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        setInitialFocus(ctx2) {
          if (!ctx2.openAutoFocus) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom3.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setReturnFocus(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        syncFormatSelectElement(ctx2) {
          sync.formatSelect(ctx2);
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        value: (a, b) => a.isEqual(b)
      }
    }
  );
}
var sync = {
  // sync channel inputs
  inputs(ctx, color) {
    const channelInputs = dom3.getChannelInputEls(ctx);
    raf(() => {
      channelInputs.forEach((inputEl) => {
        const channel = inputEl.dataset.channel;
        dom3.setValue(inputEl, getChannelValue(color || ctx.value, channel));
      });
    });
  },
  // sync format select
  formatSelect(ctx) {
    const selectEl = dom3.getFormatSelectEl(ctx);
    raf(() => {
      dom3.setValue(selectEl, ctx.format);
    });
  }
};
var invoke2 = {
  changeEnd(ctx) {
    var _a8;
    const value = ctx.value.toFormat(ctx.format);
    (_a8 = ctx.onValueChangeEnd) == null ? void 0 : _a8.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
  },
  change(ctx) {
    var _a8;
    const value = ctx.value.toFormat(ctx.format);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
    dispatchInputValueEvent(dom3.getHiddenInputEl(ctx), { value: ctx.valueAsString });
  },
  formatChange(ctx) {
    var _a8;
    (_a8 = ctx.onFormatChange) == null ? void 0 : _a8.call(ctx, { format: ctx.format });
  }
};
var set4 = {
  value(ctx, color) {
    if (!color || ctx.value.isEqual(color)) return;
    ctx.value = color;
    invoke2.change(ctx);
  },
  format(ctx, format) {
    if (ctx.format === format) return;
    ctx.format = format;
    invoke2.formatChange(ctx);
  }
};

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy4 = createAnatomy("date-picker").parts(
  "root",
  "label",
  "clearTrigger",
  "content",
  "control",
  "input",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "prevTrigger",
  "rangeText",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "viewTrigger",
  "viewControl",
  "yearSelect",
  "presetTrigger"
);
var parts4 = anatomy4.build();
var dom4 = createScope({
  getLabelId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.label) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:label:${index}`;
  },
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `datepicker:${ctx.id}`;
  },
  getTableId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.table) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:table:${id}`;
  },
  getTableHeaderId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableHeader) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:thead`;
  },
  getTableBodyId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableBody) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:tbody`;
  },
  getTableRowId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableRow) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:tr:${id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `datepicker:${ctx.id}:content`;
  },
  getCellTriggerId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.cellTrigger) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
  },
  getPrevTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
  },
  getNextTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:next:${view}`;
  },
  getViewTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.viewTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:view:${view}`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `datepicker:${ctx.id}:control`;
  },
  getInputId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:input:${index}`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `datepicker:${ctx.id}:trigger`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `datepicker:${ctx.id}:positioner`;
  },
  getMonthSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
  },
  getYearSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
  },
  getFocusedCell: (ctx, view = ctx.view) => query(
    dom4.getContentEl(ctx),
    `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`
  ),
  getTriggerEl: (ctx) => dom4.getById(ctx, dom4.getTriggerId(ctx)),
  getContentEl: (ctx) => dom4.getById(ctx, dom4.getContentId(ctx)),
  getInputEls: (ctx) => queryAll(dom4.getControlEl(ctx), `[data-part=input]`),
  getYearSelectEl: (ctx) => dom4.getById(ctx, dom4.getYearSelectId(ctx)),
  getMonthSelectEl: (ctx) => dom4.getById(ctx, dom4.getMonthSelectId(ctx)),
  getClearTriggerEl: (ctx) => dom4.getById(ctx, dom4.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom4.getById(ctx, dom4.getPositionerId(ctx)),
  getControlEl: (ctx) => dom4.getById(ctx, dom4.getControlId(ctx))
});
var { and: and4 } = guards;
var props4 = createProps()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "parse",
  "placeholder",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "open.controlled",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "view",
  "minView",
  "maxView"
]);
var splitProps5 = createSplitProps(props4);
var inputProps = createProps()(["index", "fixOnBlur"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@ark-ui/react/dist/utils/render-strategy.js
var [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext3({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
var splitRenderStrategyProps = (props25) => createSplitProps2()(props25, ["lazyMount", "unmountOnExit"]);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-props-context.js
var [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext3({
  name: "AccordionItemPropsContext",
  hookName: "useAccordionItemPropsContext",
  providerName: "<AccordionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var AccordionItem = (0, import_react29.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = splitItemProps(props25);
  const accordion = useAccordionContext();
  const renderStrategy = useRenderStrategyPropsContext();
  const mergedProps = mergeProps2(accordion.getItemProps(itemProps8), localProps);
  const item = accordion.getItemState(itemProps8);
  const itemContentProps = accordion.getItemContentProps(itemProps8);
  return (0, import_jsx_runtime12.jsx)(AccordionItemPropsProvider, { value: itemProps8, children: (0, import_jsx_runtime12.jsx)(AccordionItemProvider, { value: item, children: (0, import_jsx_runtime12.jsx)(
    CollapsibleRoot,
    {
      ref: ref2,
      open: item.expanded,
      ids: { content: itemContentProps.id },
      ...renderStrategy,
      ...mergedProps
    }
  ) }) });
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react33 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-content.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);
var CollapsibleContent = (0, import_react31.forwardRef)(
  (props25, ref2) => {
    const collapsible = useCollapsibleContext();
    if (collapsible.isUnmounted) {
      return null;
    }
    const mergedProps = mergeProps2(collapsible.getContentProps(), props25);
    return (0, import_jsx_runtime13.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleContent.displayName = "CollapsibleContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var splitVisibilityProps = createSplitProps2();
var AccordionItemContent = (0, import_react33.forwardRef)(
  (props25, ref2) => {
    const accordion = useAccordionContext();
    const itemProps8 = useAccordionItemPropsContext();
    const contentProps2 = accordion.getItemContentProps(itemProps8);
    const [, itemContentProps] = splitVisibilityProps(contentProps2, ["hidden", "data-state"]);
    const mergedProps = mergeProps2(itemContentProps, props25);
    return (0, import_jsx_runtime14.jsx)(CollapsibleContent, { ref: ref2, ...mergedProps });
  }
);
AccordionItemContent.displayName = "AccordionItemContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-context.js
var AccordionItemContext = (props25) => props25.children(useAccordionItemContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-indicator.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);
var AccordionItemIndicator = (0, import_react35.forwardRef)(
  (props25, ref2) => {
    const accordion = useAccordionContext();
    const itemProps8 = useAccordionItemPropsContext();
    const mergedProps = mergeProps2(accordion.getItemIndicatorProps(itemProps8), props25);
    return (0, import_jsx_runtime15.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemIndicator.displayName = "AccordionItemIndicator";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-trigger.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react37 = __toESM(require_react(), 1);
var AccordionItemTrigger = (0, import_react37.forwardRef)(
  (props25, ref2) => {
    const accordion = useAccordionContext();
    const itemProps8 = useAccordionItemPropsContext();
    const collapsible = useCollapsibleContext();
    const triggerProps2 = accordion.getItemTriggerProps(itemProps8);
    const mergedProps = mergeProps2(
      {
        ...triggerProps2,
        "aria-controls": collapsible.isUnmounted ? void 0 : triggerProps2["aria-controls"]
      },
      props25
    );
    return (0, import_jsx_runtime16.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemTrigger.displayName = "AccordionItemTrigger";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion.js
var import_react39 = __toESM(require_react(), 1);
var useAccordion = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react39.useId)(),
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onFocusChange: useEvent(props25.onFocusChange),
    onValueChange: useEvent(props25.onValueChange)
  };
  const [state2, send] = useMachine(machine2(initialContext), { context });
  return connect2(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var AccordionRoot = (0, import_react41.forwardRef)((props25, ref2) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props25);
  const [useAccordionProps, localProps] = createSplitProps2()(accordionProps, [
    "collapsible",
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
  ]);
  const accordion = useAccordion(useAccordionProps);
  const mergedProps = mergeProps2(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime17.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime17.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime17.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
AccordionRoot.displayName = "AccordionRoot";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root-provider.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react43 = __toESM(require_react(), 1);
var AccordionRootProvider = (0, import_react43.forwardRef)(
  (props25, ref2) => {
    const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props25);
    const [{ value: accordion }, localProps] = createSplitProps2()(
      accordionProps,
      ["value"]
    );
    const mergedProps = mergeProps2(accordion.getRootProps(), localProps);
    return (0, import_jsx_runtime18.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime18.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime18.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
AccordionRootProvider.displayName = "AccordionRootProvider";

// node_modules/@ark-ui/react/dist/components/accordion/accordion.js
var accordion_exports = {};
__export(accordion_exports, {
  Context: () => AccordionContext,
  Item: () => AccordionItem,
  ItemContent: () => AccordionItemContent,
  ItemContext: () => AccordionItemContext,
  ItemIndicator: () => AccordionItemIndicator,
  ItemTrigger: () => AccordionItemTrigger,
  Root: () => AccordionRoot,
  RootProvider: () => AccordionRootProvider
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js
var [DialogProvider, useDialogContext] = createContext3({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var DialogBackdrop = (0, import_react45.forwardRef)((props25, ref2) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps2(dialog.getBackdropProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime19.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogBackdrop.displayName = "DialogBackdrop";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var DialogCloseTrigger = (0, import_react47.forwardRef)(
  (props25, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps2(dialog.getCloseTriggerProps(), props25);
    return (0, import_jsx_runtime20.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DialogCloseTrigger.displayName = "DialogCloseTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var DialogContent = (0, import_react49.forwardRef)((props25, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(dialog.getContentProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime21.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogContent.displayName = "DialogContent";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js
var DialogContext = (props25) => props25.children(useDialogContext());

// node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var DialogDescription = (0, import_react51.forwardRef)(
  (props25, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps2(dialog.getDescriptionProps(), props25);
    return (0, import_jsx_runtime22.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DialogDescription.displayName = "DialogDescription";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var DialogPositioner = (0, import_react53.forwardRef)((props25, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getPositionerProps(), props25);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime23.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
DialogPositioner.displayName = "DialogPositioner";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/aria-hidden/dist/index.mjs
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node2) => node2 && (node2.host || unwrapHost(node2.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x) => Boolean(x));
var isIgnoredNode = (node2) => {
  if (node2.localName === "next-route-announcer") return true;
  if (node2.localName === "script") return true;
  if (node2.hasAttribute("aria-live")) return true;
  return node2.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props25) => {
  const { parentNode, markerName, controlAttribute } = props25;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node2) => {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          if (isIgnoredNode(node2)) return;
          const attr = node2.getAttribute(controlAttribute);
          const alreadyHidden = attr !== null && attr !== "false";
          const counterValue = (counterMap.get(node2) || 0) + 1;
          const markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "");
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node2, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node2) => {
      const counterValue = counterMap.get(node2) - 1;
      const markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode3 = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode3(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"
  });
};
var raf2 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf2 : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups2.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/focus-trap/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField3(this, "trapStack");
    __publicField3(this, "config");
    __publicField3(this, "doc");
    __publicField3(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField3(this, "listenerCleanups", []);
    __publicField3(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node2) => node2 === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField3(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField3(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField3(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField3(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField3(this, "_mutationObserver");
    __publicField3(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node2) => node2 === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField3(this, "updateObservedNodes", () => {
      var _a8;
      (_a8 = this._mutationObserver) == null ? void 0 : _a8.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          var _a9;
          (_a9 = this._mutationObserver) == null ? void 0 : _a9.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField3(this, "getInitialFocusNode", () => {
      let node2 = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node2 === false) {
        return false;
      }
      if (node2 === void 0 || node2 && !isFocusable(node2)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node2 = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node2 = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node2 === null) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      if (!node2) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node2.isConnected) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      return node2;
    });
    __publicField3(this, "tryFocus", (node2) => {
      if (node2 === false) return;
      if (node2 === getActiveElement(this.doc)) return;
      if (!node2 || !node2.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node2.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node2;
      if (isSelectableInput(node2)) {
        node2.select();
      }
    });
    __publicField3(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options2 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options2, "onDeactivate");
      const onPostDeactivate = this.getOption(options2, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options2, "checkCanReturnFocus");
      const returnFocus = this.getOption(options2, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate == null ? void 0 : onDeactivate();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate == null ? void 0 : onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField3(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause == null ? void 0 : onPause();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause == null ? void 0 : onPostPause();
      return this;
    });
    __publicField3(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause == null ? void 0 : onUnpause();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause == null ? void 0 : onPostUnpause();
      return this;
    });
    __publicField3(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField3(this, "getReturnFocusNode", (previousActiveElement) => {
      const node2 = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node2 ? node2 : node2 === false ? false : previousActiveElement;
    });
    __publicField3(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField3(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node2 = optionValue;
      if (typeof optionValue === "string") {
        try {
          node2 = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node2) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node2;
    });
    __publicField3(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false)))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target)))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e) {
        return isTabEvent(e) && !e.shiftKey;
      },
      isKeyBackward(e) {
        return isTabEvent(e) && e.shiftKey;
      },
      ...options
    };
    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof (event == null ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || (composedPath == null ? void 0 : composedPath.includes(container)) || tabbableNodes.find((node2) => node2 === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node2) => isTabbable(node2));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node2) => isTabbable(node2));
      const posTabIndexesFound = !!tabbableNodes.find((node2) => getTabIndex(node2) > 0);
      function nextTabbableNode(node2, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node2);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find((el) => isTabbable(el));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find((el) => isTabbable(el));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate == null ? void 0 : onActivate();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate == null ? void 0 : onPostActivate();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node2) => node2.localName === "input" && "select" in node2 && typeof node2.select === "function";
function trapFocus(el, options = {}) {
  let trap;
  const cleanup = raf(() => {
    const contentEl = typeof el === "function" ? el() : el;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap == null ? void 0 : trap.deactivate();
    cleanup();
  };
}

// node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el, style) {
  if (!el) return;
  const previousStyle = Object.keys(style).reduce(
    (acc, key) => {
      acc[key] = el.style.getPropertyValue(key);
      return acc;
    },
    {}
  );
  Object.assign(el.style, style);
  return () => {
    Object.assign(el.style, previousStyle);
  };
}
function setCSSProperty(el, property, value) {
  if (!el) return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy5 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts5 = anatomy5.build();
var dom5 = createScope({
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom5.getById(ctx, dom5.getContentId(ctx)),
  getPositionerEl: (ctx) => dom5.getById(ctx, dom5.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom5.getById(ctx, dom5.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom5.getById(ctx, dom5.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom5.getById(ctx, dom5.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom5.getById(ctx, dom5.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom5.getById(ctx, dom5.getCloseTriggerId(ctx))
});
function connect5(state2, send, normalize2) {
  const ariaLabel = state2.context["aria-label"];
  const open = state2.matches("open");
  const rendered = state2.context.renderedElements;
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts5.trigger.attrs,
        dir: state2.context.dir,
        id: dom5.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom5.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        }
      });
    },
    getBackdropProps() {
      return normalize2.element({
        ...parts5.backdrop.attrs,
        dir: state2.context.dir,
        hidden: !open,
        id: dom5.getBackdropId(state2.context),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts5.positioner.attrs,
        dir: state2.context.dir,
        id: dom5.getPositionerId(state2.context),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts5.content.attrs,
        dir: state2.context.dir,
        role: state2.context.role,
        hidden: !open,
        id: dom5.getContentId(state2.context),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom5.getTitleId(state2.context),
        "aria-describedby": rendered.description ? dom5.getDescriptionId(state2.context) : void 0
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts5.title.attrs,
        dir: state2.context.dir,
        id: dom5.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts5.description.attrs,
        dir: state2.context.dir,
        id: dom5.getDescriptionId(state2.context)
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts5.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom5.getCloseTriggerId(state2.context),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send("CLOSE");
        }
      });
    }
  };
}
function machine5(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscape: true,
        restoreFocus: true,
        ...ctx
      },
      created: ["setAlertDialogProps"],
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements", "syncZIndex"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed"
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom5.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom5.getTriggerEl(ctx2)],
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            persistentElements: ctx2.persistentElements,
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (!ctx2.closeOnEscape) {
                event.preventDefault();
              }
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll) return;
          return preventBodyScroll(dom5.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal) return;
          const contentEl = () => dom5.getContentEl(ctx2);
          return trapFocus(contentEl, {
            preventScroll: true,
            returnFocusOnDeactivate: !!ctx2.restoreFocus,
            initialFocus: ctx2.initialFocusEl,
            setReturnFocus: (el) => {
              var _a8;
              return ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? el;
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom5.getContentEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        }
      },
      actions: {
        setAlertDialogProps(ctx2) {
          if (ctx2.role !== "alertdialog") return;
          ctx2.initialFocusEl || (ctx2.initialFocusEl = () => dom5.getCloseTriggerEl(ctx2));
          ctx2.closeOnInteractOutside = false;
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            ctx2.renderedElements.title = !!dom5.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom5.getDescriptionEl(ctx2);
          });
        },
        syncZIndex(ctx2) {
          raf(() => {
            const contentEl = dom5.getContentEl(ctx2);
            if (!contentEl) return;
            const styles = getComputedStyle(contentEl);
            const elems = [dom5.getPositionerEl(ctx2), dom5.getBackdropEl(ctx2)];
            elems.forEach((node2) => {
              node2 == null ? void 0 : node2.style.setProperty("--z-index", styles.zIndex);
            });
          });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props5 = createProps()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps6 = createSplitProps(props5);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js
var import_react55 = __toESM(require_react(), 1);
var useDialog = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react55.useId)(),
    getRootNode,
    dir,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    ...props25
  };
  const context = {
    ...initialContext,
    open: props25.open,
    onOpenChange: useEvent(props25.onOpenChange, { sync: true }),
    onEscapeKeyDown: useEvent(props25.onEscapeKeyDown),
    onInteractOutside: useEvent(props25.onInteractOutside)
  };
  const [state2, send] = useMachine(machine5(initialContext), { context });
  return connect5(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var DialogRoot = (props25) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props25);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps2({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime24.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime24.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime24.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var DialogRootProvider = (props25) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props25);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps2({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime25.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime25.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime25.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react59 = __toESM(require_react(), 1);
var DialogTitle = (0, import_react59.forwardRef)((props25, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps2(dialog.getTitleProps(), props25);
  return (0, import_jsx_runtime26.jsx)(ark.h2, { ...mergedProps, ref: ref2 });
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react61 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react61.forwardRef)((props25, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props25
  );
  return (0, import_jsx_runtime27.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
DialogTrigger.displayName = "DialogTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog.js
var dialog_exports = {};
__export(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react63 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable-context.js
var [EditableProvider, useEditableContext] = createContext3({
  name: "EditableContext",
  hookName: "useEditableContext",
  providerName: "<EditableProvider />"
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var EditableArea = (0, import_react63.forwardRef)((props25, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getAreaProps(), props25);
  return (0, import_jsx_runtime28.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableArea.displayName = "EditableArea";

// node_modules/@ark-ui/react/dist/components/editable/editable-cancel-trigger.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var EditableCancelTrigger = (0, import_react65.forwardRef)(
  (props25, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps2(editable.getCancelTriggerProps(), props25);
    return (0, import_jsx_runtime29.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableCancelTrigger.displayName = "EditableCancelTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-context.js
var EditableContext = (props25) => props25.children(useEditableContext());

// node_modules/@ark-ui/react/dist/components/editable/editable-control.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var EditableControl = (0, import_react67.forwardRef)((props25, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getControlProps(), props25);
  return (0, import_jsx_runtime30.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableControl.displayName = "EditableControl";

// node_modules/@ark-ui/react/dist/components/editable/editable-edit-trigger.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var EditableEditTrigger = (0, import_react69.forwardRef)(
  (props25, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps2(editable.getEditTriggerProps(), props25);
    return (0, import_jsx_runtime31.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableEditTrigger.displayName = "EditableEditTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react71 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field-context.js
var [FieldProvider, useFieldContext] = createContext3({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var EditableInput = (0, import_react71.forwardRef)((props25, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getInputProps(), props25);
  const field = useFieldContext();
  return (0, import_jsx_runtime32.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
});
EditableInput.displayName = "EditableInput";

// node_modules/@ark-ui/react/dist/components/editable/editable-label.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);
var EditableLabel = (0, import_react73.forwardRef)((props25, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getLabelProps(), props25);
  return (0, import_jsx_runtime33.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
EditableLabel.displayName = "EditableLabel";

// node_modules/@ark-ui/react/dist/components/editable/editable-preview.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react75 = __toESM(require_react(), 1);
var EditablePreview = (0, import_react75.forwardRef)((props25, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps2(editable.getPreviewProps(), props25);
  return (0, import_jsx_runtime34.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
EditablePreview.displayName = "EditablePreview";

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);

// node_modules/@zag-js/editable/dist/index.mjs
var anatomy6 = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts6 = anatomy6.build();
var dom6 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `editable:${ctx.id}:control`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom6.getById(ctx, dom6.getInputId(ctx)),
  getPreviewEl: (ctx) => dom6.getById(ctx, dom6.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom6.getById(ctx, dom6.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom6.getById(ctx, dom6.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom6.getById(ctx, dom6.getEditTriggerId(ctx))
});
function connect6(state2, send, normalize2) {
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const readOnly = state2.context.readOnly;
  const invalid = state2.context.invalid;
  const autoResize = state2.context.autoResize;
  const translations = state2.context.translations;
  const editing = state2.matches("edit");
  const placeholderProp = state2.context.placeholder;
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = state2.context.value;
  const empty2 = value.trim() === "";
  const valueText = empty2 ? (placeholder == null ? void 0 : placeholder.preview) ?? "" : value;
  return {
    editing,
    empty: empty2,
    value,
    valueText,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2, src: "setValue" });
    },
    clearValue() {
      send({ type: "VALUE.SET", value: "", src: "clearValue" });
    },
    edit() {
      if (!interactive) return;
      send("EDIT");
    },
    cancel() {
      if (!interactive) return;
      send("CANCEL");
    },
    submit() {
      if (!interactive) return;
      send("SUBMIT");
    },
    getRootProps() {
      return normalize2.element({
        ...parts6.root.attrs,
        id: dom6.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getAreaProps() {
      return normalize2.element({
        ...parts6.area.attrs,
        id: dom6.getAreaId(state2.context),
        dir: state2.context.dir,
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": dataAttr(editing),
        "data-disabled": dataAttr(disabled),
        "data-placeholder-shown": dataAttr(empty2)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts6.label.attrs,
        id: dom6.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom6.getInputId(state2.context),
        "data-focus": dataAttr(editing),
        "data-invalid": dataAttr(invalid),
        onClick() {
          if (editing) return;
          const previewEl = dom6.getPreviewEl(state2.context);
          previewEl == null ? void 0 : previewEl.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts6.input.attrs,
        dir: state2.context.dir,
        "aria-label": translations.input,
        name: state2.context.name,
        form: state2.context.form,
        id: dom6.getInputId(state2.context),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder == null ? void 0 : placeholder.edit,
        maxLength: state2.context.maxLength,
        required: state2.context.required,
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        "data-readonly": dataAttr(readOnly),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "data-autoresize": dataAttr(autoResize),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({ type: "VALUE.SET", src: "input.change", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Escape() {
              send("CANCEL");
              event.preventDefault();
            },
            Enter(event2) {
              if (!state2.context.submitOnEnter) return;
              const { localName } = event2.currentTarget;
              if (localName === "textarea") {
                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;
                if (!submitMod) return;
                send({ type: "SUBMIT", src: "keydown.enter" });
                return;
              }
              if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                send({ type: "SUBMIT", src: "keydown.enter" });
                event2.preventDefault();
              }
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            exec2(event);
          }
        },
        style: autoResize ? {
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize2.element({
        id: dom6.getPreviewId(state2.context),
        ...parts6.preview.attrs,
        dir: state2.context.dir,
        "data-placeholder-shown": dataAttr(empty2),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": ariaAttr(disabled),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.edit,
        "data-autoresize": dataAttr(autoResize),
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive ? 0 : void 0,
        onClick() {
          if (!interactive) return;
          if (state2.context.activationMode !== "click") return;
          send({ type: "EDIT", src: "click" });
        },
        onFocus() {
          if (!interactive) return;
          if (state2.context.activationMode !== "focus") return;
          send({ type: "EDIT", src: "focus" });
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (state2.context.activationMode !== "dblclick") return;
          send({ type: "EDIT", src: "dblclick" });
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize2.button({
        ...parts6.editTrigger.attrs,
        id: dom6.getEditTriggerId(state2.context),
        dir: state2.context.dir,
        "aria-label": translations.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "EDIT", src: "edit.click" });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: dom6.getControlId(state2.context),
        ...parts6.control.attrs,
        dir: state2.context.dir
      });
    },
    getSubmitTriggerProps() {
      return normalize2.button({
        ...parts6.submitTrigger.attrs,
        dir: state2.context.dir,
        id: dom6.getSubmitTriggerId(state2.context),
        "aria-label": translations.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "SUBMIT", src: "submit.click" });
        }
      });
    },
    getCancelTriggerProps() {
      return normalize2.button({
        ...parts6.cancelTrigger.attrs,
        dir: state2.context.dir,
        "aria-label": translations.cancel,
        id: dom6.getCancelTriggerId(state2.context),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CANCEL", src: "cancel.click" });
        }
      });
    }
  };
}
var submitOnEnter = (ctx) => ["both", "enter"].includes(ctx.submitMode);
var submitOnBlur = (ctx) => ["both", "blur"].includes(ctx.submitMode);
function machine6(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "editable",
      initial: ctx.edit ? "edit" : "preview",
      entry: ctx.edit ? ["focusInput"] : void 0,
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["syncInputValue"],
        edit: ["toggleEditing"]
      },
      computed: {
        submitOnEnter,
        submitOnBlur,
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly)
      },
      on: {
        "VALUE.SET": {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            "CONTROLLED.EDIT": {
              target: "edit",
              actions: ["setPreviousValue", "focusInput"]
            },
            EDIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnEdit"]
              },
              {
                target: "edit",
                actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
              }
            ]
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            "CONTROLLED.PREVIEW": [
              {
                guard: "isSubmitEvent",
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
              }
            ],
            CANCEL: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel", "invokeOnPreview"]
              }
            ],
            SUBMIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit", "invokeOnPreview"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isEditControlled: (ctx2) => !!ctx2["edit.controlled"],
        isSubmitEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "SUBMIT";
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom6.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom6.getCancelTriggerEl(ctx2), dom6.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              const { focusable } = event.detail;
              send({ type: submitOnBlur(ctx2) ? "SUBMIT" : "CANCEL", src: "interact-outside", focusable });
            }
          });
        }
      },
      actions: {
        restoreFocus(ctx2, evt) {
          if (evt.focusable) return;
          raf(() => {
            var _a8;
            const finalEl = ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? dom6.getEditTriggerEl(ctx2);
            finalEl == null ? void 0 : finalEl.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const inputEl = dom6.getInputEl(ctx2);
            if (!inputEl) return;
            if (ctx2.selectOnFocus) {
              inputEl.select();
            } else {
              inputEl.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          var _a8;
          (_a8 = ctx2.onValueRevert) == null ? void 0 : _a8.call(ctx2, { value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          var _a8;
          (_a8 = ctx2.onValueCommit) == null ? void 0 : _a8.call(ctx2, { value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          var _a8;
          (_a8 = ctx2.onEditChange) == null ? void 0 : _a8.call(ctx2, { edit: true });
        },
        invokeOnPreview(ctx2) {
          var _a8;
          (_a8 = ctx2.onEditChange) == null ? void 0 : _a8.call(ctx2, { edit: false });
        },
        toggleEditing(ctx2, evt, { send }) {
          send({ type: ctx2.edit ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW", previousEvent: evt });
        },
        syncInputValue(ctx2) {
          sync2.value(ctx2);
        },
        setValue(ctx2, evt) {
          const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;
          set5.value(ctx2, value);
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        revertValue(ctx2) {
          set5.value(ctx2, ctx2.previousValue);
        },
        blurInputIfNeeded(ctx2) {
          var _a8;
          (_a8 = dom6.getInputEl(ctx2)) == null ? void 0 : _a8.blur();
        }
      }
    }
  );
}
var sync2 = {
  value: (ctx) => {
    const inputEl = dom6.getInputEl(ctx);
    dom6.setValue(inputEl, ctx.value);
  }
};
var invoke3 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
    sync2.value(ctx);
  }
};
var set5 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke3.change(ctx);
  }
};
var props6 = createProps()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "edit.controlled",
  "submitMode",
  "translations",
  "value"
]);
var splitProps7 = createSplitProps(props6);

// node_modules/@ark-ui/react/dist/components/editable/use-editable.js
var import_react77 = __toESM(require_react(), 1);
var useEditable = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react77.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    edit: props25.defaultEdit,
    value: props25.defaultValue,
    "edit.controlled": props25.edit !== void 0,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onEditChange: useEvent(props25.onEditChange),
    onValueCommit: useEvent(props25.onValueCommit),
    onValueRevert: useEvent(props25.onValueRevert)
  };
  const [state2, send] = useMachine(machine6(initialContext), { context });
  return connect6(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var EditableRoot = (0, import_react79.forwardRef)((props25, ref2) => {
  const [useEditableProps, localProps] = createSplitProps2()(props25, [
    "activationMode",
    "autoResize",
    "defaultEdit",
    "defaultValue",
    "disabled",
    "edit",
    "finalFocusEl",
    "form",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "submitMode",
    "translations",
    "value"
  ]);
  const editable = useEditable(useEditableProps);
  const mergedProps = mergeProps2(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime35.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime35.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
EditableRoot.displayName = "EditableRoot";

// node_modules/@ark-ui/react/dist/components/editable/editable-root-provider.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
var EditableRootProvider = (0, import_react81.forwardRef)(
  (props25, ref2) => {
    const [{ value: editable }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(editable.getRootProps(), localProps);
    return (0, import_jsx_runtime36.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime36.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
EditableRootProvider.displayName = "EditableRootProvider";

// node_modules/@ark-ui/react/dist/components/editable/editable-submit-trigger.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var EditableSubmitTrigger = (0, import_react83.forwardRef)(
  (props25, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps2(editable.getSubmitTriggerProps(), props25);
    return (0, import_jsx_runtime37.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableSubmitTrigger.displayName = "EditableSubmitTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable.js
var editable_exports = {};
__export(editable_exports, {
  Area: () => EditableArea,
  CancelTrigger: () => EditableCancelTrigger,
  Context: () => EditableContext,
  Control: () => EditableControl,
  EditTrigger: () => EditableEditTrigger,
  Input: () => EditableInput,
  Label: () => EditableLabel,
  Preview: () => EditablePreview,
  Root: () => EditableRoot,
  RootProvider: () => EditableRootProvider,
  SubmitTrigger: () => EditableSubmitTrigger
});

// node_modules/@ark-ui/react/dist/components/field/field-context.js
var FieldContext = (props25) => props25.children(useFieldContext());

// node_modules/@ark-ui/react/dist/components/field/field-error-text.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);
var FieldErrorText = (0, import_react85.forwardRef)((props25, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field.getErrorTextProps(), props25);
  if (field == null ? void 0 : field.invalid) {
    return (0, import_jsx_runtime38.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
  return null;
});
FieldErrorText.displayName = "FieldErrorText";

// node_modules/@ark-ui/react/dist/components/field/field-helper-text.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);
var FieldHelperText = (0, import_react87.forwardRef)((props25, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getHelperTextProps(), props25);
  return (0, import_jsx_runtime39.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
FieldHelperText.displayName = "FieldHelperText";

// node_modules/@ark-ui/react/dist/components/field/field-input.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react89 = __toESM(require_react(), 1);
var FieldInput = (0, import_react89.forwardRef)((props25, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getInputProps(), props25);
  return (0, import_jsx_runtime40.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
FieldInput.displayName = "FieldInput";

// node_modules/@ark-ui/react/dist/components/field/field-label.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var FieldLabel = (0, import_react91.forwardRef)((props25, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getLabelProps(), props25);
  return (0, import_jsx_runtime41.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FieldLabel.displayName = "FieldLabel";

// node_modules/@ark-ui/react/dist/components/field/field-required-indicator.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react92 = __toESM(require_react(), 1);
var FieldRequiredIndicator = (0, import_react92.forwardRef)(
  ({ fallback: fallback3, ...props25 }, ref2) => {
    const field = useFieldContext();
    if (!field.required) {
      return fallback3;
    }
    const mergedProps = mergeProps2(field.getRequiredIndicatorProps(), props25);
    return (0, import_jsx_runtime42.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props25.children ?? "*" });
  }
);
FieldRequiredIndicator.displayName = "FieldRequiredIndicator";

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var import_react94 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-safe-layout-effect.js
var import_react93 = __toESM(require_react(), 1);
var useSafeLayoutEffect2 = typeof window !== "undefined" ? import_react93.useLayoutEffect : import_react93.useEffect;

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset-context.js
var [FieldsetProvider, useFieldsetContext] = createContext3({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/field/field.anatomy.js
var fieldAnatomy = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
var parts7 = fieldAnatomy.build();

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var useField = (props25) => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset == null ? void 0 : fieldset.disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props25;
  const hasErrorText = (0, import_react94.useRef)(false);
  const hasHelperText = (0, import_react94.useRef)(false);
  const id = props25.id ?? (0, import_react94.useId)();
  const rootRef = (0, import_react94.useRef)(null);
  const rootId = (ids == null ? void 0 : ids.control) ?? `field::${id}`;
  const errorTextId = (ids == null ? void 0 : ids.errorText) ?? `field::${id}::error-text`;
  const helperTextId = (ids == null ? void 0 : ids.helperText) ?? `field::${id}::helper-text`;
  const labelId = (ids == null ? void 0 : ids.label) ?? `field::${id}::label`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react94.useMemo)(() => {
    const ids2 = [];
    if (hasErrorText.current && invalid) ids2.push(errorTextId);
    if (hasHelperText.current) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react94.useMemo)(
    () => () => ({
      ...parts7.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = (0, import_react94.useMemo)(
    () => () => ({
      ...parts7.label.attrs,
      id: labelId,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly),
      htmlFor: id
    }),
    [disabled, invalid, readOnly, id, labelId]
  );
  const getControlProps = (0, import_react94.useMemo)(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr(invalid),
      "data-required": dataAttr(required),
      "data-readonly": dataAttr(readOnly),
      id,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id, disabled]
  );
  const getInputProps = (0, import_react94.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts7.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = (0, import_react94.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts7.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = (0, import_react94.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts7.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = (0, import_react94.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts7.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react94.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts7.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  const getRequiredIndicatorProps = (0, import_react94.useMemo)(
    () => () => ({
      "aria-hidden": true,
      ...parts7.requiredIndicator.attrs
    }),
    []
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var FieldRoot = (0, import_react96.forwardRef)((props25, ref2) => {
  const [useFieldProps, localProps] = createSplitProps2()(props25, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps2(field.getRootProps(), localProps);
  return (0, import_jsx_runtime43.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime43.jsx)(ark.div, { ...mergedProps, ref: composeRefs(ref2, field.refs.rootRef) }) });
});
FieldRoot.displayName = "FieldRoot";

// node_modules/@ark-ui/react/dist/components/field/field-root-provider.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react98 = __toESM(require_react(), 1);
var FieldRootProvider = (0, import_react98.forwardRef)(
  (props25, ref2) => {
    const [{ value: field }, localProps] = createSplitProps2()(props25, ["value"]);
    const mergedProps = mergeProps2(field.getRootProps(), localProps);
    return (0, import_jsx_runtime44.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime44.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FieldRootProvider.displayName = "FieldRootProvider";

// node_modules/@ark-ui/react/dist/components/field/field-select.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var FieldSelect = (0, import_react100.forwardRef)((props25, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps2(field == null ? void 0 : field.getSelectProps(), props25);
  return (0, import_jsx_runtime45.jsx)(ark.select, { ...mergedProps, ref: ref2 });
});
FieldSelect.displayName = "FieldSelect";

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/auto-resize/dist/index.mjs
var autoresizeTextarea = (el) => {
  var _a8;
  if (!el) return;
  const style = getComputedStyle(el);
  const win = getWindow(el);
  const doc = getDocument(el);
  const resize = () => {
    el.style.height = "auto";
    const borderTopWidth = parseInt(style.borderTopWidth, 10);
    const borderBottomWidth = parseInt(style.borderBottomWidth, 10);
    el.style.height = `${el.scrollHeight + borderTopWidth + borderBottomWidth}px`;
  };
  el.addEventListener("input", resize);
  const elementPrototype = Object.getPrototypeOf(el);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el, "value", {
    ...descriptor,
    set() {
      var _a9;
      (_a9 = descriptor == null ? void 0 : descriptor.set) == null ? void 0 : _a9.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => resize());
  resizeObserver.observe(el);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  (_a8 = doc.fonts) == null ? void 0 : _a8.addEventListener("loadingdone", resize);
  return () => {
    var _a9;
    el.removeEventListener("input", resize);
    (_a9 = doc.fonts) == null ? void 0 : _a9.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_react102 = __toESM(require_react(), 1);
var FieldTextarea = (0, import_react102.forwardRef)((props25, ref2) => {
  const { autoresize, ...textareaProps } = props25;
  const textareaRef = (0, import_react102.useRef)(null);
  const field = useFieldContext();
  const mergedProps = mergeProps2(
    field == null ? void 0 : field.getTextareaProps(),
    { style: { resize: autoresize ? "none" : void 0 } },
    textareaProps
  );
  (0, import_react102.useEffect)(() => {
    if (!autoresize) return;
    return autoresizeTextarea(textareaRef.current);
  }, [autoresize]);
  return (0, import_jsx_runtime46.jsx)(ark.textarea, { ...mergedProps, ref: composeRefs(ref2, textareaRef) });
});
FieldTextarea.displayName = "FieldTextarea";

// node_modules/@ark-ui/react/dist/components/field/field.js
var field_exports = {};
__export(field_exports, {
  Context: () => FieldContext,
  ErrorText: () => FieldErrorText,
  HelperText: () => FieldHelperText,
  Input: () => FieldInput,
  Label: () => FieldLabel,
  RequiredIndicator: () => FieldRequiredIndicator,
  Root: () => FieldRoot,
  RootProvider: () => FieldRootProvider,
  Select: () => FieldSelect,
  Textarea: () => FieldTextarea
});

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-context.js
var FieldsetContext = (props25) => props25.children(useFieldsetContext());

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-error-text.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);
var FieldsetErrorText = (0, import_react104.forwardRef)(
  (props25, ref2) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps2(fieldset.getErrorTextProps(), props25);
    return fieldset.invalid ? (0, import_jsx_runtime47.jsx)(ark.span, { ...mergedProps, ref: ref2 }) : null;
  }
);
FieldsetErrorText.displayName = "FieldsetErrorText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-helper-text.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react106 = __toESM(require_react(), 1);
var FieldsetHelperText = (0, import_react106.forwardRef)(
  (props25, ref2) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps2(fieldset.getHelperTextProps(), props25);
    return (0, import_jsx_runtime48.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
FieldsetHelperText.displayName = "FieldsetHelperText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-legend.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react108 = __toESM(require_react(), 1);
var FieldsetLegend = (0, import_react108.forwardRef)((props25, ref2) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps2(fieldset.getLegendProps(), props25);
  return (0, import_jsx_runtime49.jsx)(ark.legend, { ...mergedProps, ref: ref2 });
});
FieldsetLegend.displayName = "FieldsetLegend";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react111 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var import_react109 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js
var fieldsetAnatomy = createAnatomy("fieldset").parts(
  "root",
  "errorText",
  "helperText",
  "legend"
);
var parts8 = fieldsetAnatomy.build();

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var useFieldset = (props25) => {
  const { disabled = false, invalid = false } = props25;
  const hasErrorText = (0, import_react109.useRef)(false);
  const hasHelperText = (0, import_react109.useRef)(false);
  const id = props25.id ?? (0, import_react109.useId)();
  const rootRef = (0, import_react109.useRef)(null);
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react109.useMemo)(() => {
    const ids = [];
    if (hasErrorText.current && invalid) ids.push(errorTextId);
    if (hasHelperText.current) ids.push(helperTextId);
    return ids.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react109.useMemo)(
    () => () => ({
      ...parts8.root.attrs,
      ref: rootRef,
      disabled,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0,
      "aria-describedby": labelIds
    }),
    [disabled, invalid, labelIds]
  );
  const getLegendProps = (0, import_react109.useMemo)(
    () => () => ({
      ...parts8.legend.attrs,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0
    }),
    [disabled, invalid]
  );
  const getHelperTextProps = (0, import_react109.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts8.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react109.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts8.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  return {
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  };
};

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var FieldsetRoot = (0, import_react111.forwardRef)((props25, ref2) => {
  const [useFieldsetProps, localProps] = createSplitProps2()(props25, [
    "id",
    "disabled",
    "invalid"
  ]);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps2(fieldset.getRootProps(), localProps);
  return (0, import_jsx_runtime50.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime50.jsx)(ark.fieldset, { ...mergedProps, ref: composeRefs(ref2, fieldset.refs.rootRef) }) });
});
FieldsetRoot.displayName = "FieldsetRoot";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root-provider.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
var FieldsetRootProvider = (0, import_react113.forwardRef)(
  (props25, ref2) => {
    const [{ value: fieldset }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(fieldset.getRootProps(), localProps);
    return (0, import_jsx_runtime51.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime51.jsx)(ark.fieldset, { ...mergedProps, ref: ref2 }) });
  }
);
FieldsetRootProvider.displayName = "FieldsetRootProvider";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.js
var fieldset_exports = {};
__export(fieldset_exports, {
  Context: () => FieldsetContext,
  ErrorText: () => FieldsetErrorText,
  HelperText: () => FieldsetHelperText,
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot,
  RootProvider: () => FieldsetRootProvider
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react115 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-context.js
var [FileUploadProvider, useFileUploadContext] = createContext3({
  name: "FileUploadContext",
  hookName: "useFileUploadContext",
  providerName: "<FileUploadProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var FileUploadClearTrigger = (0, import_react115.forwardRef)(
  (props25, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getClearTriggerProps(), props25);
    return (0, import_jsx_runtime52.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadClearTrigger.displayName = "FileUploadClearTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-context.js
var FileUploadContext = (props25) => props25.children(useFileUploadContext());

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-dropzone.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react117 = __toESM(require_react(), 1);
var FileUploadDropzone = (0, import_react117.forwardRef)((props25, ref2) => {
  const [dropzoneProps, localProps] = createSplitProps2()(props25, [
    "disableClick"
  ]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(
    fileUpload.getDropzoneProps(dropzoneProps),
    localProps
  );
  return (0, import_jsx_runtime53.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
FileUploadDropzone.displayName = "FileUploadDropzone";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-hidden-input.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react119 = __toESM(require_react(), 1);
var FileUploadHiddenInput = (0, import_react119.forwardRef)(
  (props25, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getHiddenInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime54.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
FileUploadHiddenInput.displayName = "FileUploadHiddenInput";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react121 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-item-props-context.js
var [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext3({
  name: "FileUploadItemPropsContext",
  hookName: "useFileUploadItemPropsContext",
  providerName: "<FileUploadItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var FileUploadItem = (0, import_react121.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, ["file"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getItemProps(itemProps8), localProps);
  return (0, import_jsx_runtime55.jsx)(FileUploadItemPropsProvider, { value: itemProps8, children: (0, import_jsx_runtime55.jsx)(ark.li, { ...mergedProps, ref: ref2 }) });
});
FileUploadItem.displayName = "FileUploadItem";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-delete-trigger.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react123 = __toESM(require_react(), 1);
var FileUploadItemDeleteTrigger = (0, import_react123.forwardRef)((props25, ref2) => {
  const fileUpload = useFileUploadContext();
  const itemProps8 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(fileUpload.getItemDeleteTriggerProps(itemProps8), props25);
  return (0, import_jsx_runtime56.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
FileUploadItemDeleteTrigger.displayName = "FileUploadItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-group.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react125 = __toESM(require_react(), 1);
var FileUploadItemGroup = (0, import_react125.forwardRef)(
  (props25, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getItemGroupProps(), props25);
    return (0, import_jsx_runtime57.jsx)(ark.ul, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemGroup.displayName = "FileUploadItemGroup";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-name.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react127 = __toESM(require_react(), 1);
var FileUploadItemName = (0, import_react127.forwardRef)(
  (props25, ref2) => {
    const { children, ...rest } = props25;
    const fileUpload = useFileUploadContext();
    const itemProps8 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemNameProps(itemProps8), rest);
    return (0, import_jsx_runtime58.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || itemProps8.file.name });
  }
);
FileUploadItemName.displayName = "FileUploadItemName";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react129 = __toESM(require_react(), 1);
var FileUploadItemPreview = (0, import_react129.forwardRef)(
  (props25, ref2) => {
    const fileUpload = useFileUploadContext();
    const itemProps8 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemPreviewProps(itemProps8), props25);
    if (!itemProps8.file.type.match(props25.type ?? ".*")) return null;
    return (0, import_jsx_runtime59.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemPreview.displayName = "FileUploadItemPreview";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview-image.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react131 = __toESM(require_react(), 1);
var FileUploadItemPreviewImage = (0, import_react131.forwardRef)((props25, ref2) => {
  const [url, setUrl] = (0, import_react131.useState)("");
  const fileUpload = useFileUploadContext();
  const itemProps8 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps2(
    fileUpload.getItemPreviewImageProps({ ...itemProps8, url }),
    props25
  );
  (0, import_react131.useEffect)(() => {
    return fileUpload.createFileUrl(itemProps8.file, (url2) => setUrl(url2));
  }, [itemProps8, fileUpload]);
  if (!url) return null;
  return (0, import_jsx_runtime60.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
FileUploadItemPreviewImage.displayName = "FileUploadItemPreviewImage";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-size-text.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react133 = __toESM(require_react(), 1);
var FileUploadItemSizeText = (0, import_react133.forwardRef)(
  (props25, ref2) => {
    const { children, ...rest } = props25;
    const fileUpload = useFileUploadContext();
    const itemProps8 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps2(fileUpload.getItemSizeTextProps(itemProps8), rest);
    return (0, import_jsx_runtime61.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || fileUpload.getFileSize(itemProps8.file) });
  }
);
FileUploadItemSizeText.displayName = "FileUploadItemSizeText";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-label.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react135 = __toESM(require_react(), 1);
var FileUploadLabel = (0, import_react135.forwardRef)((props25, ref2) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps2(fileUpload.getLabelProps(), props25);
  return (0, import_jsx_runtime62.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FileUploadLabel.displayName = "FileUploadLabel";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react139 = __toESM(require_react(), 1);

// node_modules/@zag-js/file-utils/dist/index.mjs
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
  if (!accept) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter(isValidMIME).join(",");
}
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : accept.split(",");
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy7 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts9 = anatomy7.build();
var dom7 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item:${id}`;
  },
  getItemNameId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemName) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-name:${id}`;
  },
  getItemSizeTextId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemSizeText) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-size:${id}`;
  },
  getItemPreviewId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemPreview) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-preview:${id}`;
  },
  getRootEl: (ctx) => dom7.getById(ctx, dom7.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom7.getById(ctx, dom7.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom7.getById(ctx, dom7.getDropzoneId(ctx))
});
function isEventWithFiles(event) {
  const target = getEventTarget(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  if (!ctx.multiple && incomingCount > 1) return false;
  if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2) return true;
  if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles) return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    var _a8;
    const [accepted, acceptError] = isValidFileType(file, ctx.acceptAttr);
    const [sizeMatch, sizeError] = isValidFileSize(file, ctx.minFileSize, ctx.maxFileSize);
    const validateErrors = (_a8 = ctx.validate) == null ? void 0 : _a8.call(ctx, file, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function connect7(state2, send, normalize2) {
  const disabled = state2.context.disabled;
  const allowDrop = state2.context.allowDrop;
  const translations = state2.context.translations;
  const dragging = state2.matches("dragging");
  const focused = state2.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    disabled: !!disabled,
    openFilePicker() {
      if (disabled) return;
      send("OPEN");
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: state2.context.acceptedFiles,
    rejectedFiles: state2.context.rejectedFiles,
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearRejectedFiles() {
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, state2.context.locale);
    },
    createFileUrl(file, cb) {
      const win = dom7.getWin(state2.context);
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    setClipboardFiles(dt) {
      if (disabled) return false;
      const items = Array.from((dt == null ? void 0 : dt.items) ?? []);
      const files = items.reduce((acc, item) => {
        if (item.kind !== "file") return acc;
        const file = item.getAsFile();
        if (!file) return acc;
        return [...acc, file];
      }, []);
      if (!files.length) return false;
      send({ type: "FILES.SET", files });
      return true;
    },
    getRootProps() {
      return normalize2.element({
        ...parts9.root.attrs,
        dir: state2.context.dir,
        id: dom7.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps(props25 = {}) {
      return normalize2.element({
        ...parts9.dropzone.attrs,
        dir: state2.context.dir,
        id: dom7.getDropzoneId(state2.context),
        tabIndex: disabled || props25.disableClick ? void 0 : 0,
        role: props25.disableClick ? "application" : "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (props25.disableClick) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (props25.disableClick) return;
          if (!isSelfTarget(event)) return;
          if (event.currentTarget.localName === "label") {
            event.preventDefault();
          }
          send("DROPZONE.CLICK");
        },
        onDragOver(event) {
          if (disabled) return;
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (disabled) return;
          if (!allowDrop) return;
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (disabled) return;
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles) return;
          send({ type: "DROPZONE.DROP", files: Array.from(event.dataTransfer.files) });
        },
        onFocus() {
          if (disabled) return;
          send("DROPZONE.FOCUS");
        },
        onBlur() {
          if (disabled) return;
          send("DROPZONE.BLUR");
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts9.trigger.attrs,
        dir: state2.context.dir,
        id: dom7.getTriggerId(state2.context),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        type: "button",
        onClick(event) {
          if (disabled) return;
          if (contains(dom7.getDropzoneEl(state2.context), event.currentTarget)) {
            event.stopPropagation();
          }
          send("OPEN");
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom7.getHiddenInputId(state2.context),
        tabIndex: -1,
        disabled,
        type: "file",
        required: state2.context.required,
        capture: state2.context.capture,
        name: state2.context.name,
        accept: state2.context.acceptAttr,
        webkitdirectory: state2.context.directory ? "" : void 0,
        multiple: state2.context.multiple || state2.context.maxFiles > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onInput(event) {
          if (disabled) return;
          const { files } = event.currentTarget;
          send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize2.element({
        ...parts9.itemGroup.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props25) {
      const { file } = props25;
      return normalize2.element({
        ...parts9.item.attrs,
        dir: state2.context.dir,
        id: dom7.getItemId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props25) {
      const { file } = props25;
      return normalize2.element({
        ...parts9.itemName.attrs,
        dir: state2.context.dir,
        id: dom7.getItemNameId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props25) {
      const { file } = props25;
      return normalize2.element({
        ...parts9.itemSizeText.attrs,
        dir: state2.context.dir,
        id: dom7.getItemSizeTextId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props25) {
      const { file } = props25;
      return normalize2.element({
        ...parts9.itemPreview.attrs,
        dir: state2.context.dir,
        id: dom7.getItemPreviewId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props25) {
      var _a8;
      const { file, url } = props25;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize2.img({
        ...parts9.itemPreviewImage.attrs,
        alt: (_a8 = translations.itemPreview) == null ? void 0 : _a8.call(translations, file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props25) {
      var _a8;
      const { file } = props25;
      return normalize2.button({
        ...parts9.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": (_a8 = translations.deleteFile) == null ? void 0 : _a8.call(translations, file),
        onClick() {
          if (disabled) return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts9.label.attrs,
        dir: state2.context.dir,
        id: dom7.getLabelId(state2.context),
        htmlFor: dom7.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts9.clearTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        hidden: state2.context.acceptedFiles.length === 0,
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
function machine7(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "fileupload",
      initial: "idle",
      context: {
        minFileSize: 0,
        maxFileSize: Number.POSITIVE_INFINITY,
        maxFiles: 1,
        allowDrop: true,
        accept: ctx.accept,
        preventDocumentDrop: true,
        ...ctx,
        acceptedFiles: ref([]),
        rejectedFiles: ref([]),
        translations: {
          dropzone: "dropzone",
          itemPreview: (file) => `preview of ${file.name}`,
          deleteFile: (file) => `delete file ${file.name}`,
          ...ctx.translations
        }
      },
      computed: {
        acceptAttr: (ctx2) => getAcceptAttrString(ctx2.accept),
        multiple: (ctx2) => ctx2.maxFiles > 1
      },
      watch: {
        acceptedFiles: ["syncInputElement"]
      },
      on: {
        "FILES.SET": {
          actions: ["setFilesFromEvent"]
        },
        "FILE.DELETE": {
          actions: ["removeFile"]
        },
        "FILES.CLEAR": {
          actions: ["clearFiles"]
        },
        "REJECTED_FILES.CLEAR": {
          actions: ["clearRejectedFiles"]
        }
      },
      activities: ["preventDocumentDrop"],
      states: {
        idle: {
          on: {
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.FOCUS": "focused",
            "DROPZONE.DRAG_OVER": "dragging"
          }
        },
        focused: {
          on: {
            "DROPZONE.BLUR": "idle",
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.DRAG_OVER": "dragging"
          }
        },
        dragging: {
          on: {
            "DROPZONE.DROP": {
              target: "idle",
              actions: ["setFilesFromEvent"]
            },
            "DROPZONE.DRAG_LEAVE": "idle"
          }
        }
      }
    },
    {
      activities: {
        preventDocumentDrop(ctx2) {
          if (!ctx2.preventDocumentDrop) return;
          if (!ctx2.allowDrop) return;
          if (ctx2.disabled) return;
          const doc = dom7.getDoc(ctx2);
          const onDragOver = (event) => {
            event == null ? void 0 : event.preventDefault();
          };
          const onDrop = (event) => {
            if (contains(dom7.getRootEl(ctx2), getEventTarget(event))) return;
            event.preventDefault();
          };
          return callAll2(addDomEvent(doc, "dragover", onDragOver, false), addDomEvent(doc, "drop", onDrop, false));
        }
      },
      actions: {
        syncInputElement(ctx2) {
          queueMicrotask(() => {
            const inputEl = dom7.getHiddenInputEl(ctx2);
            if (!inputEl) return;
            const win = dom7.getWin(ctx2);
            const dataTransfer = new win.DataTransfer();
            ctx2.acceptedFiles.forEach((v) => {
              dataTransfer.items.add(v);
            });
            inputEl.files = dataTransfer.files;
            inputEl.dispatchEvent(new win.Event("change", { bubbles: true }));
          });
        },
        openFilePicker(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom7.getHiddenInputEl(ctx2)) == null ? void 0 : _a8.click();
          });
        },
        setFilesFromEvent(ctx2, evt) {
          const result = getFilesFromEvent(ctx2, evt.files);
          const { acceptedFiles, rejectedFiles } = result;
          if (ctx2.multiple) {
            const files = ref([...ctx2.acceptedFiles, ...acceptedFiles]);
            set6.files(ctx2, files, rejectedFiles);
            return;
          }
          if (acceptedFiles.length) {
            const files = ref([acceptedFiles[0]]);
            set6.files(ctx2, files, rejectedFiles);
          } else if (rejectedFiles.length) {
            set6.files(ctx2, ctx2.acceptedFiles, rejectedFiles);
          }
        },
        removeFile(ctx2, evt) {
          const files = Array.from(ctx2.acceptedFiles.filter((file) => file !== evt.file));
          const rejectedFiles = Array.from(ctx2.rejectedFiles.filter((item) => item.file !== evt.file));
          ctx2.acceptedFiles = ref(files);
          ctx2.rejectedFiles = ref(rejectedFiles);
          invoke4.change(ctx2);
        },
        clearRejectedFiles(ctx2) {
          ctx2.rejectedFiles = ref([]);
          invoke4.change(ctx2);
        },
        clearFiles(ctx2) {
          ctx2.acceptedFiles = ref([]);
          ctx2.rejectedFiles = ref([]);
          invoke4.change(ctx2);
        }
      },
      compareFns: {
        acceptedFiles: (a, b) => a.length === b.length && a.every((file, i) => isFileEqual(file, b[i]))
      }
    }
  );
}
var invoke4 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileChange) == null ? void 0 : _a8.call(ctx, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
  },
  accept: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileAccept) == null ? void 0 : _a8.call(ctx, { files: ctx.acceptedFiles });
  },
  reject: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileReject) == null ? void 0 : _a8.call(ctx, { files: ctx.rejectedFiles });
  }
};
var set6 = {
  files: (ctx, acceptedFiles, rejectedFiles) => {
    ctx.acceptedFiles = ref(acceptedFiles);
    invoke4.accept(ctx);
    if (rejectedFiles) {
      ctx.rejectedFiles = ref(rejectedFiles);
      invoke4.reject(ctx);
    }
    invoke4.change(ctx);
  }
};
var props7 = createProps()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "validate"
]);
var splitProps8 = createSplitProps(props7);
var itemProps2 = createProps()(["file"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload.js
var import_react137 = __toESM(require_react(), 1);
var useFileUpload = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react137.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    getRootNode,
    ...props25
  };
  const context = {
    ...initialContext,
    onFileAccept: useEvent(props25.onFileAccept),
    onFileReject: useEvent(props25.onFileReject),
    onFileChange: useEvent(props25.onFileChange, { sync: true })
  };
  const [state2, send] = useMachine(machine7(initialContext), { context });
  return connect7(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var FileUploadRoot = (0, import_react139.forwardRef)((props25, ref2) => {
  const [useFileUploadProps, localProps] = createSplitProps2()(props25, [
    "accept",
    "allowDrop",
    "capture",
    "directory",
    "disabled",
    "id",
    "ids",
    "invalid",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "preventDocumentDrop",
    "required",
    "translations",
    "validate"
  ]);
  const fileUpload = useFileUpload(useFileUploadProps);
  const mergedProps = mergeProps2(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime63.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime63.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
FileUploadRoot.displayName = "FileUploadRoot";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root-provider.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);
var FileUploadRootProvider = (0, import_react141.forwardRef)(
  (props25, ref2) => {
    const [{ value: fileUpload }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(fileUpload.getRootProps(), localProps);
    return (0, import_jsx_runtime64.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime64.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FileUploadRootProvider.displayName = "FileUploadRootProvider";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-trigger.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react143 = __toESM(require_react(), 1);
var FileUploadTrigger = (0, import_react143.forwardRef)(
  (props25, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps2(fileUpload.getTriggerProps(), props25);
    return (0, import_jsx_runtime65.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadTrigger.displayName = "FileUploadTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload.js
var file_upload_exports = {};
__export(file_upload_exports, {
  ClearTrigger: () => FileUploadClearTrigger,
  Context: () => FileUploadContext,
  Dropzone: () => FileUploadDropzone,
  HiddenInput: () => FileUploadHiddenInput,
  Item: () => FileUploadItem,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger,
  ItemGroup: () => FileUploadItemGroup,
  ItemName: () => FileUploadItemName,
  ItemPreview: () => FileUploadItemPreview,
  ItemPreviewImage: () => FileUploadItemPreviewImage,
  ItemSizeText: () => FileUploadItemSizeText,
  Label: () => FileUploadLabel,
  Root: () => FileUploadRoot,
  RootProvider: () => FileUploadRootProvider,
  Trigger: () => FileUploadTrigger
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react145 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-context.js
var [MenuProvider, useMenuContext] = createContext3({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var MenuArrow = (0, import_react145.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getArrowProps(), props25);
  return (0, import_jsx_runtime66.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrow.displayName = "MenuArrow";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow-tip.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react147 = __toESM(require_react(), 1);
var MenuArrowTip = (0, import_react147.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getArrowTipProps(), props25);
  return (0, import_jsx_runtime67.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrowTip.displayName = "MenuArrowTip";

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react149 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-context.js
var [MenuItemProvider, useMenuItemContext] = createContext3({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-option-item-props-context.js
var [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext3({
  name: "MenuOptionItemPropsContext",
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var MenuCheckboxItem = (0, import_react149.forwardRef)((props25, ref2) => {
  const [partialOptionItemProps, localProps] = createSplitProps2()(props25, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps2 = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime68.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime68.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime68.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-content.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react151 = __toESM(require_react(), 1);
var MenuContent = (0, import_react151.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(menu.getContentProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime69.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
MenuContent.displayName = "MenuContent";

// node_modules/@ark-ui/react/dist/components/menu/menu-context.js
var MenuContext = (props25) => props25.children(useMenuContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-context-trigger.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react153 = __toESM(require_react(), 1);
var MenuContextTrigger = (0, import_react153.forwardRef)(
  (props25, ref2) => {
    const menu = useMenuContext();
    const mergedProps = mergeProps2(menu.getContextTriggerProps(), props25);
    return (0, import_jsx_runtime70.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
MenuContextTrigger.displayName = "MenuContextTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-indicator.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react155 = __toESM(require_react(), 1);
var MenuIndicator = (0, import_react155.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getIndicatorProps(), props25);
  return (0, import_jsx_runtime71.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuIndicator.displayName = "MenuIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react157 = __toESM(require_react(), 1);
var MenuItem = (0, import_react157.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getItemProps(itemProps8), localProps);
  const itemState = menu.getItemState(itemProps8);
  return (0, import_jsx_runtime72.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime72.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItem.displayName = "MenuItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-context.js
var MenuItemContext = (props25) => props25.children(useMenuItemContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react159 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-group-context.js
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext3({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var MenuItemGroup = (0, import_react159.forwardRef)((props25, ref2) => {
  const [optionalItemGroupProps, localProps] = createSplitProps2()(props25, [
    "id"
  ]);
  const menu = useMenuContext();
  const id = (0, import_react159.useId)();
  const itemGroupProps3 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps2(menu.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime73.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime73.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItemGroup.displayName = "MenuItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group-label.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react161 = __toESM(require_react(), 1);
var MenuItemGroupLabel = (0, import_react161.forwardRef)(
  (props25, ref2) => {
    const menu = useMenuContext();
    const itemGroup = useMenuItemGroupContext();
    const mergedProps = mergeProps2(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props25);
    return (0, import_jsx_runtime74.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-indicator.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react163 = __toESM(require_react(), 1);
var MenuItemIndicator = (0, import_react163.forwardRef)(
  (props25, ref2) => {
    const menu = useMenuContext();
    const optionItemProps2 = useMenuOptionItemPropsContext();
    const mergedProps = mergeProps2(menu.getItemIndicatorProps(optionItemProps2), props25);
    return (0, import_jsx_runtime75.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemIndicator.displayName = "MenuItemIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-text.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react165 = __toESM(require_react(), 1);
var MenuItemText = (0, import_react165.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const optionItemProps2 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps2(menu.getItemTextProps(optionItemProps2), props25);
  return (0, import_jsx_runtime76.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuItemText.displayName = "MenuItemText";

// node_modules/@ark-ui/react/dist/components/menu/menu-positioner.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react167 = __toESM(require_react(), 1);
var MenuPositioner = (0, import_react167.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getPositionerProps(), props25);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime77.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuPositioner.displayName = "MenuPositioner";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react169 = __toESM(require_react(), 1);
var MenuRadioItem = (0, import_react169.forwardRef)((props25, ref2) => {
  const [partialItemProps, localProps] = createSplitProps2()(props25, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps2 = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => {
      var _a8;
      return (_a8 = itemGroup.onValueChange) == null ? void 0 : _a8.call(itemGroup, { value: partialItemProps.value });
    }
  };
  const mergedProps = mergeProps2(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime78.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime78.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime78.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item-group.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react171 = __toESM(require_react(), 1);
var MenuRadioItemGroup = (0, import_react171.forwardRef)(
  (props25, ref2) => {
    const [optionalItemGroupProps, localProps] = createSplitProps2()(props25, ["id", "onValueChange", "value"]);
    const menu = useMenuContext();
    const id = (0, import_react171.useId)();
    const itemGroupProps3 = { id, ...optionalItemGroupProps };
    const mergedProps = mergeProps2(menu.getItemGroupProps({ id: itemGroupProps3.id }), localProps);
    return (0, import_jsx_runtime79.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime79.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
MenuRadioItemGroup.displayName = "MenuRadioItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react176 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-effect-once.js
var import_react172 = __toESM(require_react(), 1);
var useEffectOnce = (cb) => {
  const savedCallback = (0, import_react172.useRef)(cb);
  const effectGuard = (0, import_react172.useRef)(false);
  (0, import_react172.useEffect)(() => {
    savedCallback.current = cb;
  });
  (0, import_react172.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};

// node_modules/@zag-js/rect-utils/dist/index.mjs
var createPoint = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var { min: min3, max: max3 } = Math;
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var { sign: sign2, abs: abs3, min: min22 } = Math;

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy8 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts10 = anatomy8.build();
var dom8 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.group) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.groupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group-label:${id}`;
  },
  getContentEl: (ctx) => dom8.getById(ctx, dom8.getContentId(ctx)),
  getPositionerEl: (ctx) => dom8.getById(ctx, dom8.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom8.getById(ctx, dom8.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom8.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom8.getById(ctx, dom8.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom8.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom8.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom8.getElements(ctx)),
  getLastEl: (ctx) => last(dom8.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom8.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom8.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom8.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    var _a8;
    return !!((_a8 = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a8.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el) {
    return {
      id: el.id,
      name: el.dataset.name,
      value: el.dataset.value,
      valueText: el.dataset.valueText,
      type: el.dataset.type
    };
  }
});
function connect8(state2, send, normalize2) {
  const isSubmenu = state2.context.isSubmenu;
  const isTypingAhead = state2.context.isTypingAhead;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.anchorPoint ? "bottom" : state2.context.currentPlacement
  });
  function getItemState(props25) {
    return {
      disabled: !!props25.disabled,
      highlighted: state2.context.highlightedValue === props25.value
    };
  }
  function getOptionItemProps(props25) {
    const valueText = props25.valueText ?? props25.value;
    return { ...props25, id: props25.value, valueText };
  }
  function getOptionItemState(props25) {
    const itemState = getItemState(getOptionItemProps(props25));
    return {
      ...itemState,
      checked: !!props25.checked
    };
  }
  function getItemProps(props25) {
    const { value: id, closeOnSelect, valueText } = props25;
    const itemState = getItemState(props25);
    return normalize2.element({
      ...parts10.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.disabled,
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": dom8.getContentId(state2.context),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = state2.previousEvent.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue: state2.context.highlightedValue,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", id: value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.state.context.id });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getContextTriggerProps() {
      return normalize2.element({
        ...parts10.contextTrigger.attrs,
        dir: state2.context.dir,
        id: dom8.getContextTriggerId(state2.context),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      return mergeProps2(
        getItemProps({ value: childApi.getTriggerProps().id }),
        childApi.getTriggerProps()
      );
    },
    getTriggerProps() {
      return normalize2.button({
        ...isSubmenu ? parts10.triggerItem.attrs : parts10.trigger.attrs,
        "data-placement": state2.context.currentPlacement,
        type: "button",
        dir: state2.context.dir,
        id: dom8.getTriggerId(state2.context),
        "data-uid": state2.context.id,
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": dom8.getContentId(state2.context),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = dom8.isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
        },
        onPointerLeave(event) {
          if (dom8.isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
        },
        onPointerDown(event) {
          if (dom8.isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (dom8.isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts10.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts10.positioner.attrs,
        dir: state2.context.dir,
        id: dom8.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom8.getArrowId(state2.context),
        ...parts10.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts10.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts10.content.attrs,
        id: dom8.getContentId(state2.context),
        "aria-label": state2.context["aria-label"],
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: state2.context.dir,
        "aria-activedescendant": state2.context.highlightedValue ?? void 0,
        "aria-labelledby": dom8.getTriggerId(state2.context),
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send("MENU_POINTERENTER");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = (target == null ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = dom8.getHighlightedItemEl(state2.context);
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
              if (isAnchorElement(item)) {
                state2.context.navigate({ value: state2.context.highlightedValue, node: item });
              }
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, { dir: state2.context.dir });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!state2.context.typeahead) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize2.element({
        ...parts10.separator.attrs,
        role: "separator",
        dir: state2.context.dir,
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props25) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props25;
      const option = getOptionItemProps(props25);
      const itemState = getOptionItemState(props25);
      return {
        ...getItemProps(option),
        ...normalize2.element({
          "data-type": type,
          ...parts10.item.attrs,
          dir: state2.context.dir,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange == null ? void 0 : onCheckedChange(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props25) {
      const itemState = getOptionItemState(props25);
      return normalize2.element({
        ...parts10.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props25) {
      const itemState = getOptionItemState(props25);
      return normalize2.element({
        ...parts10.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props25) {
      return normalize2.element({
        id: dom8.getGroupLabelId(state2.context, props25.htmlFor),
        dir: state2.context.dir,
        ...parts10.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props25) {
      return normalize2.element({
        id: dom8.getGroupId(state2.context, props25.id),
        ...parts10.itemGroup.attrs,
        dir: state2.context.dir,
        "aria-labelledby": dom8.getGroupLabelId(state2.context, props25.id),
        role: "group"
      });
    }
  };
}
var { not: not3, and: and5, or: or2 } = guards;
function machine8(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "menu",
      initial: ctx.open ? "open" : "idle",
      context: {
        highlightedValue: null,
        loopFocus: false,
        anchorPoint: null,
        closeOnSelect: true,
        typeahead: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...ctx,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        },
        intentPolygon: null,
        parent: null,
        lastHighlightedValue: null,
        children: cast(ref({})),
        suspendPointer: false,
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeaheadState.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "reposition",
        open: "toggleVisibility"
      },
      on: {
        "PARENT.SET": {
          actions: "setParentMenu"
        },
        "CHILD.SET": {
          actions: "setChildMenu"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnOpen"
          },
          {
            target: "open",
            actions: "invokeOnOpen"
          }
        ],
        OPEN_AUTOFOCUS: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            internal: true,
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnClose"
          },
          {
            target: "closed",
            actions: "invokeOnClose"
          }
        ],
        "HIGHLIGHTED.RESTORE": {
          actions: "restoreHighlightedItem"
        },
        "HIGHLIGHTED.SET": {
          actions: "setHighlightedItem"
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_FOCUS: {
              guard: not3("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          tags: ["closed"],
          after: {
            LONG_PRESS_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_CANCEL: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            SUBMENU_OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            BLUR: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            TRIGGER_POINTERLEAVE: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHighlightedItem"]
            },
            // don't invoke on open here since the menu is still open (we're only keeping it open)
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHighlightedItem"]
              }
            ]
          }
        },
        closed: {
          tags: ["closed"],
          entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: or2("isOpenAutoFocusEvent", "isArrowDownEvent"),
                target: "open",
                actions: "highlightFirstItem"
              },
              {
                guard: "isArrowUpEvent",
                target: "open",
                actions: "highlightLastItem"
              },
              {
                target: "open"
              }
            ],
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            ARROW_UP: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                target: "closed",
                guard: "isArrowLeftEvent",
                actions: ["focusParentMenu"]
              },
              {
                target: "closed"
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: and5(not3("isTriggerItem"), "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: not3("isTriggerItem"),
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            ARROW_UP: {
              actions: ["highlightPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["highlightNextItem", "focusMenu"]
            },
            ARROW_LEFT: [
              {
                guard: and5("isSubmenu", "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: "isSubmenu",
                target: "closed",
                actions: ["focusParentMenu", "invokeOnClose"]
              }
            ],
            HOME: {
              actions: ["highlightFirstItem", "focusMenu"]
            },
            END: {
              actions: ["highlightLastItem", "focusMenu"]
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemHighlighted",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemHighlighted",
                actions: "openSubmenu"
              },
              {
                actions: "clickHighlightedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: not3("suspendPointer"),
                actions: ["setHighlightedItem", "focusMenu"]
              },
              {
                actions: "setLastHighlightedItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and5(not3("suspendPointer"), not3("isTriggerItem")),
              actions: "clearHighlightedItem"
            },
            ITEM_CLICK: [
              // == grouped ==
              {
                guard: and5(
                  not3("isTriggerItemHighlighted"),
                  not3("isHighlightedItemEditable"),
                  "closeOnSelect",
                  "isOpenControlled"
                ),
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              {
                guard: and5(not3("isTriggerItemHighlighted"), not3("isHighlightedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              //
              {
                guard: and5(not3("isTriggerItemHighlighted"), not3("isHighlightedItemEditable")),
                actions: ["invokeOnSelect", "setOptionState"]
              },
              { actions: "setHighlightedItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "setHighlightedItem"
            },
            TYPEAHEAD: {
              actions: "highlightMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!((evt == null ? void 0 : evt.closeOnSelect) ?? ctx2.closeOnSelect),
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom8.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemHighlighted: (ctx2, evt) => {
          const target = evt.target ?? dom8.getHighlightedItemEl(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isHighlightedItemEditable: (ctx2) => isEditableElement(dom8.getHighlightedItemEl(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon) return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        },
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isArrowLeftEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_LEFT";
        },
        isArrowUpEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_UP";
        },
        isArrowDownEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_DOWN";
        },
        isOpenAutoFocusEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "OPEN_AUTOFOCUS";
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint) return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom8.getPositionerEl(ctx2);
          return getPlacement(dom8.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom8.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom8.getTriggerEl(ctx2)],
            onInteractOutside: ctx2.onInteractOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (ctx2.isSubmenu) event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              var _a8;
              restoreFocus = !event.detail.focusable;
              (_a8 = ctx2.onPointerDownOutside) == null ? void 0 : _a8.call(ctx2, event);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom8.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = () => {
            const state2 = getState();
            if (state2.event.type.startsWith("ITEM_POINTER")) return;
            const itemEl = dom8.getHighlightedItemEl(ctx2);
            const contentEl2 = dom8.getContentEl(ctx2);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2());
          const contentEl = () => dom8.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["aria-activedescendant"],
            callback: exec2
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu) return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom8.getPositionerEl(ctx2);
          const getAnchorRect = ctx2.anchorPoint ? () => ({ width: 0, height: 0, ...ctx2.anchorPoint }) : void 0;
          getPlacement(dom8.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            getAnchorRect,
            ...evt.options ?? {},
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setOptionState(_ctx, evt) {
          if (!evt.option) return;
          const { checked, onCheckedChange, type } = evt.option;
          if (type === "radio") {
            onCheckedChange == null ? void 0 : onCheckedChange(true);
          } else if (type === "checkbox") {
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        },
        clickHighlightedItem(ctx2, _evt) {
          const itemEl = dom8.getHighlightedItemEl(ctx2);
          if (!itemEl || itemEl.dataset.disabled) return;
          queueMicrotask(() => itemEl.click());
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom8.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement) return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon) return;
          const rightSide = getPlacementSide(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent) return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setHighlightedItem(ctx2, evt) {
          set7.highlighted(ctx2, evt.id);
        },
        clearHighlightedItem(ctx2) {
          set7.highlighted(ctx2, null);
        },
        focusMenu(ctx2) {
          raf(() => {
            const contentEl = dom8.getContentEl(ctx2);
            const initialFocusEl = getInitialFocus({
              root: contentEl,
              enabled: !contains(contentEl, dom8.getActiveElement(ctx2)),
              filter(node2) {
                var _a8;
                return !((_a8 = node2.role) == null ? void 0 : _a8.startsWith("menuitem"));
              }
            });
            initialFocusEl == null ? void 0 : initialFocusEl.focus({ preventScroll: true });
          });
        },
        highlightFirstItem(ctx2) {
          const fn = !!dom8.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const first2 = dom8.getFirstEl(ctx2);
            if (!first2) return;
            set7.highlighted(ctx2, first2.id);
          });
        },
        highlightLastItem(ctx2) {
          const fn = !!dom8.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const last2 = dom8.getLastEl(ctx2);
            if (!last2) return;
            set7.highlighted(ctx2, last2.id);
          });
        },
        highlightNextItem(ctx2, evt) {
          const next2 = dom8.getNextEl(ctx2, evt.loop);
          set7.highlighted(ctx2, (next2 == null ? void 0 : next2.id) ?? null);
        },
        highlightPrevItem(ctx2, evt) {
          const prev2 = dom8.getPrevEl(ctx2, evt.loop);
          set7.highlighted(ctx2, (prev2 == null ? void 0 : prev2.id) ?? null);
        },
        invokeOnSelect(ctx2) {
          var _a8;
          if (!ctx2.highlightedValue) return;
          (_a8 = ctx2.onSelect) == null ? void 0 : _a8.call(ctx2, { value: ctx2.highlightedValue });
        },
        focusTrigger(ctx2, evt) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || evt.restoreFocus === false) return;
          queueMicrotask(() => {
            var _a8;
            return (_a8 = dom8.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        highlightMatchedItem(ctx2, evt) {
          const node2 = dom8.getElemByKey(ctx2, evt.key);
          if (!node2) return;
          set7.highlighted(ctx2, node2.id);
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom8.getHighlightedItemEl(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a8;
          (_a8 = ctx2.parent) == null ? void 0 : _a8.send("FOCUS_MENU");
        },
        setLastHighlightedItem(ctx2, evt) {
          ctx2.lastHighlightedValue = evt.id;
        },
        restoreHighlightedItem(ctx2) {
          if (!ctx2.lastHighlightedValue) return;
          set7.highlighted(ctx2, ctx2.lastHighlightedValue);
          ctx2.lastHighlightedValue = null;
        },
        restoreParentHighlightedItem(ctx2) {
          var _a8;
          (_a8 = ctx2.parent) == null ? void 0 : _a8.send("HIGHLIGHTED.RESTORE");
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}
var set7 = {
  highlighted(ctx, value) {
    var _a8;
    if (isEqual(ctx.highlightedValue, value)) return;
    ctx.highlightedValue = value;
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, { highlightedValue: value });
  }
};
var props8 = createProps()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open.controlled",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps9 = createSplitProps(props8);
var itemProps3 = createProps()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps3 = createSplitProps(itemProps3);
var itemGroupLabelProps = createProps()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var optionItemProps = createProps()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@ark-ui/react/dist/components/menu/use-menu.js
var import_react174 = __toESM(require_react(), 1);
var useMenu = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react174.useId)(),
    dir,
    getRootNode,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    ...props25
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props25.onOpenChange),
    onSelect: useEvent(props25.onSelect)
  };
  const [state2, send, machine27] = useMachine(machine8(initialContext), { context });
  const api = connect8(state2, send, normalizeProps);
  return { api, machine: machine27 };
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu-machine-context.js
var [MenuMachineProvider, useMenuMachineContext] = createContext3({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-trigger-item-context.js
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext3({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var MenuRoot = (props25) => {
  const [presenceProps, menuProps] = splitPresenceProps(props25);
  const [useMenuProps, localProps] = createSplitProps2()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, machine: machine27 } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps2({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine27);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react176.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime80.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime80.jsx)(MenuMachineProvider, { value: machine27, children: (0, import_jsx_runtime80.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime80.jsx)(PresenceProvider, { value: presence, ...localProps }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-root-provider.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react178 = __toESM(require_react(), 1);
var MenuRootProvider = (props25) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props25);
  const { api, machine: machine27 } = menu;
  const presence = usePresence(mergeProps2({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine27);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react178.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime81.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime81.jsx)(MenuMachineProvider, { value: machine27, children: (0, import_jsx_runtime81.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime81.jsx)(PresenceProvider, { value: presence, children }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-separator.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react180 = __toESM(require_react(), 1);
var MenuSeparator = (0, import_react180.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps2(menu.getSeparatorProps(), props25);
  return (0, import_jsx_runtime82.jsx)(ark.hr, { ...mergedProps, ref: ref2 });
});
MenuSeparator.displayName = "MenuSeparator";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react182 = __toESM(require_react(), 1);
var MenuTrigger = (0, import_react182.forwardRef)((props25, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props25
  );
  return (0, import_jsx_runtime83.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
MenuTrigger.displayName = "MenuTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger-item.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react184 = __toESM(require_react(), 1);
var MenuTriggerItem = (0, import_react184.forwardRef)((props25, ref2) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps2((getTriggerItemProps == null ? void 0 : getTriggerItemProps()) ?? {}, props25);
  return (0, import_jsx_runtime84.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuTriggerItem.displayName = "MenuTriggerItem";

// node_modules/@ark-ui/react/dist/components/menu/menu.js
var menu_exports = {};
__export(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react186 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover-context.js
var [PopoverProvider, usePopoverContext] = createContext3({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var PopoverAnchor = (0, import_react186.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getAnchorProps(), props25);
  return (0, import_jsx_runtime85.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverAnchor.displayName = "PopoverAnchor";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react188 = __toESM(require_react(), 1);
var PopoverArrow = (0, import_react188.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getArrowProps(), props25);
  return (0, import_jsx_runtime86.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow-tip.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react190 = __toESM(require_react(), 1);
var PopoverArrowTip = (0, import_react190.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getArrowTipProps(), props25);
  return (0, import_jsx_runtime87.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrowTip.displayName = "PopoverArrowTip";

// node_modules/@ark-ui/react/dist/components/popover/popover-close-trigger.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react192 = __toESM(require_react(), 1);
var PopoverCloseTrigger = (0, import_react192.forwardRef)(
  (props25, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps2(popover.getCloseTriggerProps(), props25);
    return (0, import_jsx_runtime88.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PopoverCloseTrigger.displayName = "PopoverCloseTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react194 = __toESM(require_react(), 1);
var PopoverContent = (0, import_react194.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(popover.getContentProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime89.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
PopoverContent.displayName = "PopoverContent";

// node_modules/@ark-ui/react/dist/components/popover/popover-context.js
var PopoverContext = (props25) => props25.children(usePopoverContext());

// node_modules/@ark-ui/react/dist/components/popover/popover-description.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react196 = __toESM(require_react(), 1);
var PopoverDescription = (0, import_react196.forwardRef)(
  (props25, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps2(popover.getDescriptionProps(), props25);
    return (0, import_jsx_runtime90.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverDescription.displayName = "PopoverDescription";

// node_modules/@ark-ui/react/dist/components/popover/popover-indicator.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react198 = __toESM(require_react(), 1);
var PopoverIndicator = (0, import_react198.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getIndicatorProps(), props25);
  return (0, import_jsx_runtime91.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverIndicator.displayName = "PopoverIndicator";

// node_modules/@ark-ui/react/dist/components/popover/popover-positioner.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react200 = __toESM(require_react(), 1);
var PopoverPositioner = (0, import_react200.forwardRef)(
  (props25, ref2) => {
    const popover = usePopoverContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(popover.getPositionerProps(), props25);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime92.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverPositioner.displayName = "PopoverPositioner";

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy9 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts11 = anatomy9.build();
var dom9 = createScope({
  getAnchorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom9.getById(ctx, dom9.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom9.getById(ctx, dom9.getTriggerId(ctx)),
  getContentEl: (ctx) => dom9.getById(ctx, dom9.getContentId(ctx)),
  getPositionerEl: (ctx) => dom9.getById(ctx, dom9.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom9.getById(ctx, dom9.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom9.getById(ctx, dom9.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom9.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom9.getFocusableEls(ctx)[0]
});
function connect9(state2, send, normalize2) {
  const open = state2.matches("open");
  const currentPlacement = state2.context.currentPlacement;
  const portalled = state2.context.currentPortalled;
  const rendered = state2.context.renderedElements;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom9.getArrowId(state2.context),
        ...parts11.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts11.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize2.element({
        ...parts11.anchor.attrs,
        dir: state2.context.dir,
        id: dom9.getAnchorId(state2.context)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts11.trigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        id: dom9.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom9.getContentId(state2.context),
        onPointerDown(event) {
          if (isSafari()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts11.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom9.getPositionerId(state2.context),
        ...parts11.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts11.content.attrs,
        dir: state2.context.dir,
        id: dom9.getContentId(state2.context),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? dom9.getTitleId(state2.context) : void 0,
        "aria-describedby": rendered.description ? dom9.getDescriptionId(state2.context) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts11.title.attrs,
        id: dom9.getTitleId(state2.context),
        dir: state2.context.dir
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts11.description.attrs,
        id: dom9.getDescriptionId(state2.context),
        dir: state2.context.dir
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts11.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom9.getCloseTriggerId(state2.context),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLOSE");
        }
      });
    }
  };
}
function machine9(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEscape: true,
        autoFocus: true,
        modal: false,
        portalled: true,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ]
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom9.getAnchorEl(ctx2) ?? dom9.getTriggerEl(ctx2);
          const getPositionerEl = () => dom9.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom9.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: dom9.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (ctx2.closeOnEscape) return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            persistentElements: ctx2.persistentElements,
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled) return;
          const getContentEl = () => dom9.getContentEl(ctx2);
          return proxyTabFocus(getContentEl, {
            triggerElement: dom9.getTriggerEl(ctx2),
            defer: true,
            onFocus(el) {
              el.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom9.getContentEl(ctx2), dom9.getTriggerEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal) return;
          return preventBodyScroll(dom9.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal) return;
          const contentEl = () => dom9.getContentEl(ctx2);
          return trapFocus(contentEl, {
            initialFocus: () => getInitialFocus({
              root: dom9.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            })
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const anchorEl = dom9.getAnchorEl(ctx2) ?? dom9.getTriggerEl(ctx2);
          const getPositionerEl = () => dom9.getPositionerEl(ctx2);
          getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!dom9.getTitleEl(ctx2),
              description: !!dom9.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          if (ctx2.modal) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom9.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2, evt) {
          var _a8;
          const restoreFocus = evt.restoreFocus ?? ((_a8 = evt.previousEvent) == null ? void 0 : _a8.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom9.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props9 = createProps()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps10 = createSplitProps(props9);

// node_modules/@ark-ui/react/dist/components/popover/use-popover.js
var import_react202 = __toESM(require_react(), 1);
var usePopover = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react202.useId)(),
    dir,
    getRootNode,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    ...props25
  };
  const context = {
    ...initialContext,
    open: props25.open,
    onOpenChange: useEvent(props25.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine9(initialContext), { context });
  return connect9(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var PopoverRoot = (props25) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props25);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps2({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime93.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime93.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root-provider.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var PopoverRootProvider = (props25) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props25);
  const presence = usePresence(mergeProps2({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime94.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime94.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-title.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react206 = __toESM(require_react(), 1);
var PopoverTitle = (0, import_react206.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps2(popover.getTitleProps(), props25);
  return (0, import_jsx_runtime95.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverTitle.displayName = "PopoverTitle";

// node_modules/@ark-ui/react/dist/components/popover/popover-trigger.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react208 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react208.forwardRef)((props25, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props25
  );
  return (0, import_jsx_runtime96.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover.js
var popover_exports = {};
__export(popover_exports, {
  Anchor: () => PopoverAnchor,
  Arrow: () => PopoverArrow,
  ArrowTip: () => PopoverArrowTip,
  CloseTrigger: () => PopoverCloseTrigger,
  Content: () => PopoverContent,
  Context: () => PopoverContext,
  Description: () => PopoverDescription,
  Indicator: () => PopoverIndicator,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  RootProvider: () => PopoverRootProvider,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-context.js
var [RadioGroupProvider, useRadioGroupContext] = createContext3({
  name: "RadioGroupContext",
  hookName: "useRadioGroupContext",
  providerName: "<RadioGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-context.js
var RadioGroupContext = (props25) => props25.children(useRadioGroupContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-indicator.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react210 = __toESM(require_react(), 1);
var RadioGroupIndicator = (0, import_react210.forwardRef)(
  (props25, ref2) => {
    const radioGroup = useRadioGroupContext();
    const mergedProps = mergeProps2(radioGroup.getIndicatorProps(), props25);
    return (0, import_jsx_runtime97.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupIndicator.displayName = "RadioGroupIndicator";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react212 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-context.js
var [RadioGroupItemProvider, useRadioGroupItemContext] = createContext3({
  name: "RadioGroupItemContext",
  hookName: "useRadioGroupItemContext",
  providerName: "<RadioGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-props-context.js
var [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext3({
  name: "RadioGroupItemPropsContext",
  hookName: "useRadioGroupItemPropsContext",
  providerName: "<RadioGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var RadioGroupItem = (0, import_react212.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, [
    "value",
    "disabled",
    "invalid"
  ]);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getItemProps(itemProps8), localProps);
  const itemState = radioGroup.getItemState(itemProps8);
  return (0, import_jsx_runtime98.jsx)(RadioGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime98.jsx)(RadioGroupItemPropsProvider, { value: itemProps8, children: (0, import_jsx_runtime98.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
});
RadioGroupItem.displayName = "RadioGroupItem";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-context.js
var RadioGroupItemContext = (props25) => props25.children(useRadioGroupItemContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-control.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react214 = __toESM(require_react(), 1);
var RadioGroupItemControl = (0, import_react214.forwardRef)(
  (props25, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps8 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps2(radioGroup.getItemControlProps(itemProps8), props25);
    return (0, import_jsx_runtime99.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemControl.displayName = "RadioGroupItemControl";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-hidden-input.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react216 = __toESM(require_react(), 1);
var RadioGroupItemHiddenInput = (0, import_react216.forwardRef)((props25, ref2) => {
  const radioGroup = useRadioGroupContext();
  const itemProps8 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps2(radioGroup.getItemHiddenInputProps(itemProps8), props25);
  return (0, import_jsx_runtime100.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
RadioGroupItemHiddenInput.displayName = "RadioGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-text.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react218 = __toESM(require_react(), 1);
var RadioGroupItemText = (0, import_react218.forwardRef)(
  (props25, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps8 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps2(radioGroup.getItemTextProps(itemProps8), props25);
    return (0, import_jsx_runtime101.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemText.displayName = "RadioGroupItemText";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-label.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react220 = __toESM(require_react(), 1);
var RadioGroupLabel = (0, import_react220.forwardRef)((props25, ref2) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps2(radioGroup.getLabelProps(), props25);
  return (0, import_jsx_runtime102.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
RadioGroupLabel.displayName = "RadioGroupLabel";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react224 = __toESM(require_react(), 1);

// node_modules/@zag-js/focus-visible/dist/index.mjs
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root))) {
    return;
  }
  const win = getWindow(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props25 = {}) {
  const { isTextInput, autoFocus, onChange, root } = props25;
  setupGlobalFocusEvents(root);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/@zag-js/element-rect/dist/index.mjs
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el) => el.getBoundingClientRect();
function trackElementRect(el, options) {
  const { scope = "rect", getRect = getRectFn, onChange } = options;
  const loop = getLoopFn({ scope, getRect });
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, {
      rect: {},
      callbacks: [onChange]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(onChange);
    onChange(getRect(el));
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2) return;
    const index = data2.callbacks.indexOf(onChange);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(options) {
  const { scope, getRect } = options;
  const isEqual3 = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = getRect(element);
      if (!isEqual3(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a, b) => a.width === b.width && a.height === b.height;
var isEqualPosition = (a, b) => a.top === b.top && a.left === b.left;
var isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);
function getEqualityFn(scope) {
  if (scope === "size") return isEqualSize;
  if (scope === "position") return isEqualPosition;
  return isEqualRect;
}

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy10 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts12 = anatomy10.build();
var dom10 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemHiddenInput) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemControl) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemLabel) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom10.getById(ctx, dom10.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom10.getById(ctx, dom10.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom10.getById(ctx, dom10.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a8;
    return (_a8 = dom10.getRootEl(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a8;
    return (_a8 = dom10.getRootEl(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom10.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom10.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom10.getById(ctx, dom10.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom10.getById(ctx, dom10.getItemId(ctx, id));
    if (!radioEl) return;
    return dom10.resolveRect(dom10.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect10(state2, send, normalize2) {
  const groupDisabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  function getItemState(props25) {
    return {
      invalid: !!props25.invalid,
      disabled: !!props25.disabled || groupDisabled,
      checked: state2.context.value === props25.value,
      focused: state2.context.focusedValue === props25.value,
      hovered: state2.context.hoveredValue === props25.value,
      active: state2.context.activeValue === props25.value
    };
  }
  function getItemDataAttrs(props25) {
    const radioState = getItemState(props25);
    return {
      "data-focus": dataAttr(radioState.focused),
      "data-focus-visible": dataAttr(radioState.focused && state2.context.focusVisible),
      "data-disabled": dataAttr(radioState.disabled),
      "data-readonly": dataAttr(readOnly),
      "data-state": radioState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.hovered),
      "data-invalid": dataAttr(radioState.invalid),
      "data-orientation": state2.context.orientation,
      "data-ssr": dataAttr(state2.context.ssr)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom10.getFirstEnabledAndCheckedInputEl(state2.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom10.getFirstEnabledInputEl(state2.context);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  };
  return {
    focus,
    value: state2.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize2.element({
        ...parts12.root.attrs,
        role: "radiogroup",
        id: dom10.getRootId(state2.context),
        "aria-labelledby": dom10.getLabelId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        "aria-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts12.label.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        id: dom10.getLabelId(state2.context),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.label({
        ...parts12.item.attrs,
        dir: state2.context.dir,
        id: dom10.getItemId(state2.context, props25.value),
        htmlFor: dom10.getItemHiddenInputId(state2.context, props25.value),
        ...getItemDataAttrs(props25),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props25.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props25.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getItemTextProps(props25) {
      return normalize2.element({
        ...parts12.itemText.attrs,
        dir: state2.context.dir,
        id: dom10.getItemLabelId(state2.context, props25.value),
        ...getItemDataAttrs(props25)
      });
    },
    getItemControlProps(props25) {
      const controlState = getItemState(props25);
      return normalize2.element({
        ...parts12.itemControl.attrs,
        dir: state2.context.dir,
        id: dom10.getItemControlId(state2.context, props25.value),
        "data-active": dataAttr(controlState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props25)
      });
    },
    getItemHiddenInputProps(props25) {
      const inputState = getItemState(props25);
      return normalize2.input({
        "data-ownedby": dom10.getRootId(state2.context),
        id: dom10.getItemHiddenInputId(state2.context, props25.value),
        type: "radio",
        name: state2.context.name || state2.context.id,
        form: state2.context.form,
        value: props25.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props25.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false, focusVisible: false });
        },
        onFocus() {
          const focusVisible = isFocusVisible();
          send({ type: "SET_FOCUSED", value: props25.value, focused: true, focusVisible });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props25.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.disabled,
        defaultChecked: inputState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      var _a8, _b7, _c6, _d6;
      return normalize2.element({
        id: dom10.getIndicatorId(state2.context),
        ...parts12.indicator.attrs,
        dir: state2.context.dir,
        hidden: state2.context.value == null,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, top, width, height",
          "--left": (_a8 = state2.context.indicatorRect) == null ? void 0 : _a8.left,
          "--top": (_b7 = state2.context.indicatorRect) == null ? void 0 : _b7.top,
          "--width": (_c6 = state2.context.indicatorRect) == null ? void 0 : _c6.width,
          "--height": (_d6 = state2.context.indicatorRect) == null ? void 0 : _d6.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: state2.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [state2.context.orientation === "horizontal" ? "left" : "top"]: state2.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not4 } = guards;
function machine10(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeValue: null,
        focusedValue: null,
        hoveredValue: null,
        disabled: false,
        orientation: "vertical",
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false,
        focusVisible: false,
        ssr: true
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect", "syncSsr"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState", "trackFocusVisible"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not4("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom10.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        },
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom10.getRootNode(ctx2) });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set8.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeValue = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedValue = evt.value;
          ctx2.focusVisible = evt.focusVisible;
        },
        syncInputElements(ctx2) {
          const inputs = dom10.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString2(ctx2.value);
        },
        cleanupObserver(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
          if (!dom10.getIndicatorEl(ctx2)) return;
          const value = ctx2.value;
          const radioEl = dom10.getActiveRadioEl(ctx2);
          if (value == null || !radioEl) {
            ctx2.indicatorRect = {};
            return;
          }
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom10.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom10.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom10.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked) return;
            dispatchInputCheckedEvent(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke5 = {
  change: (ctx) => {
    var _a8;
    if (ctx.value == null) return;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
  }
};
var set8 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke5.change(ctx);
  }
};
var props10 = createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps11 = createSplitProps(props10);
var itemProps4 = createProps()(["value", "disabled", "invalid"]);
var splitItemProps4 = createSplitProps(itemProps4);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group.js
var import_react222 = __toESM(require_react(), 1);
var useRadioGroup = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react222.useId)(),
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine10(initialContext), {
    context
  });
  return connect10(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var RadioGroupRoot = (0, import_react224.forwardRef)((props25, ref2) => {
  const [useRadioGroupProps, localProps] = createSplitProps2()(props25, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps2(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime103.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime103.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RadioGroupRoot.displayName = "RadioGroupRoot";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root-provider.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react226 = __toESM(require_react(), 1);
var RadioGroupRootProvider = (0, import_react226.forwardRef)(
  (props25, ref2) => {
    const [{ value: radioGroup }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(radioGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime104.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime104.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RadioGroupRootProvider.displayName = "RadioGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Context: () => RadioGroupContext,
  Indicator: () => RadioGroupIndicator,
  Item: () => RadioGroupItem,
  ItemContext: () => RadioGroupItemContext,
  ItemControl: () => RadioGroupItemControl,
  ItemHiddenInput: () => RadioGroupItemHiddenInput,
  ItemText: () => RadioGroupItemText,
  Label: () => RadioGroupLabel,
  Root: () => RadioGroupRoot,
  RootProvider: () => RadioGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-context.js
var [RatingGroupProvider, useRatingGroupContext] = createContext3({
  name: "RatingGroupContext",
  hookName: "useRatingGroupContext",
  providerName: "<RatingGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-context.js
var RatingGroupContext = (props25) => props25.children(useRatingGroupContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-control.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react228 = __toESM(require_react(), 1);
var RatingGroupControl = (0, import_react228.forwardRef)(
  (props25, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps2(ratingGroup.getControlProps(), props25);
    return (0, import_jsx_runtime105.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupControl.displayName = "RatingGroupControl";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-hidden-input.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react230 = __toESM(require_react(), 1);
var RatingGroupHiddenInput = (0, import_react230.forwardRef)(
  (props25, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps2(ratingGroup.getHiddenInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime106.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
RatingGroupHiddenInput.displayName = "RatingGroupHiddenInput";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react232 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-item-context.js
var [RatingGroupItemProvider, useRatingGroupItemContext] = createContext3({
  name: "RatingGroupItemContext",
  hookName: "useRatingGroupItemContext",
  providerName: "<RatingGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var RatingGroupItem = (0, import_react232.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, ["index"]);
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps2(ratingGroup.getItemProps(itemProps8), localProps);
  const itemState = ratingGroup.getItemState(itemProps8);
  return (0, import_jsx_runtime107.jsx)(RatingGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime107.jsx)(ark.span, { ...mergedProps, ref: ref2 }) });
});
RatingGroupItem.displayName = "RatingGroupItem";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item-context.js
var RatingGroupItemContext = (props25) => props25.children(useRatingGroupItemContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-label.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react234 = __toESM(require_react(), 1);
var RatingGroupLabel = (0, import_react234.forwardRef)(
  (props25, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps2(ratingGroup.getLabelProps(), props25);
    return (0, import_jsx_runtime108.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupLabel.displayName = "RatingGroupLabel";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react238 = __toESM(require_react(), 1);

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy11 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts13 = anatomy11.build();
var dom11 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `rating:${ctx.id}:item:${id}`;
  },
  getRootEl: (ctx) => dom11.getById(ctx, dom11.getRootId(ctx)),
  getControlEl: (ctx) => dom11.getById(ctx, dom11.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query(dom11.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom11.getById(ctx, dom11.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom11.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
function connect11(state2, send, normalize2) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const value = state2.context.value;
  const hoveredValue = state2.context.hoveredValue;
  const translations = state2.context.translations;
  function getItemState(props25) {
    const value2 = state2.context.isHovering ? state2.context.hoveredValue : state2.context.value;
    const equal = Math.ceil(value2) === props25.index;
    const highlighted = props25.index <= value2 || equal;
    const half = equal && Math.abs(value2 - props25.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || state2.context.value === -1 && props25.index === 1
    };
  }
  return {
    hovering: state2.context.isHovering,
    value,
    hoveredValue,
    count: state2.context.count,
    items: Array.from({ length: state2.context.count }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send("CLEAR_VALUE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts13.root.attrs,
        dir: state2.context.dir,
        id: dom11.getRootId(state2.context)
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        name: state2.context.name,
        form: state2.context.form,
        type: "text",
        hidden: true,
        disabled,
        readOnly,
        required: state2.context.required,
        id: dom11.getHiddenInputId(state2.context),
        defaultValue: state2.context.value
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts13.label.attrs,
        dir: state2.context.dir,
        id: dom11.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        htmlFor: dom11.getHiddenInputId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = dom11.getRadioEl(state2.context, 1);
          radioEl == null ? void 0 : radioEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: dom11.getControlId(state2.context),
        ...parts13.control.attrs,
        dir: state2.context.dir,
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": dom11.getLabelId(state2.context),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_OVER");
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_LEAVE");
        }
      });
    },
    getItemState,
    getItemProps(props25) {
      const { index } = props25;
      const itemState = getItemState(props25);
      const valueText = translations.ratingValueText(index);
      return normalize2.element({
        ...parts13.item.attrs,
        dir: state2.context.dir,
        id: dom11.getItemId(state2.context, index.toString()),
        role: "radio",
        tabIndex: (() => {
          if (readOnly) return itemState.checked ? 0 : void 0;
          if (disabled) return void 0;
          return itemState.checked ? 0 : -1;
        })(),
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "aria-setsize": state2.context.count,
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = getEventPoint(event);
          const relativePoint = getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state2.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send("FOCUS");
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        }
      });
    }
  };
}
function machine11(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        count: 5,
        dir: "ltr",
        value: -1,
        readOnly: false,
        disabled: false,
        ...ctx,
        hoveredValue: -1,
        fieldsetDisabled: false,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"]
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => {
          var _a8;
          return !!((_a8 = dom11.getControlEl(ctx2)) == null ? void 0 : _a8.contains(dom11.getActiveElement(ctx2)));
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom11.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set9.value(ctx2, initialContext.value);
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          set9.hoveredValue(ctx2, -1);
        },
        focusActiveRadio(ctx2) {
          raf(() => {
            var _a8;
            return (_a8 = dom11.getRadioEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          set9.value(ctx2, Math.max(0, ctx2.value - factor));
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          set9.value(ctx2, Math.min(ctx2.count, value + factor));
        },
        setValueToMin(ctx2) {
          set9.value(ctx2, 1);
        },
        setValueToMax(ctx2) {
          set9.value(ctx2, ctx2.count);
        },
        setValue(ctx2, evt) {
          const value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
          set9.value(ctx2, value);
        },
        clearValue(ctx2) {
          set9.value(ctx2, -1);
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          set9.hoveredValue(ctx2, evt.index - factor);
        },
        roundValueIfNeeded(ctx2) {
          if (ctx2.allowHalf) return;
          ctx2.value = Math.round(ctx2.value);
        }
      }
    }
  );
}
var invoke6 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
    dom11.dispatchChangeEvent(ctx);
  },
  hoverChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onHoverChange) == null ? void 0 : _a8.call(ctx, { hoveredValue: ctx.hoveredValue });
  }
};
var set9 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke6.change(ctx);
  },
  hoveredValue: (ctx, value) => {
    if (isEqual(ctx.hoveredValue, value)) return;
    ctx.hoveredValue = value;
    invoke6.hoverChange(ctx);
  }
};
var props11 = createProps()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
var splitProps12 = createSplitProps(props11);
var itemProps5 = createProps()(["index"]);
var splitItemProps5 = createSplitProps(itemProps5);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group.js
var import_react236 = __toESM(require_react(), 1);
var useRatingGroup = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react236.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onHoverChange: useEvent(props25.onHoverChange)
  };
  const [state2, send] = useMachine(machine11(initialContext), {
    context
  });
  return connect11(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var RatingGroupRoot = (0, import_react238.forwardRef)((props25, ref2) => {
  const [useRatingProps, localProps] = createSplitProps2()(props25, [
    "allowHalf",
    "autoFocus",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "readOnly",
    "required",
    "translations",
    "value"
  ]);
  const ratingGroup = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps2(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime109.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime109.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RatingGroupRoot.displayName = "RatingGroupRoot";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root-provider.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react240 = __toESM(require_react(), 1);
var RatingGroupRootProvider = (0, import_react240.forwardRef)(
  (props25, ref2) => {
    const [{ value: ratingGroup }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(ratingGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime110.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime110.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RatingGroupRootProvider.displayName = "RatingGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group.js
var rating_group_exports = {};
__export(rating_group_exports, {
  Context: () => RatingGroupContext,
  Control: () => RatingGroupControl,
  HiddenInput: () => RatingGroupHiddenInput,
  Item: () => RatingGroupItem,
  ItemContext: () => RatingGroupItemContext,
  Label: () => RatingGroupLabel,
  Root: () => RatingGroupRoot,
  RootProvider: () => RatingGroupRootProvider
});

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject5(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject5(item) && hasProp(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject5(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class {
  constructor(options) {
    this.options = options;
    __publicField4(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    var _a8, _b7;
    if (item == null) return null;
    return ((_b7 = (_a8 = this.options).itemToValue) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    var _a8, _b7;
    if (item == null) return false;
    return ((_b7 = (_a8 = this.options).isItemDisabled) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    var _a8, _b7;
    if (item == null) return null;
    return ((_b7 = (_a8 = this.options).itemToString) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value, step = 1, clamp3 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp3 ? Math.min(index + step, this.size - 1) : index + step;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value, step = 1, clamp3 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp3 ? Math.max(index - step, 0) : index - step;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap4(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match4(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state: state2, currentValue, timeout = 350 } = options;
    const search = state2.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query2 = isRepeated ? search[0] : search;
    const item = this.getByText(query2, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value2) {
      state2.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  json() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match4 = (label, query2) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query2.toLowerCase()));
};
var wrap4 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};

// node_modules/@ark-ui/react/dist/components/collection.js
var createListCollection = (options) => ref(new ListCollection(options));

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react242 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-context.js
var [SelectProvider, useSelectContext] = createContext3({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var SelectClearTrigger = (0, import_react242.forwardRef)(
  (props25, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps2(select.getClearTriggerProps(), props25);
    return (0, import_jsx_runtime111.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
SelectClearTrigger.displayName = "SelectClearTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-content.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react244 = __toESM(require_react(), 1);
var SelectContent = (0, import_react244.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(select.getContentProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime112.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
SelectContent.displayName = "SelectContent";

// node_modules/@ark-ui/react/dist/components/select/select-context.js
var SelectContext = (props25) => props25.children(useSelectContext());

// node_modules/@ark-ui/react/dist/components/select/select-control.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react246 = __toESM(require_react(), 1);
var SelectControl = (0, import_react246.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getControlProps(), props25);
  return (0, import_jsx_runtime113.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectControl.displayName = "SelectControl";

// node_modules/@ark-ui/react/dist/components/select/select-hidden-select.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react248 = __toESM(require_react(), 1);
var SelectHiddenSelect = (0, import_react248.forwardRef)(
  (props25, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps2(select.getHiddenSelectProps(), props25);
    const isValueEmpty = select.value.length === 0;
    const field = useFieldContext();
    return (0, import_jsx_runtime114.jsxs)(ark.select, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2, children: [
      isValueEmpty && (0, import_jsx_runtime114.jsx)("option", { value: "" }),
      select.collection.items.map((item, index) => (0, import_jsx_runtime114.jsx)(
        "option",
        {
          value: select.collection.getItemValue(item) ?? "",
          disabled: select.collection.getItemDisabled(item)
        },
        index
      ))
    ] });
  }
);
SelectHiddenSelect.displayName = "SelectHiddenSelect";

// node_modules/@ark-ui/react/dist/components/select/select-indicator.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_react250 = __toESM(require_react(), 1);
var SelectIndicator = (0, import_react250.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getIndicatorProps(), props25);
  return (0, import_jsx_runtime115.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectIndicator.displayName = "SelectIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react252 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-context.js
var [SelectItemProvider, useSelectItemContext] = createContext3({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/use-select-item-props-context.js
var [SelectItemPropsProvider, useSelectItemPropsContext] = createContext3({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var SelectItem = (0, import_react252.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getItemProps(itemProps8), localProps);
  const itemState = select.getItemState(itemProps8);
  return (0, import_jsx_runtime116.jsx)(SelectItemPropsProvider, { value: itemProps8, children: (0, import_jsx_runtime116.jsx)(SelectItemProvider, { value: itemState, children: (0, import_jsx_runtime116.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
SelectItem.displayName = "SelectItem";

// node_modules/@ark-ui/react/dist/components/select/select-item-context.js
var SelectItemContext = (props25) => props25.children(useSelectItemContext());

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react254 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-group-props.js
var [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext3({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var SelectItemGroup = (0, import_react254.forwardRef)((props25, ref2) => {
  const id = (0, import_react254.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props25, ["id"]);
  const itemGroupProps3 = { id, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime117.jsx)(SelectItemGroupPropsProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime117.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SelectItemGroup.displayName = "SelectItemGroup";

// node_modules/@ark-ui/react/dist/components/select/select-item-group-label.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react256 = __toESM(require_react(), 1);
var SelectItemGroupLabel = (0, import_react256.forwardRef)(
  (props25, ref2) => {
    const select = useSelectContext();
    const itemGroupProps3 = useSelectItemGroupPropsContext();
    const mergedProps = mergeProps2(
      select.getItemGroupLabelProps({ htmlFor: itemGroupProps3.id }),
      props25
    );
    return (0, import_jsx_runtime118.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemGroupLabel.displayName = "SelectItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/select/select-item-indicator.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react258 = __toESM(require_react(), 1);
var SelectItemIndicator = (0, import_react258.forwardRef)(
  (props25, ref2) => {
    const select = useSelectContext();
    const itemProps8 = useSelectItemPropsContext();
    const mergedProps = mergeProps2(select.getItemIndicatorProps(itemProps8), props25);
    return (0, import_jsx_runtime119.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemIndicator.displayName = "SelectItemIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item-text.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react260 = __toESM(require_react(), 1);
var SelectItemText = (0, import_react260.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const itemProps8 = useSelectItemPropsContext();
  const mergedProps = mergeProps2(select.getItemTextProps(itemProps8), props25);
  return (0, import_jsx_runtime120.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SelectItemText.displayName = "SelectItemText";

// node_modules/@ark-ui/react/dist/components/select/select-label.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react262 = __toESM(require_react(), 1);
var SelectLabel = (0, import_react262.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getLabelProps(), props25);
  return (0, import_jsx_runtime121.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SelectLabel.displayName = "SelectLabel";

// node_modules/@ark-ui/react/dist/components/select/select-list.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react264 = __toESM(require_react(), 1);
var SelectList = (0, import_react264.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getListProps(), props25);
  return (0, import_jsx_runtime122.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectList.displayName = "SelectList";

// node_modules/@ark-ui/react/dist/components/select/select-positioner.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var import_react266 = __toESM(require_react(), 1);
var SelectPositioner = (0, import_react266.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getPositionerProps(), props25);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime123.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectPositioner.displayName = "SelectPositioner";

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react270 = __toESM(require_react(), 1);

// node_modules/@zag-js/select/dist/index.mjs
var anatomy12 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts14 = anatomy12.build();
var collection = (options) => {
  return ref(new ListCollection(options));
};
collection.empty = () => {
  return ref(new ListCollection({ items: [] }));
};
var dom12 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:option:${id}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
  },
  getHiddenSelectEl: (ctx) => dom12.getById(ctx, dom12.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom12.getById(ctx, dom12.getContentId(ctx)),
  getControlEl: (ctx) => dom12.getById(ctx, dom12.getControlId(ctx)),
  getTriggerEl: (ctx) => dom12.getById(ctx, dom12.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom12.getById(ctx, dom12.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom12.getById(ctx, dom12.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom12.getById(ctx, dom12.getItemId(ctx, ctx.highlightedValue));
  }
});
function connect12(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const focused = state2.matches("focused");
  const highlightedValue = state2.context.highlightedValue;
  const highlightedItem = state2.context.highlightedItem;
  const selectedItems = state2.context.selectedItems;
  const isTypingAhead = state2.context.isTypingAhead;
  const collection2 = state2.context.collection;
  const ariaActiveDescendant = highlightedValue ? dom12.getItemId(state2.context, highlightedValue) : void 0;
  function getItemState(props25) {
    const _disabled = collection2.getItemDisabled(props25.item);
    const value = collection2.getItemValue(props25.item);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    focused,
    empty: state2.context.value.length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: state2.context.hasSelectedItems,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    collection: collection2,
    multiple: !!state2.context.multiple,
    disabled: !!disabled,
    setCollection(collection3) {
      send({ type: "COLLECTION.SET", value: collection3 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      var _a8;
      (_a8 = dom12.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection2.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts14.root.attrs,
        dir: state2.context.dir,
        id: dom12.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        dir: state2.context.dir,
        id: dom12.getLabelId(state2.context),
        ...parts14.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        htmlFor: dom12.getHiddenSelectId(state2.context),
        onClick(event) {
          var _a8;
          if (event.defaultPrevented) return;
          if (disabled) return;
          (_a8 = dom12.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts14.control.attrs,
        dir: state2.context.dir,
        id: dom12.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts14.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        id: dom12.getTriggerId(state2.context),
        disabled,
        dir: state2.context.dir,
        type: "button",
        role: "combobox",
        "aria-controls": dom12.getContentId(state2.context),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": dom12.getLabelId(state2.context),
        ...parts14.trigger.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-placement": state2.context.currentPlacement,
        "data-placeholder-shown": dataAttr(!state2.context.hasSelectedItems),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send("TRIGGER.FOCUS");
        },
        onBlur() {
          send("TRIGGER.BLUR");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts14.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        id: dom12.getItemId(state2.context, itemState.value),
        role: "option",
        ...parts14.item.attrs,
        dir: state2.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === state2.context.highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props25.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = state2.previousEvent.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts14.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        "aria-hidden": true,
        ...parts14.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props25) {
      const { htmlFor } = props25;
      return normalize2.element({
        ...parts14.itemGroupLabel.attrs,
        id: dom12.getItemGroupLabelId(state2.context, htmlFor),
        role: "group",
        dir: state2.context.dir
      });
    },
    getItemGroupProps(props25) {
      const { id } = props25;
      return normalize2.element({
        ...parts14.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom12.getItemGroupId(state2.context, id),
        "aria-labelledby": dom12.getItemGroupLabelId(state2.context, id),
        dir: state2.context.dir
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts14.clearTrigger.attrs,
        id: dom12.getClearTriggerId(state2.context),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr(invalid),
        disabled,
        hidden: !state2.context.hasSelectedItems,
        dir: state2.context.dir,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLEAR.CLICK");
        }
      });
    },
    getHiddenSelectProps() {
      return normalize2.select({
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        multiple: state2.context.multiple,
        required: state2.context.required,
        "aria-hidden": true,
        id: dom12.getHiddenSelectId(state2.context),
        defaultValue: state2.context.multiple ? state2.context.value : state2.context.value[0],
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          var _a8;
          (_a8 = dom12.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        "aria-labelledby": dom12.getLabelId(state2.context)
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts14.positioner.attrs,
        dir: state2.context.dir,
        id: dom12.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        hidden: !open,
        dir: state2.context.dir,
        id: dom12.getContentId(state2.context),
        role: composite ? "listbox" : "dialog",
        ...parts14.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        "aria-labelledby": dom12.getLabelId(state2.context),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts14.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom12.getTriggerId(state2.context),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && state2.context.multiple ? true : void 0
      });
    }
  };
}
var { and: and6, not: not5, or: or3 } = guards;
function machine12(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        loopFocus: false,
        closeOnSelect: !ctx.multiple,
        disabled: false,
        readOnly: false,
        composite: true,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection.empty(),
        typeahead: getByTypeahead.defaultOptions,
        fieldsetDisabled: false,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly)
      },
      initial: ctx.open ? "open" : "idle",
      created: ["syncCollection"],
      entry: ["syncSelectElement"],
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectedItems", "syncSelectElement"],
        highlightedValue: ["syncHighlightedItem"],
        collection: ["syncCollection"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "CLEAR.CLICK": {
          actions: ["clearSelectedItems", "focusTriggerEl"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                guard: "isTriggerArrowUpEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightComputedLastItem"]
              },
              {
                guard: or3("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                target: "open",
                actions: ["setInitialFocus", "highlightComputedFirstItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ],
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.ENTER": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and6(not5("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not5("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and6(not5("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not5("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not5("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not5("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not5("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "focused",
              actions: ["focusTriggerEl", "clearHighlightedItem"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and6("closeOnSelect", "isOpenControlled"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and6("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and6("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "POSITIONING.SET": {
              actions: ["reposition"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loopFocus,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => !!ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.firstValue,
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.lastValue,
        closeOnSelect: (ctx2, evt) => !!(evt.closeOnSelect ?? ctx2.closeOnSelect),
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isTriggerClickEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.CLICK";
        },
        isTriggerEnterEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ENTER";
        },
        isTriggerArrowUpEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_UP";
        },
        isTriggerArrowDownEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_DOWN";
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom12.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set10.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const contentEl = () => dom12.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: [dom12.getTriggerEl(ctx2), dom12.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom12.getTriggerEl(ctx2);
          const positionerEl = () => dom12.getPositionerEl(ctx2);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = (immediate) => {
            if (ctx2.highlightedValue == null) return;
            const state2 = getState();
            if (state2.event.type.includes("POINTER")) return;
            const optionEl = dom12.getHighlightedOptionEl(ctx2);
            const contentEl2 = dom12.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2(true));
          const contentEl = () => dom12.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec2(false);
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom12.getPositionerEl(ctx2);
          getPlacement(dom12.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
          set10.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getNextValue(ctx2.highlightedValue);
          set10.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set10.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set10.highlightedItem(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf(() => {
            const element = getInitialFocus({
              root: dom12.getContentEl(ctx2)
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        focusTriggerEl(ctx2, evt) {
          var _a8;
          const restoreFocus = evt.restoreFocus ?? ((_a8 = evt.previousEvent) == null ? void 0 : _a8.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom12.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          let value = evt.value ?? ctx2.highlightedValue;
          if (value == null) return;
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);
          value = nullable ? null : value;
          set10.selectedItem(ctx2, value, nullable);
        },
        highlightComputedFirstItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;
          set10.highlightedItem(ctx2, value);
        },
        highlightComputedLastItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;
          set10.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems) return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set10.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set10.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null) return;
          set10.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set10.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set10.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);
          const value = nullable ? null : evt.value;
          set10.selectedItem(ctx2, value, nullable);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set10.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set10.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set10.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.getPreviousValue(ctx2.value[0]);
          set10.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.getNextValue(ctx2.value[0]);
          set10.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set10.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set10.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null) return;
          set10.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          var _a8;
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            (_a8 = dom12.getContentEl(ctx2)) == null ? void 0 : _a8.scrollTo(0, 0);
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom12.getHiddenSelectEl(ctx2);
          if (!selectEl) return;
          if (ctx2.value.length === 0 && !ctx2.multiple) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = ctx2.value.includes(option.value);
          }
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncCollection(ctx2) {
          const selectedItems = ctx2.collection.findMany(ctx2.value);
          const valueAsString = ctx2.collection.stringifyItems(selectedItems);
          ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
        },
        syncSelectedItems(ctx2) {
          sync3.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync3.highlightChange(ctx2);
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  raf(() => {
    const node2 = dom12.getHiddenSelectEl(ctx);
    if (!node2) return;
    const win = dom12.getWin(ctx);
    const changeEvent = new win.Event("change", { bubbles: true, composed: true });
    node2.dispatchEvent(changeEvent);
  });
}
var sync3 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((value) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.getItemValue(item) === value);
      if (foundItem) return foundItem;
      return ctx.collection.find(value);
    });
    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
  }
};
var invoke7 = {
  valueChange: (ctx) => {
    var _a8;
    sync3.valueChange(ctx);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a8;
    sync3.highlightChange(ctx);
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem,
      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
    });
  }
};
var set10 = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value)) return;
    if (value == null && !force) return;
    if (value == null && force) {
      ctx.value = [];
      invoke7.valueChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    invoke7.valueChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke7.valueChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value)) return;
    if (value == null && !force) return;
    ctx.highlightedValue = value ?? null;
    invoke7.highlightChange(ctx);
  }
};
var props12 = createProps()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
var splitProps13 = createSplitProps(props12);
var itemProps6 = createProps()(["item", "persistFocus"]);
var splitItemProps6 = createSplitProps(itemProps6);
var itemGroupProps2 = createProps()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@ark-ui/react/dist/components/select/use-select.js
var import_react268 = __toESM(require_react(), 1);
var useSelect = (props25) => {
  const { collection: collection2, ...selectProps } = props25;
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react268.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenSelect: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    dir: locale.dir,
    getRootNode: environment.getRootNode,
    collection: collection2,
    open: props25.defaultOpen,
    value: props25.defaultValue,
    "open.controlled": props25.open !== void 0,
    ...selectProps
  };
  const context = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      value: props25.value,
      onValueChange: useEvent(props25.onValueChange, { sync: true }),
      onHighlightChange: useEvent(props25.onHighlightChange),
      onOpenChange: useEvent(props25.onOpenChange)
    };
  })();
  const [state2, send, service] = useMachine(machine12(initialContext), {
    context
  });
  (0, import_react268.useEffect)(() => {
    service.setContext({ collection: collection2 });
  }, [collection2]);
  return connect12(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var SelectImpl = (props25, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props25);
  const [useSelectProps, localProps] = createSplitProps2()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps2({ present: select.open }, presenceProps));
  const mergedProps = mergeProps2(select.getRootProps(), localProps);
  return (0, import_jsx_runtime124.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime124.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime124.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRoot = (0, import_react270.forwardRef)(SelectImpl);

// node_modules/@ark-ui/react/dist/components/select/select-root-provider.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react272 = __toESM(require_react(), 1);
var SelectImpl2 = (props25, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props25);
  const [{ value: select }, localProps] = createSplitProps2()(selectProps, [
    "value"
  ]);
  const presence = usePresence(mergeProps2({ present: select.open }, presenceProps));
  const mergedProps = mergeProps2(select.getRootProps(), localProps);
  return (0, import_jsx_runtime125.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime125.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime125.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRootProvider = (0, import_react272.forwardRef)(SelectImpl2);

// node_modules/@ark-ui/react/dist/components/select/select-trigger.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react274 = __toESM(require_react(), 1);
var SelectTrigger = (0, import_react274.forwardRef)((props25, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getTriggerProps(), props25);
  return (0, import_jsx_runtime126.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
SelectTrigger.displayName = "SelectTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-value-text.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react276 = __toESM(require_react(), 1);
var SelectValueText = (0, import_react276.forwardRef)((props25, ref2) => {
  const { children, placeholder, ...localprops } = props25;
  const select = useSelectContext();
  const mergedProps = mergeProps2(select.getValueTextProps(), localprops);
  return (0, import_jsx_runtime127.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || select.valueAsString || placeholder });
});
SelectValueText.displayName = "SelectValueText";

// node_modules/@ark-ui/react/dist/components/select/select.js
var select_exports = {};
__export(select_exports, {
  ClearTrigger: () => SelectClearTrigger,
  Content: () => SelectContent,
  Context: () => SelectContext,
  Control: () => SelectControl,
  HiddenSelect: () => SelectHiddenSelect,
  Indicator: () => SelectIndicator,
  Item: () => SelectItem,
  ItemContext: () => SelectItemContext,
  ItemGroup: () => SelectItemGroup,
  ItemGroupLabel: () => SelectItemGroupLabel,
  ItemIndicator: () => SelectItemIndicator,
  ItemText: () => SelectItemText,
  Label: () => SelectLabel,
  List: () => SelectList,
  Positioner: () => SelectPositioner,
  Root: () => SelectRoot,
  RootProvider: () => SelectRootProvider,
  Trigger: () => SelectTrigger,
  ValueText: () => SelectValueText
});

// node_modules/@ark-ui/react/dist/components/slider/use-slider-context.js
var [SliderProvider, useSliderContext] = createContext3({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<SliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-context.js
var SliderContext = (props25) => props25.children(useSliderContext());

// node_modules/@ark-ui/react/dist/components/slider/slider-control.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react278 = __toESM(require_react(), 1);
var SliderControl = (0, import_react278.forwardRef)((props25, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getControlProps(), props25);
  return (0, import_jsx_runtime128.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderControl.displayName = "SliderControl";

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_react280 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-thumb-props-context.js
var [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext3({
  name: "SliderThumbPropsContext",
  hookName: "useSliderThumbPropsContext",
  providerName: "<SliderThumbPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var SliderDraggingIndicator = (0, import_react280.forwardRef)(
  (props25, ref2) => {
    const slider = useSliderContext();
    const { index } = useSliderThumbPropsContext();
    const mergedProps = mergeProps2(slider.getDraggingIndicatorProps({ index }), props25);
    return (0, import_jsx_runtime129.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props25.children || slider.getThumbValue(index) });
  }
);
SliderDraggingIndicator.displayName = "SliderDraggingIndicator";

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react282 = __toESM(require_react(), 1);
var SliderHiddenInput = (0, import_react282.forwardRef)(
  (props25, ref2) => {
    const slider = useSliderContext();
    const thumbProps2 = useSliderThumbPropsContext();
    const mergedProps = mergeProps2(slider.getHiddenInputProps(thumbProps2), props25);
    return (0, import_jsx_runtime130.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
SliderHiddenInput.displayName = "SliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/slider/slider-label.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react284 = __toESM(require_react(), 1);
var SliderLabel = (0, import_react284.forwardRef)((props25, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getLabelProps(), props25);
  return (0, import_jsx_runtime131.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SliderLabel.displayName = "SliderLabel";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react286 = __toESM(require_react(), 1);
var SliderMarker = (0, import_react286.forwardRef)((props25, ref2) => {
  const [markerProps, localProps] = createSplitProps2()(props25, ["value"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getMarkerProps(markerProps), localProps);
  return (0, import_jsx_runtime132.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SliderMarker.displayName = "SliderMarker";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker-group.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react288 = __toESM(require_react(), 1);
var SliderMarkerGroup = (0, import_react288.forwardRef)(
  (props25, ref2) => {
    const slider = useSliderContext();
    const mergedProps = mergeProps2(slider.getMarkerGroupProps(), props25);
    return (0, import_jsx_runtime133.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SliderMarkerGroup.displayName = "SliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/slider/slider-range.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_react290 = __toESM(require_react(), 1);
var SliderRange = (0, import_react290.forwardRef)((props25, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getRangeProps(), props25);
  return (0, import_jsx_runtime134.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderRange.displayName = "SliderRange";

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react294 = __toESM(require_react(), 1);

// node_modules/@zag-js/element-size/dist/index.mjs
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({ width: element.offsetWidth, height: element.offsetHeight });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver((entries) => {
    if (!Array.isArray(entries) || !entries.length) return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({ width, height });
  });
  observer.observe(element, { box: "border-box" });
  return () => observer.unobserve(element);
}
function trackElementsSize(options) {
  const { getNodes, observeMutation = true, callback } = options;
  const cleanups2 = [];
  let firstNode = null;
  function trigger() {
    const elements = getNodes();
    firstNode = elements[0];
    const fns = elements.map(
      (element, index) => trackElementSize(element, (size3) => {
        callback(size3, index);
      })
    );
    cleanups2.push(...fns);
  }
  trigger();
  if (observeMutation) {
    const fn = trackMutation(firstNode, trigger);
    cleanups2.push(fn);
  }
  return () => {
    cleanups2.forEach((cleanup) => {
      cleanup == null ? void 0 : cleanup();
    });
  };
}
function trackMutation(el, cb) {
  var _a8;
  if (!el || !el.parentElement) return;
  const win = ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, { childList: true });
  return () => {
    observer.disconnect();
  };
}

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy13 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
var parts15 = anatomy13.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset3 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset3}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range2 = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset3 = getThumbOffset({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset3 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom13 = createScope({
  ...styleGetterFns,
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.thumb) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:input:${index}`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.valueText) ?? `slider:${ctx.id}:value-text`;
  },
  getMarkerId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.marker) == null ? void 0 : _b7.call(_a8, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom13.getById(ctx, dom13.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom13.getById(ctx, dom13.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom13.getById(ctx, dom13.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom13.getById(ctx, dom13.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom13.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom13.getElements(ctx)[0],
  getRangeEl: (ctx) => dom13.getById(ctx, dom13.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom13.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom13.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
function normalizeValues(ctx, nextValues) {
  return nextValues.map((value, index, values) => {
    return constrainValue2({ ...ctx, value: values }, value, index);
  });
}
function getRangeAtIndex(ctx, index) {
  return getValueRanges(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];
}
function constrainValue2(ctx, value, index) {
  const range2 = getRangeAtIndex(ctx, index);
  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step);
  return clampValue(snapValue, range2.min, range2.max);
}
function decrement(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getPreviousStepValue(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function increment(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getNextStepValue(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function getClosestIndex(ctx, pointValue) {
  return getClosestValueIndex(ctx.value, pointValue);
}
function assignArray(current, next2) {
  for (let i = 0; i < next2.length; i++) {
    const value = next2[i];
    current[i] = value;
  }
}
function connect13(state2, send, normalize2) {
  const ariaLabel = state2.context["aria-label"];
  const ariaLabelledBy = state2.context["aria-labelledby"];
  const sliderValue = state2.context.value;
  const focused = state2.matches("focus");
  const dragging = state2.matches("dragging");
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const interactive = state2.context.isInteractive;
  const isHorizontal = state2.context.orientation === "horizontal";
  const isVertical = state2.context.orientation === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent(value, state2.context.min, state2.context.max);
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, state2.context.min, state2.context.max, state2.context.step);
  }
  return {
    value: state2.context.value,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(state2.context, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(state2.context, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts15.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        id: dom13.getLabelId(state2.context),
        htmlFor: dom13.getHiddenInputId(state2.context, 0),
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          (_a8 = dom13.getFirstEl(state2.context)) == null ? void 0 : _a8.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize2.element({
        ...parts15.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-dragging": dataAttr(dragging),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom13.getRootId(state2.context),
        dir: state2.context.dir,
        style: dom13.getRootStyle(state2.context)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts15.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom13.getValueTextId(state2.context)
      });
    },
    getTrackProps() {
      return normalize2.element({
        ...parts15.track.attrs,
        dir: state2.context.dir,
        id: dom13.getTrackId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props25) {
      var _a8, _b7;
      const { index = 0, name } = props25;
      const value = sliderValue[index];
      const range2 = getRangeAtIndex(state2.context, index);
      const valueText = (_b7 = (_a8 = state2.context).getAriaValueText) == null ? void 0 : _b7.call(_a8, { value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize2.element({
        ...parts15.thumb.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-name": name,
        id: dom13.getThumbId(state2.context, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused && state2.context.focusedIndex === index),
        "data-dragging": dataAttr(dragging && state2.context.focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? dom13.getLabelId(state2.context),
        "aria-orientation": state2.context.orientation,
        "aria-valuemax": range2.max,
        "aria-valuemin": range2.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: dom13.getThumbStyle(state2.context, index),
        onPointerDown(event) {
          if (!interactive) return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props25) {
      const { index = 0, name } = props25;
      return normalize2.input({
        name: name ?? (state2.context.name ? state2.context.name + (state2.context.value.length > 1 ? "[]" : "") : void 0),
        form: state2.context.form,
        type: "text",
        hidden: true,
        defaultValue: state2.context.value[index],
        id: dom13.getHiddenInputId(state2.context, index)
      });
    },
    getRangeProps() {
      return normalize2.element({
        id: dom13.getRangeId(state2.context),
        ...parts15.range.attrs,
        dir: state2.context.dir,
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        style: dom13.getRangeStyle(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts15.control.attrs,
        dir: state2.context.dir,
        id: dom13.getControlId(state2.context),
        "data-dragging": dataAttr(dragging),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: dom13.getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize2.element({
        ...parts15.markerGroup.attrs,
        role: "presentation",
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-orientation": state2.context.orientation,
        style: dom13.getMarkerGroupStyle()
      });
    },
    getMarkerProps(props25) {
      const style = dom13.getMarkerStyle(state2.context, props25.value);
      let markerState;
      const first2 = state2.context.value[0];
      const last2 = state2.context.value[state2.context.value.length - 1];
      if (props25.value < first2) {
        markerState = "under-value";
      } else if (props25.value > last2) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize2.element({
        ...parts15.marker.attrs,
        id: dom13.getMarkerId(state2.context, props25.value),
        role: "presentation",
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-value": props25.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    },
    getDraggingIndicatorProps(props25) {
      const { index = 0 } = props25;
      const isDragging = index === state2.context.focusedIndex && dragging;
      return normalize2.element({
        ...parts15.draggingIndicator.attrs,
        role: "presentation",
        dir: state2.context.dir,
        hidden: !isDragging,
        "data-orientation": state2.context.orientation,
        "data-state": isDragging ? "open" : "closed",
        style: dom13.getThumbStyle(state2.context, index)
      });
    }
  };
}
var isEqualSize2 = (a, b) => {
  return (a == null ? void 0 : a.width) === (b == null ? void 0 : b.width) && (a == null ? void 0 : a.height) === (b == null ? void 0 : b.height);
};
function machine13(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        min: 0,
        max: 100,
        step: 1,
        value: [0],
        origin: "start",
        orientation: "horizontal",
        dir: "ltr",
        minStepsBetweenThumbs: 0,
        disabled: false,
        readOnly: false,
        ...ctx,
        focusedIndex: -1,
        fieldsetDisabled: false
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize != null,
        valuePercent(ctx2) {
          return ctx2.value.map((value) => 100 * getValuePercent(value, ctx2.min, ctx2.max));
        }
      },
      watch: {
        value: ["syncInputElements"]
      },
      entry: ["coarseValue"],
      activities: ["trackFormControlState", "trackThumbsSize"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        INCREMENT: {
          actions: "incrementThumbAtIndex"
        },
        DECREMENT: {
          actions: "decrementThumbAtIndex"
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            FOCUS: {
              target: "focus",
              actions: "setFocusedIndex"
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            }
          }
        },
        focus: {
          entry: "focusActiveThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            },
            ARROW_DEC: {
              actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            ARROW_INC: {
              actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            HOME: {
              actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
            },
            END: {
              actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            }
          }
        },
        dragging: {
          entry: "focusActiveThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        hasIndex: (_ctx, evt) => evt.index != null
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom13.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set11.value(ctx2, initialContext.value);
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom13.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbsSize(ctx2) {
          if (ctx2.thumbAlignment !== "contain" || ctx2.thumbSize) return;
          return trackElementsSize({
            getNodes: () => dom13.getElements(ctx2),
            observeMutation: true,
            callback(size3) {
              if (!size3 || isEqualSize2(ctx2.thumbSize, size3)) return;
              ctx2.thumbSize = size3;
            }
          });
        }
      },
      actions: {
        syncInputElements(ctx2) {
          ctx2.value.forEach((value, index) => {
            const inputEl = dom13.getHiddenInputEl(ctx2, index);
            dom13.setValue(inputEl, value);
          });
        },
        invokeOnChangeEnd(ctx2) {
          invoke8.valueChangeEnd(ctx2);
        },
        setClosestThumbIndex(ctx2, evt) {
          const pointValue = dom13.getValueFromPoint(ctx2, evt.point);
          if (pointValue == null) return;
          const focusedIndex = getClosestIndex(ctx2, pointValue);
          set11.focusedIndex(ctx2, focusedIndex);
        },
        setFocusedIndex(ctx2, evt) {
          set11.focusedIndex(ctx2, evt.index);
        },
        clearFocusedIndex(ctx2) {
          set11.focusedIndex(ctx2, -1);
        },
        setPointerValue(ctx2, evt) {
          const pointerValue = dom13.getValueFromPoint(ctx2, evt.point);
          if (pointerValue == null) return;
          const value = constrainValue2(ctx2, pointerValue, ctx2.focusedIndex);
          set11.valueAtIndex(ctx2, ctx2.focusedIndex, value);
        },
        focusActiveThumb(ctx2) {
          raf(() => {
            const thumbEl = dom13.getThumbEl(ctx2, ctx2.focusedIndex);
            thumbEl == null ? void 0 : thumbEl.focus({ preventScroll: true });
          });
        },
        decrementThumbAtIndex(ctx2, evt) {
          const value = decrement(ctx2, evt.index, evt.step);
          set11.value(ctx2, value);
        },
        incrementThumbAtIndex(ctx2, evt) {
          const value = increment(ctx2, evt.index, evt.step);
          set11.value(ctx2, value);
        },
        setFocusedThumbToMin(ctx2) {
          const { min: min4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set11.valueAtIndex(ctx2, ctx2.focusedIndex, min4);
        },
        setFocusedThumbToMax(ctx2) {
          const { max: max4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set11.valueAtIndex(ctx2, ctx2.focusedIndex, max4);
        },
        coarseValue(ctx2) {
          const value = normalizeValues(ctx2, ctx2.value);
          set11.value(ctx2, value);
        },
        setValueAtIndex(ctx2, evt) {
          const value = constrainValue2(ctx2, evt.value, evt.index);
          set11.valueAtIndex(ctx2, evt.index, value);
        },
        setValue(ctx2, evt) {
          const value = normalizeValues(ctx2, evt.value);
          set11.value(ctx2, value);
        }
      }
    }
  );
}
var invoke8 = {
  valueChange(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value)
    });
    dom13.dispatchChangeEvent(ctx);
  },
  valueChangeEnd(ctx) {
    var _a8;
    (_a8 = ctx.onValueChangeEnd) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value)
    });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      focusedIndex: ctx.focusedIndex
    });
  }
};
var set11 = {
  valueAtIndex: (ctx, index, value) => {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke8.valueChange(ctx);
  },
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    assignArray(ctx.value, value);
    invoke8.valueChange(ctx);
  },
  focusedIndex: (ctx, index) => {
    if (isEqual(ctx.focusedIndex, index)) return;
    ctx.focusedIndex = index;
    invoke8.focusChange(ctx);
  }
};
var props13 = createProps()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
var splitProps14 = createSplitProps(props13);
var thumbProps = createProps()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);

// node_modules/@ark-ui/react/dist/components/slider/use-slider.js
var import_react292 = __toESM(require_react(), 1);
var useSlider = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react292.useId)(),
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props25.onValueChangeEnd),
    onFocusChange: useEvent(props25.onFocusChange)
  };
  const [state2, send] = useMachine(machine13(initialContext), {
    context
  });
  return connect13(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var SliderRoot = (0, import_react294.forwardRef)((props25, ref2) => {
  const [useSliderProps, localProps] = createSplitProps2()(props25, [
    "aria-label",
    "aria-labelledby",
    "defaultValue",
    "disabled",
    "form",
    "getAriaValueText",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
  ]);
  const slider = useSlider(useSliderProps);
  const mergedProps = mergeProps2(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime135.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime135.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderRoot.displayName = "SliderRoot";

// node_modules/@ark-ui/react/dist/components/slider/slider-root-provider.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react296 = __toESM(require_react(), 1);
var SliderRootProvider = (0, import_react296.forwardRef)(
  (props25, ref2) => {
    const [{ value: slider }, localProps] = createSplitProps2()(props25, ["value"]);
    const mergedProps = mergeProps2(slider.getRootProps(), localProps);
    return (0, import_jsx_runtime136.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime136.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SliderRootProvider.displayName = "SliderRootProvider";

// node_modules/@ark-ui/react/dist/components/slider/slider-thumb.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react298 = __toESM(require_react(), 1);
var SliderThumb = (0, import_react298.forwardRef)((props25, ref2) => {
  const [thumbProps2, localProps] = createSplitProps2()(props25, ["index", "name"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getThumbProps(thumbProps2), localProps);
  return (0, import_jsx_runtime137.jsx)(SliderThumbPropsProvider, { value: thumbProps2, children: (0, import_jsx_runtime137.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderThumb.displayName = "SliderThumb";

// node_modules/@ark-ui/react/dist/components/slider/slider-track.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react300 = __toESM(require_react(), 1);
var SliderTrack = (0, import_react300.forwardRef)((props25, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getTrackProps(), props25);
  return (0, import_jsx_runtime138.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderTrack.displayName = "SliderTrack";

// node_modules/@ark-ui/react/dist/components/slider/slider-value-text.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var import_react302 = __toESM(require_react(), 1);
var SliderValueText = (0, import_react302.forwardRef)((props25, ref2) => {
  const { children, ...rest } = props25;
  const slider = useSliderContext();
  const mergedProps = mergeProps2(slider.getValueTextProps(), rest);
  return (0, import_jsx_runtime139.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || slider.value.join(", ") });
});
SliderValueText.displayName = "SliderValueText";

// node_modules/@ark-ui/react/dist/components/slider/slider.js
var slider_exports = {};
__export(slider_exports, {
  Context: () => SliderContext,
  Control: () => SliderControl,
  DraggingIndicator: () => SliderDraggingIndicator,
  HiddenInput: () => SliderHiddenInput,
  Label: () => SliderLabel,
  Marker: () => SliderMarker,
  MarkerGroup: () => SliderMarkerGroup,
  Range: () => SliderRange,
  Root: () => SliderRoot,
  RootProvider: () => SliderRootProvider,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  ValueText: () => SliderValueText
});

// node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext3({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props25) => props25.children(useSwitchContext());

// node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react304 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react304.forwardRef)((props25, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getControlProps(), props25);
  return (0, import_jsx_runtime140.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react306 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react306.forwardRef)(
  (props25, ref2) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps2(switchContext.getHiddenInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime141.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react308 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react308.forwardRef)((props25, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getLabelProps(), props25);
  return (0, import_jsx_runtime142.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react312 = __toESM(require_react(), 1);

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy14 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts16 = anatomy14.build();
var dom14 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom14.getById(ctx, dom14.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom14.getById(ctx, dom14.getHiddenInputId(ctx))
});
function connect14(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const checked = state2.context.checked;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts16.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getRootId(state2.context),
        htmlFor: dom14.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === dom14.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts16.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getLabelId(state2.context)
      });
    },
    getThumbProps() {
      return normalize2.element({
        ...parts16.thumb.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getThumbId(state2.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts16.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom14.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom14.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not6 } = guards;
function machine14(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not6("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not6("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom14.getRootEl(ctx2),
            keyboardNode: dom14.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom14.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom14.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom14.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set12.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set12.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom14.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke9 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onCheckedChange) == null ? void 0 : _a8.call(ctx, { checked: ctx.checked });
  }
};
var set12 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke9.change(ctx);
  }
};
var props14 = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps15 = createSplitProps(props14);

// node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react310 = __toESM(require_react(), 1);
var useSwitch = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react310.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props25.defaultChecked,
    ...props25
  };
  const context = {
    ...initialContext,
    checked: props25.checked,
    onCheckedChange: useEvent(props25.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine14(initialContext), { context });
  return connect14(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react312.forwardRef)((props25, ref2) => {
  const [switchProps, localProps] = createSplitProps2()(props25, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps2(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime143.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime143.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var import_react314 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react314.forwardRef)(
  (props25, ref2) => {
    const [{ value: api }, localProps] = createSplitProps2()(props25, ["value"]);
    const mergedProps = mergeProps2(api.getRootProps(), localProps);
    return (0, import_jsx_runtime144.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime144.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react316 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react316.forwardRef)((props25, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps2(switchContext.getThumbProps(), props25);
  return (0, import_jsx_runtime145.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar-context.js
var [AvatarProvider, useAvatarContext] = createContext3({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});

// node_modules/@ark-ui/react/dist/components/avatar/avatar-context.js
var AvatarContext = (props25) => props25.children(useAvatarContext());

// node_modules/@ark-ui/react/dist/components/avatar/avatar-fallback.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react318 = __toESM(require_react(), 1);
var AvatarFallback = (0, import_react318.forwardRef)((props25, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps2(avatar.getFallbackProps(), props25);
  return (0, import_jsx_runtime146.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
AvatarFallback.displayName = "AvatarFallback";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-image.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react320 = __toESM(require_react(), 1);
var AvatarImage = (0, import_react320.forwardRef)((props25, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps2(avatar.getImageProps(), props25);
  return (0, import_jsx_runtime147.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
AvatarImage.displayName = "AvatarImage";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react324 = __toESM(require_react(), 1);

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy15 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts17 = anatomy15.build();
var dom15 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom15.getById(ctx, dom15.getRootId(ctx)),
  getImageEl: (ctx) => dom15.getById(ctx, dom15.getImageId(ctx))
});
function connect15(state2, send, normalize2) {
  const loaded = state2.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts17.root.attrs,
        dir: state2.context.dir,
        id: dom15.getRootId(state2.context)
      });
    },
    getImageProps() {
      return normalize2.img({
        ...parts17.image.attrs,
        hidden: !loaded,
        dir: state2.context.dir,
        id: dom15.getImageId(state2.context),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "IMG.LOADED", src: "element" });
        },
        onError() {
          send({ type: "IMG.ERROR", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize2.element({
        ...parts17.fallback.attrs,
        dir: state2.context.dir,
        id: dom15.getFallbackId(state2.context),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
function machine15(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImageStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const imageEl = dom15.getImageEl(ctx2);
          return observeAttributes(imageEl, {
            attributes: ["src", "srcset"],
            callback() {
              send({ type: "SRC.CHANGE" });
            }
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom15.getRootEl(ctx2);
          return observeChildren(rootEl, {
            callback(records) {
              const removedNodes = Array.from(records[0].removedNodes);
              const removed = removedNodes.find(
                (node2) => node2.nodeType === Node.ELEMENT_NODE && node2.matches("[data-scope=avatar][data-part=image]")
              );
              if (removed) {
                send({ type: "IMG.UNMOUNT" });
              }
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "loaded" });
        },
        invokeOnError(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "error" });
        },
        checkImageStatus(ctx2, _evt, { send }) {
          const imageEl = dom15.getImageEl(ctx2);
          if (imageEl == null ? void 0 : imageEl.complete) {
            const type = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
            send({ type, src: "ssr" });
          }
        }
      }
    }
  );
}
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props15 = createProps()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps16 = createSplitProps(props15);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar.js
var import_react322 = __toESM(require_react(), 1);
var useAvatar = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react322.useId)(),
    dir,
    getRootNode,
    ...props25
  };
  const context = {
    ...initialContext,
    onStatusChange: useEvent(props25.onStatusChange)
  };
  const [state2, send] = useMachine(machine15(initialContext), { context });
  return connect15(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var AvatarRoot = (0, import_react324.forwardRef)((props25, ref2) => {
  const [useAvatarProps, localProps] = createSplitProps2()(props25, [
    "id",
    "ids",
    "onStatusChange"
  ]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps2(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime148.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime148.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
AvatarRoot.displayName = "AvatarRoot";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root-provider.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react326 = __toESM(require_react(), 1);
var AvatarRootProvider = (0, import_react326.forwardRef)(
  (props25, ref2) => {
    const [{ value: avatar }, localProps] = createSplitProps2()(props25, ["value"]);
    const mergedProps = mergeProps2(avatar.getRootProps(), localProps);
    return (0, import_jsx_runtime149.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime149.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
AvatarRootProvider.displayName = "AvatarRootProvider";

// node_modules/@ark-ui/react/dist/components/avatar/avatar.js
var avatar_exports = {};
__export(avatar_exports, {
  Context: () => AvatarContext,
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot,
  RootProvider: () => AvatarRootProvider
});

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js
var [CheckboxProvider, useCheckboxContext] = createContext3({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js
var CheckboxContext = (props25) => props25.children(useCheckboxContext());

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react328 = __toESM(require_react(), 1);
var CheckboxControl = (0, import_react328.forwardRef)((props25, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getControlProps(), props25);
  return (0, import_jsx_runtime150.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CheckboxControl.displayName = "CheckboxControl";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react330 = __toESM(require_react(), 1);

// node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy16 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
var parts18 = anatomy16.build();
var dom16 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom16.getById(ctx, dom16.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom16.getById(ctx, dom16.getHiddenInputId(ctx))
});
function connect16(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const checked = state2.context.isChecked;
  const indeterminate = state2.context.isIndeterminate;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": indeterminate ? "indeterminate" : state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: state2.context.checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts18.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom16.getRootId(state2.context),
        htmlFor: dom16.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          const target = getEventTarget(event);
          if (target === dom16.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts18.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom16.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts18.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom16.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts18.indicator.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        hidden: !indeterminate && !state2.context.checked
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom16.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom16.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not7 } = guards;
function machine16(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "checkbox",
      initial: "ready",
      context: {
        checked: false,
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not7("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not7("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      computed: {
        isIndeterminate: (ctx2) => isIndeterminate(ctx2.checked),
        isChecked: (ctx2) => isChecked(ctx2.checked),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom16.getRootEl(ctx2),
            keyboardNode: dom16.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom16.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom16.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom16.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          setElementChecked(inputEl, ctx2.isChecked);
          inputEl.indeterminate = ctx2.isIndeterminate;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
            ctx2.focusVisible = false;
          }
        },
        setChecked(ctx2, evt) {
          set13.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2) {
          const checked = isIndeterminate(ctx2.checked) ? true : !ctx2.checked;
          set13.checked(ctx2, checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom16.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: isChecked(ctx2.checked) });
        }
      }
    }
  );
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var invoke10 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onCheckedChange) == null ? void 0 : _a8.call(ctx, { checked: ctx.checked });
  }
};
var set13 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke10.change(ctx);
  }
};
var props16 = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps17 = createSplitProps(props16);

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js
var checkboxAnatomy = anatomy16.extendWith("group");

// node_modules/@ark-ui/react/dist/utils/use-controllable-state.js
var import_react329 = __toESM(require_react(), 1);
function useControllableState2(props25) {
  const { value, onChange, defaultValue } = props25;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react329.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0, import_react329.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange == null ? void 0 : onChange(value2);
      }
      setUncontrolledValue(value2);
      return onChange == null ? void 0 : onChange(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js
function useCheckboxGroup(props25 = {}) {
  const {
    defaultValue,
    value: controlledValue,
    onValueChange,
    disabled,
    readOnly,
    name,
    invalid
  } = props25;
  const interactive = !(disabled || readOnly);
  const onChangeProp = useEvent(onValueChange, { sync: true });
  const [value, setValue] = useControllableState2({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked2 = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked2(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interactive) return;
    if (isChecked2(val)) return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interactive) return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props26) => {
    return {
      checked: props26.value != null ? isChecked2(props26.value) : void 0,
      onCheckedChange() {
        if (props26.value != null) {
          toggleValue(props26.value);
        }
      },
      name,
      disabled,
      readOnly,
      invalid
    };
  };
  return {
    isChecked: isChecked2,
    value,
    name,
    disabled: !!disabled,
    readOnly: !!readOnly,
    invalid: !!invalid,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js
var [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext3({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var CheckboxGroup = (0, import_react330.forwardRef)((props25, ref2) => {
  const [checkboxGroupProps, localProps] = createSplitProps2()(props25, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "invalid",
    "readOnly",
    "name"
  ]);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return (0, import_jsx_runtime151.jsx)(CheckboxGroupContextProvider, { value: checkboxGroup, children: (0, import_jsx_runtime151.jsx)(ark.div, { ref: ref2, role: "group", ...localProps, ...checkboxAnatomy.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react332 = __toESM(require_react(), 1);
var CheckboxHiddenInput = (0, import_react332.forwardRef)(
  (props25, ref2) => {
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps2(checkbox.getHiddenInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime152.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-indicator.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react334 = __toESM(require_react(), 1);
var CheckboxIndicator = (0, import_react334.forwardRef)(
  (props25, ref2) => {
    const { indeterminate, ...rest } = props25;
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps2(checkbox.getIndicatorProps(), rest);
    const isVisible = indeterminate ? checkbox.indeterminate : checkbox.checked;
    return (0, import_jsx_runtime153.jsx)(ark.div, { ...mergedProps, hidden: !isVisible, ref: ref2 });
  }
);
CheckboxIndicator.displayName = "CheckboxIndicator";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react336 = __toESM(require_react(), 1);
var CheckboxLabel = (0, import_react336.forwardRef)((props25, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps2(checkbox.getLabelProps(), props25);
  return (0, import_jsx_runtime154.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
CheckboxLabel.displayName = "CheckboxLabel";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react340 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js
var import_react338 = __toESM(require_react(), 1);
var useCheckbox = (ownProps = {}) => {
  const checkboxGroup = useCheckboxGroupContext();
  const field = useFieldContext();
  const props25 = (0, import_react338.useMemo)(() => {
    return mergeProps2(ownProps, (checkboxGroup == null ? void 0 : checkboxGroup.getItemProps({ value: ownProps.value })) ?? {});
  }, [ownProps, checkboxGroup]);
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react338.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props25.defaultChecked,
    ...props25
  };
  const context = {
    ...initialContext,
    checked: props25.checked,
    onCheckedChange: useEvent(props25.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine16(initialContext), { context });
  return connect16(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var CheckboxRoot = (0, import_react340.forwardRef)((props25, ref2) => {
  const [useCheckboxProps, localProps] = createSplitProps2()(props25, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps2(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime155.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime155.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
CheckboxRoot.displayName = "CheckboxRoot";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react342 = __toESM(require_react(), 1);
var CheckboxRootProvider = (0, import_react342.forwardRef)(
  (props25, ref2) => {
    const [{ value: checkbox }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(checkbox.getRootProps(), localProps);
    return (0, import_jsx_runtime156.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime156.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
CheckboxRootProvider.displayName = "CheckboxRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Context: () => CheckboxContext,
  Control: () => CheckboxControl,
  Group: () => CheckboxGroup,
  HiddenInput: () => CheckboxHiddenInput,
  Indicator: () => CheckboxIndicator,
  Label: () => CheckboxLabel,
  Root: () => CheckboxRoot,
  RootProvider: () => CheckboxRootProvider
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-context.js
var CollapsibleContext = (props25) => props25.children(useCollapsibleContext());

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root-provider.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react344 = __toESM(require_react(), 1);
var CollapsibleRootProvider = (0, import_react344.forwardRef)(
  (props25, ref2) => {
    const [{ value: collapsible }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(collapsible.getRootProps(), localProps);
    return (0, import_jsx_runtime157.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime157.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-trigger.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react346 = __toESM(require_react(), 1);
var CollapsibleTrigger = (0, import_react346.forwardRef)(
  (props25, ref2) => {
    const collapsible = useCollapsibleContext();
    const mergedProps = mergeProps2(collapsible.getTriggerProps(), props25);
    return (0, import_jsx_runtime158.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleTrigger.displayName = "CollapsibleTrigger";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => CollapsibleContent,
  Context: () => CollapsibleContext,
  Root: () => CollapsibleRoot,
  RootProvider: () => CollapsibleRootProvider,
  Trigger: () => CollapsibleTrigger
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react348 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-area-props-context.js
var [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext3({
  name: "ColorPickerAreaContext",
  hookName: "useColorPickerAreaContext",
  providerName: "<ColorPickerAreaProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-context.js
var [ColorPickerProvider, useColorPickerContext] = createContext3({
  name: "ColorPickerContext",
  hookName: "useColorPickerContext",
  providerName: "<ColorPickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var ColorPickerArea = (0, import_react348.forwardRef)((props25, ref2) => {
  const [areaProps, localProps] = createSplitProps2()(props25, ["xChannel", "yChannel"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getAreaProps(areaProps), localProps);
  return (0, import_jsx_runtime159.jsx)(ColorPickerAreaPropsProvider, { value: areaProps, children: (0, import_jsx_runtime159.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ColorPickerArea.displayName = "ColorPickerArea";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-background.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react350 = __toESM(require_react(), 1);
var ColorPickerAreaBackground = (0, import_react350.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps2(colorPicker.getAreaBackgroundProps(areaProps), props25);
    return (0, import_jsx_runtime160.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaBackground.displayName = "ColorPickerAreaBackground";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-thumb.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react352 = __toESM(require_react(), 1);
var ColorPickerAreaThumb = (0, import_react352.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps2(colorPicker.getAreaThumbProps(areaProps), props25);
    return (0, import_jsx_runtime161.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaThumb.displayName = "ColorPickerAreaThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-input.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react354 = __toESM(require_react(), 1);
var ColorPickerChannelInput = (0, import_react354.forwardRef)(
  (props25, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props25, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getChannelInputProps(channelProps), localProps);
    return (0, import_jsx_runtime162.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerChannelInput.displayName = "ColorPickerChannelInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react356 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-channel-props-context.js
var [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext3({
  name: "ColorPickerChannelSliderContext",
  hookName: "useColorPickerChannelSliderContext",
  providerName: "<ColorPickerChannelSliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-format-context.js
var [ColorPickerFormatPropsProvider, useColorPickerFormatPropsContext] = createContext3({
  name: "ColorPickerFormatContext",
  hookName: "useColorPickerFormatPropsContext",
  providerName: "<ColorPickerFormatPropsProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var ColorPickerChannelSlider = (0, import_react356.forwardRef)(
  (props25, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props25, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const formatProps = useColorPickerFormatPropsContext();
    const channelSliderProps = { ...channelProps, ...formatProps };
    const mergedProps = mergeProps2(
      colorPicker.getChannelSliderProps(channelSliderProps),
      localProps
    );
    return (0, import_jsx_runtime163.jsx)(ColorPickerChannelPropsProvider, { value: channelProps, children: (0, import_jsx_runtime163.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerChannelSlider.displayName = "ColorPickerChannelSlider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-label.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var import_react358 = __toESM(require_react(), 1);
var ColorPickerChannelSliderLabel = (0, import_react358.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps2(colorPicker.getChannelSliderLabelProps(channelProps), props25);
  return (0, import_jsx_runtime164.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderLabel.displayName = "ColorPickerChannelSliderLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-thumb.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react360 = __toESM(require_react(), 1);
var ColorPickerChannelSliderThumb = (0, import_react360.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps, ...formatProps };
  const mergedProps = mergeProps2(colorPicker.getChannelSliderThumbProps(channelSliderProps), props25);
  return (0, import_jsx_runtime165.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderThumb.displayName = "ColorPickerChannelSliderThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-track.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react362 = __toESM(require_react(), 1);
var ColorPickerChannelSliderTrack = (0, import_react362.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps, ...formatProps };
  const mergedProps = mergeProps2(colorPicker.getChannelSliderTrackProps(channelSliderProps), props25);
  return (0, import_jsx_runtime166.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderTrack.displayName = "ColorPickerChannelSliderTrack";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-value-text.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react364 = __toESM(require_react(), 1);
var ColorPickerChannelSliderValueText = (0, import_react364.forwardRef)((props25, ref2) => {
  const { locale } = useLocaleContext();
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps2(colorPicker.getChannelSliderValueTextProps(channelProps), props25);
  return (0, import_jsx_runtime167.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props25.children || colorPicker.getChannelValueText(channelProps.channel, locale) });
});
ColorPickerChannelSliderValueText.displayName = "ColorPickerChannelSliderValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-content.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react366 = __toESM(require_react(), 1);
var ColorPickerContent = (0, import_react366.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps2(
      colorPicker.getContentProps(),
      presence.getPresenceProps(),
      props25
    );
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime168.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
  }
);
ColorPickerContent.displayName = "ColorPickerContent";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-context.js
var ColorPickerContext = (props25) => props25.children(useColorPickerContext());

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-control.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react368 = __toESM(require_react(), 1);
var ColorPickerControl = (0, import_react368.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getControlProps(), props25);
    return (0, import_jsx_runtime169.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerControl.displayName = "ColorPickerControl";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-eye-dropper-trigger.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react370 = __toESM(require_react(), 1);
var ColorPickerEyeDropperTrigger = (0, import_react370.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getEyeDropperTriggerProps(), props25);
  return (0, import_jsx_runtime170.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerEyeDropperTrigger.displayName = "ColorPickerEyeDropperTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-select.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react372 = __toESM(require_react(), 1);
var ColorPickerFormatSelect = (0, import_react372.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getFormatSelectProps(), props25);
    return (0, import_jsx_runtime171.jsx)(ark.select, { ...mergedProps, ref: ref2, children: ["rgba", "hsla", "hsba"].map((format) => (0, import_jsx_runtime171.jsx)(ark.option, { value: format, children: format }, format)) });
  }
);
ColorPickerFormatSelect.displayName = "ColorPickerFormatSelect";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-trigger.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react374 = __toESM(require_react(), 1);
var ColorPickerFormatTrigger = (0, import_react374.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getFormatTriggerProps(), props25);
  return (0, import_jsx_runtime172.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerFormatTrigger.displayName = "ColorPickerFormatTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-hidden-input.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react376 = __toESM(require_react(), 1);
var ColorPickerHiddenInput = (0, import_react376.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getHiddenInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime173.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
ColorPickerHiddenInput.displayName = "ColorPickerHiddenInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-label.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var import_react378 = __toESM(require_react(), 1);
var ColorPickerLabel = (0, import_react378.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getLabelProps(), props25);
    return (0, import_jsx_runtime174.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerLabel.displayName = "ColorPickerLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-positioner.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react380 = __toESM(require_react(), 1);
var ColorPickerPositioner = (0, import_react380.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getPositionerProps(), props25);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime175.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerPositioner.displayName = "ColorPickerPositioner";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react384 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker.js
var import_react382 = __toESM(require_react(), 1);
var useColorPicker = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react382.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props25.onValueChangeEnd)
  };
  const [state2, send] = useMachine(machine4(initialContext), { context });
  return connect4(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var ColorPickerRoot = (0, import_react384.forwardRef)((props25, ref2) => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props25);
  const [useColorPickerProps, localProps] = createSplitProps2()(
    colorPickerProps,
    [
      "closeOnSelect",
      "defaultOpen",
      "defaultValue",
      "disabled",
      "format",
      "id",
      "ids",
      "initialFocusEl",
      "invalid",
      "name",
      "name",
      "onFocusOutside",
      "onFormatChange",
      "onInteractOutside",
      "onOpenChange",
      "onPointerDownOutside",
      "onValueChange",
      "onValueChangeEnd",
      "open",
      "openAutoFocus",
      "positioning",
      "readOnly",
      "required",
      "value"
    ]
  );
  const colorPicker = useColorPicker(useColorPickerProps);
  const presence = usePresence(mergeProps2({ present: colorPicker.open }, presenceProps));
  const mergedProps = mergeProps2(colorPicker.getRootProps(), localProps);
  return (0, import_jsx_runtime176.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime176.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime176.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
ColorPickerRoot.displayName = "ColorPickerRoot";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root-provider.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react386 = __toESM(require_react(), 1);
var ColorPickerRootProvider = (0, import_react386.forwardRef)(
  (props25, ref2) => {
    const [presenceProps, colorPickerProps] = splitPresenceProps(props25);
    const [{ value: colorPicker }, localProps] = createSplitProps2()(
      colorPickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps2({ present: colorPicker.open }, presenceProps));
    const mergedProps = mergeProps2(colorPicker.getRootProps(), localProps);
    return (0, import_jsx_runtime177.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime177.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime177.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
ColorPickerRootProvider.displayName = "ColorPickerRootProvider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react388 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-swatch-props-context.js
var [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext3({
  name: "ColorPickerSwatchContext",
  hookName: "useColorPickerSwatchContext",
  providerName: "<ColorPickerSwatchProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var ColorPickerSwatch = (0, import_react388.forwardRef)(
  (props25, ref2) => {
    const [swatwchProps, localProps] = createSplitProps2()(props25, [
      "respectAlpha",
      "value"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getSwatchProps(swatwchProps), localProps);
    return (0, import_jsx_runtime178.jsx)(ColorPickerSwatchPropsProvider, { value: swatwchProps, children: (0, import_jsx_runtime178.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerSwatch.displayName = "ColorPickerSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-group.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react390 = __toESM(require_react(), 1);
var ColorPickerSwatchGroup = (0, import_react390.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getSwatchGroupProps(), props25);
    return (0, import_jsx_runtime179.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerSwatchGroup.displayName = "ColorPickerSwatchGroup";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-indicator.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react392 = __toESM(require_react(), 1);
var ColorPickerSwatchIndicator = (0, import_react392.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const swatchProps = useColorPickerSwatchPropsContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchIndicatorProps(swatchProps), props25);
  return (0, import_jsx_runtime180.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchIndicator.displayName = "ColorPickerSwatchIndicator";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-trigger.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react394 = __toESM(require_react(), 1);
var ColorPickerSwatchTrigger = (0, import_react394.forwardRef)((props25, ref2) => {
  const [triggerProps2, localProps] = createSplitProps2()(props25, [
    "value",
    "disabled"
  ]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getSwatchTriggerProps(triggerProps2), localProps);
  return (0, import_jsx_runtime181.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchTrigger.displayName = "ColorPickerSwatchTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-transparency-grid.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react396 = __toESM(require_react(), 1);
var ColorPickerTransparencyGrid = (0, import_react396.forwardRef)((props25, ref2) => {
  const [gridProps, localProps] = createSplitProps2()(props25, ["size"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps2(colorPicker.getTransparencyGridProps(gridProps), localProps);
  return (0, import_jsx_runtime182.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerTransparencyGrid.displayName = "ColorPickerTransparencyGrid";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-trigger.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_react398 = __toESM(require_react(), 1);
var ColorPickerTrigger = (0, import_react398.forwardRef)(
  (props25, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getTriggerProps(), props25);
    return (0, import_jsx_runtime183.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerTrigger.displayName = "ColorPickerTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-swatch.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react400 = __toESM(require_react(), 1);
var ColorPickerValueSwatch = (0, import_react400.forwardRef)(
  (props25, ref2) => {
    const [{ respectAlpha }, localProps] = createSplitProps2()(props25, [
      "respectAlpha"
    ]);
    const colorPicker = useColorPickerContext();
    const swatchProps = {
      respectAlpha,
      value: colorPicker.valueAsString
    };
    const mergedProps = mergeProps2(colorPicker.getSwatchProps(swatchProps), localProps);
    return (0, import_jsx_runtime184.jsx)(ColorPickerSwatchPropsProvider, { value: swatchProps, children: (0, import_jsx_runtime184.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerValueSwatch.displayName = "ColorPickerValueSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-text.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react402 = __toESM(require_react(), 1);
var ColorPickerValueText = (0, import_react402.forwardRef)(
  (props25, ref2) => {
    const { children, ...localprops } = props25;
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps2(colorPicker.getValueTextProps(), localprops);
    return (0, import_jsx_runtime185.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props25.children || colorPicker.valueAsString });
  }
);
ColorPickerValueText.displayName = "ColorPickerValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var import_react403 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js
var colorPickerAnatomy = anatomy3.extendWith("view");

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var ColorPickerView = (0, import_react403.forwardRef)((props25, ref2) => {
  const colorPicker = useColorPickerContext();
  const [formatProps, restProps] = createSplitProps2()(props25, ["format"]);
  if (colorPicker.format !== formatProps.format) {
    return null;
  }
  return (0, import_jsx_runtime186.jsx)(ColorPickerFormatPropsProvider, { value: formatProps, children: (0, import_jsx_runtime186.jsx)(
    ark.div,
    {
      ref: ref2,
      "data-format": props25.format,
      ...colorPickerAnatomy.build().view.attrs,
      ...restProps
    }
  ) });
});
ColorPickerView.displayName = "ColorPickerView";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.js
var color_picker_exports = {};
__export(color_picker_exports, {
  Area: () => ColorPickerArea,
  AreaBackground: () => ColorPickerAreaBackground,
  AreaThumb: () => ColorPickerAreaThumb,
  ChannelInput: () => ColorPickerChannelInput,
  ChannelSlider: () => ColorPickerChannelSlider,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText,
  Content: () => ColorPickerContent,
  Context: () => ColorPickerContext,
  Control: () => ColorPickerControl,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger,
  FormatSelect: () => ColorPickerFormatSelect,
  FormatTrigger: () => ColorPickerFormatTrigger,
  HiddenInput: () => ColorPickerHiddenInput,
  Label: () => ColorPickerLabel,
  Positioner: () => ColorPickerPositioner,
  Root: () => ColorPickerRoot,
  RootProvider: () => ColorPickerRootProvider,
  Swatch: () => ColorPickerSwatch,
  SwatchGroup: () => ColorPickerSwatchGroup,
  SwatchIndicator: () => ColorPickerSwatchIndicator,
  SwatchTrigger: () => ColorPickerSwatchTrigger,
  TransparencyGrid: () => ColorPickerTransparencyGrid,
  Trigger: () => ColorPickerTrigger,
  ValueSwatch: () => ColorPickerValueSwatch,
  ValueText: () => ColorPickerValueText,
  View: () => ColorPickerView
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_react405 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card-context.js
var [HoverCardProvider, useHoverCardContext] = createContext3({
  name: "HoverCardContext",
  hookName: "useHoverCardContext",
  providerName: "<HoverCardProvider />"
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var HoverCardArrow = (0, import_react405.forwardRef)((props25, ref2) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps2(hoverCard.getArrowProps(), props25);
  return (0, import_jsx_runtime187.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
HoverCardArrow.displayName = "HoverCardArrow";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow-tip.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react407 = __toESM(require_react(), 1);
var HoverCardArrowTip = (0, import_react407.forwardRef)(
  (props25, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps2(hoverCard.getArrowTipProps(), props25);
    return (0, import_jsx_runtime188.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardArrowTip.displayName = "HoverCardArrowTip";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-content.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react409 = __toESM(require_react(), 1);
var HoverCardContent = (0, import_react409.forwardRef)((props25, ref2) => {
  const hoverCard = useHoverCardContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(hoverCard.getContentProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime189.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
HoverCardContent.displayName = "HoverCardContent";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-context.js
var HoverCardContext = (props25) => props25.children(useHoverCardContext());

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-positioner.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react411 = __toESM(require_react(), 1);
var HoverCardPositioner = (0, import_react411.forwardRef)(
  (props25, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps2(hoverCard.getPositionerProps(), props25);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime190.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardPositioner.displayName = "HoverCardPositioner";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy17 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts19 = anatomy17.build();
var dom17 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom17.getById(ctx, dom17.getTriggerId(ctx)),
  getContentEl: (ctx) => dom17.getById(ctx, dom17.getContentId(ctx)),
  getPositionerEl: (ctx) => dom17.getById(ctx, dom17.getPositionerId(ctx))
});
function connect17(state2, send, normalize2) {
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom17.getArrowId(state2.context),
        ...parts19.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts19.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts19.trigger.attrs,
        dir: state2.context.dir,
        "data-placement": state2.context.currentPlacement,
        id: dom17.getTriggerId(state2.context),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onBlur() {
          send("TRIGGER_BLUR");
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom17.getPositionerId(state2.context),
        ...parts19.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts19.content.attrs,
        dir: state2.context.dir,
        id: dom17.getContentId(state2.context),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not: not8, and: and7 } = guards;
function machine17(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and7("isOpenControlled", not8("isPointer")),
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                guard: not8("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and7("isOpenControlled", not8("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not8("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      },
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom17.getPositionerEl(ctx2);
          return getPlacement(dom17.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom17.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom17.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom17.getPositionerEl(ctx2);
          getPlacement(dom17.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        }
      }
    }
  );
}
var props17 = createProps()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps18 = createSplitProps(props17);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card.js
var import_react413 = __toESM(require_react(), 1);
var useHoverCard = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react413.useId)(),
    dir,
    getRootNode,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    ...props25
  };
  const context = {
    ...initialContext,
    open: props25.open,
    onOpenChange: useEvent(props25.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine17(initialContext), { context });
  return connect17(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var HoverCardRoot = (props25) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props25);
  const hoverCard = useHoverCard(localProps);
  const presence = usePresence(mergeProps2({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime191.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime191.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root-provider.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var HoverCardRootProvider = (props25) => {
  const [presenceProps, { value: hoverCard, children }] = splitPresenceProps(props25);
  const presence = usePresence(mergeProps2({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime192.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime192.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-trigger.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_react417 = __toESM(require_react(), 1);
var HoverCardTrigger = (0, import_react417.forwardRef)(
  (props25, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps2(hoverCard.getTriggerProps(), props25);
    return (0, import_jsx_runtime193.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
HoverCardTrigger.displayName = "HoverCardTrigger";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card.js
var hover_card_exports = {};
__export(hover_card_exports, {
  Arrow: () => HoverCardArrow,
  ArrowTip: () => HoverCardArrowTip,
  Content: () => HoverCardContent,
  Context: () => HoverCardContext,
  Positioner: () => HoverCardPositioner,
  Root: () => HoverCardRoot,
  RootProvider: () => HoverCardRootProvider,
  Trigger: () => HoverCardTrigger
});

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input-context.js
var [NumberInputProvider, useNumberInputContext] = createContext3({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/number-input/number-input-context.js
var NumberInputContext = (props25) => props25.children(useNumberInputContext());

// node_modules/@ark-ui/react/dist/components/number-input/number-input-control.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_react419 = __toESM(require_react(), 1);
var NumberInputControl = (0, import_react419.forwardRef)(
  (props25, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getControlProps(), props25);
    return (0, import_jsx_runtime194.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputControl.displayName = "NumberInputControl";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-decrement-trigger.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react421 = __toESM(require_react(), 1);
var NumberInputDecrementTrigger = (0, import_react421.forwardRef)((props25, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getDecrementTriggerProps(), props25);
  return (0, import_jsx_runtime195.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputDecrementTrigger.displayName = "NumberInputDecrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-increment-trigger.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react423 = __toESM(require_react(), 1);
var NumberInputIncrementTrigger = (0, import_react423.forwardRef)((props25, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps2(numberInput.getIncrementTriggerProps(), props25);
  return (0, import_jsx_runtime196.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputIncrementTrigger.displayName = "NumberInputIncrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-input.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react425 = __toESM(require_react(), 1);
var NumberInputInput = (0, import_react425.forwardRef)(
  (props25, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime197.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
NumberInputInput.displayName = "NumberInputInput";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-label.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react427 = __toESM(require_react(), 1);
var NumberInputLabel = (0, import_react427.forwardRef)(
  (props25, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getLabelProps(), props25);
    return (0, import_jsx_runtime198.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
NumberInputLabel.displayName = "NumberInputLabel";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
var import_react431 = __toESM(require_react(), 1);

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b) => b.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace2) {
  if (str.replaceAll) return str.replaceAll(find, replace2);
  return str.split(find).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@zag-js/number-input/dist/index.mjs
var anatomy18 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts20 = anatomy18.build();
var dom18 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom18.getById(ctx, dom18.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom18.getById(ctx, dom18.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom18.getById(ctx, dom18.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom18.getById(ctx, dom18.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom18.getDoc(ctx).getElementById(dom18.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom18.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom18.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari()) return;
    dom18.createVirtualCursor(ctx);
    return () => {
      var _a8;
      (_a8 = dom18.getCursorEl(ctx)) == null ? void 0 : _a8.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom18.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousemoveValue(ctx, event) {
    const win = dom18.getWin(ctx);
    const x = roundToDpr(event.movementX, win.devicePixelRatio);
    const y = roundToDpr(event.movementY, win.devicePixelRatio);
    let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x,
      y: ctx.scrubberCursorPoint.y + y
    };
    const width = win.innerWidth;
    const half = roundToDpr(7.5, win.devicePixelRatio);
    point.x = wrap2(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom18.getDoc(ctx);
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = dom18.getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el);
  }
});
function connect18(state2, send, normalize2) {
  const focused = state2.hasTag("focus");
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const empty2 = state2.context.isValueEmpty;
  const invalid = state2.context.isOutOfRange || !!state2.context.invalid;
  const isIncrementDisabled = disabled || !state2.context.canIncrement || readOnly;
  const isDecrementDisabled = disabled || !state2.context.canDecrement || readOnly;
  const translations = state2.context.translations;
  return {
    focused,
    invalid,
    empty: empty2,
    value: state2.context.formattedValue,
    valueAsNumber: state2.context.valueAsNumber,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    increment() {
      send("VALUE.INCREMENT");
    },
    decrement() {
      send("VALUE.DECREMENT");
    },
    setToMax() {
      send({ type: "VALUE.SET", value: state2.context.max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: state2.context.min });
    },
    focus() {
      var _a8;
      (_a8 = dom18.getInputEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize2.element({
        id: dom18.getRootId(state2.context),
        ...parts20.root.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts20.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: dom18.getLabelId(state2.context),
        htmlFor: dom18.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts20.control.attrs,
        dir: state2.context.dir,
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(state2.context.invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts20.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts20.input.attrs,
        dir: state2.context.dir,
        name: state2.context.name,
        form: state2.context.form,
        id: dom18.getInputId(state2.context),
        role: "spinbutton",
        defaultValue: state2.context.formattedValue,
        pattern: state2.context.pattern,
        inputMode: state2.context.inputMode,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": state2.context.min,
        "aria-valuemax": state2.context.max,
        "aria-valuenow": Number.isNaN(state2.context.valueAsNumber) ? void 0 : state2.context.valueAsNumber,
        "aria-valuetext": state2.context.valueText,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur() {
          send("INPUT.BLUR");
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = state2.context.parser.isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send("INPUT.HOME");
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send("INPUT.END");
              event.preventDefault();
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[event.key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize2.button({
        ...parts20.decrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom18.getDecrementTriggerId(state2.context),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom18.getInputId(state2.context),
        onPointerDown(event) {
          var _a8;
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize2.button({
        ...parts20.incrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom18.getIncrementTriggerId(state2.context),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom18.getInputId(state2.context),
        onPointerDown(event) {
          var _a8;
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize2.element({
        ...parts20.scrubber.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        id: dom18.getScrubberId(state2.context),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return ref(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {}) => {
  return ref(new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options));
};
var parseValue = (ctx, value) => {
  if (!ctx.formatOptions) return parseFloat(value);
  return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value) => {
  if (Number.isNaN(value)) return "";
  if (!ctx.formatOptions) return value.toString();
  return ctx.formatter.format(value);
};
var { not: not9, and: and8 } = guards;
function machine18(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "number-input",
      initial: "idle",
      context: {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: true,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "[0-9]*(.[0-9]+)?",
        value: "",
        step: 1,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        invalid: false,
        spinOnPress: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        hint: null,
        scrubberCursorPoint: null,
        fieldsetDisabled: false,
        formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
        parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...ctx.translations
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        valueAsNumber: (ctx2) => parseValue(ctx2, ctx2.value),
        formattedValue: (ctx2) => formatValue(ctx2, ctx2.valueAsNumber),
        isAtMin: (ctx2) => isValueAtMin(ctx2.valueAsNumber, ctx2.min),
        isAtMax: (ctx2) => isValueAtMax(ctx2.valueAsNumber, ctx2.max),
        isOutOfRange: (ctx2) => !isValueWithinRange(ctx2.valueAsNumber, ctx2.min, ctx2.max),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        canIncrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMax,
        canDecrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMin,
        valueText: (ctx2) => {
          var _a8, _b7;
          return (_b7 = (_a8 = ctx2.translations).valueText) == null ? void 0 : _b7.call(_a8, ctx2.value);
        }
      },
      watch: {
        formatOptions: ["setFormatterAndParser", "syncInputElement"],
        locale: ["setFormatterAndParser", "syncInputElement"],
        value: ["syncInputElement"],
        isOutOfRange: ["invokeOnInvalid"],
        scrubberCursorPoint: ["setVirtualCursorPosition"]
      },
      activities: ["trackFormControl"],
      on: {
        "VALUE.SET": {
          actions: ["setRawValue", "setHintToSet"]
        },
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.INCREMENT": {
          actions: ["increment"]
        },
        "VALUE.DECREMENT": {
          actions: ["decrement"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              {
                target: "before:spin",
                actions: ["focusInput", "invokeOnFocus", "setHint"]
              }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
            },
            "INPUT.FOCUS": {
              target: "focused",
              actions: ["focusInput", "invokeOnFocus"]
            }
          }
        },
        focused: {
          tags: "focus",
          activities: "attachWheelListener",
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              { target: "before:spin", actions: ["focusInput", "setHint"] }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "setHint", "setCursorPoint"]
            },
            "INPUT.ARROW_UP": {
              actions: "increment"
            },
            "INPUT.ARROW_DOWN": {
              actions: "decrement"
            },
            "INPUT.HOME": {
              actions: "decrementToMin"
            },
            "INPUT.END": {
              actions: "incrementToMax"
            },
            "INPUT.CHANGE": {
              actions: ["setValue", "setHint"]
            },
            "INPUT.BLUR": [
              {
                guard: and8("clampValueOnBlur", not9("isInRange")),
                target: "idle",
                actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
              },
              {
                target: "idle",
                actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
            }
          }
        },
        "before:spin": {
          tags: "focus",
          activities: "trackButtonDisabled",
          entry: choose([
            { guard: "isIncrementHint", actions: "increment" },
            { guard: "isDecrementHint", actions: "decrement" }
          ]),
          after: {
            CHANGE_DELAY: {
              target: "spinning",
              guard: and8("isInRange", "spinOnPress")
            }
          },
          on: {
            "TRIGGER.PRESS_UP": [
              { guard: "isTouchPointer", target: "focused", actions: "clearHint" },
              { target: "focused", actions: ["focusInput", "clearHint"] }
            ]
          }
        },
        spinning: {
          tags: "focus",
          activities: "trackButtonDisabled",
          every: [
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not9("isAtMin"), "isIncrementHint"),
              actions: "increment"
            },
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not9("isAtMax"), "isDecrementHint"),
              actions: "decrement"
            }
          ],
          on: {
            "TRIGGER.PRESS_UP": {
              target: "focused",
              actions: ["focusInput", "clearHint"]
            }
          }
        },
        scrubbing: {
          tags: "focus",
          activities: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
          on: {
            "SCRUBBER.POINTER_UP": {
              target: "focused",
              actions: ["focusInput", "clearCursorPoint"]
            },
            "SCRUBBER.POINTER_MOVE": [
              {
                guard: "isIncrementHint",
                actions: ["increment", "setCursorPoint"]
              },
              {
                guard: "isDecrementHint",
                actions: ["decrement", "setCursorPoint"]
              }
            ]
          }
        }
      }
    },
    {
      delays: {
        CHANGE_INTERVAL: 50,
        CHANGE_DELAY: 300
      },
      guards: {
        clampValueOnBlur: (ctx2) => ctx2.clampValueOnBlur,
        isAtMin: (ctx2) => ctx2.isAtMin,
        spinOnPress: (ctx2) => !!ctx2.spinOnPress,
        isAtMax: (ctx2) => ctx2.isAtMax,
        isInRange: (ctx2) => !ctx2.isOutOfRange,
        isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "decrement",
        isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "increment",
        isTouchPointer: (_ctx, evt) => evt.pointerType === "touch"
      },
      activities: {
        trackFormControl(ctx2, _evt, { initialContext }) {
          const inputEl = dom18.getInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set14.value(ctx2, initialContext.value);
            }
          });
        },
        setupVirtualCursor(ctx2) {
          return dom18.setupVirtualCursor(ctx2);
        },
        preventTextSelection(ctx2) {
          return dom18.preventTextSelection(ctx2);
        },
        trackButtonDisabled(ctx2, _evt, { send }) {
          const btn = dom18.getPressedTriggerEl(ctx2, ctx2.hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener(ctx2, _evt, { send }) {
          const inputEl = dom18.getInputEl(ctx2);
          if (!inputEl || !dom18.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send("VALUE.INCREMENT");
            } else if (dir === -1) {
              send("VALUE.DECREMENT");
            }
          }
          return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock(ctx2) {
          if (isSafari()) return;
          return requestPointerLock(dom18.getDoc(ctx2));
        },
        trackMousemove(ctx2, _evt, { send }) {
          const doc = dom18.getDoc(ctx2);
          function onMousemove(event) {
            if (!ctx2.scrubberCursorPoint) return;
            const value = dom18.getMousemoveValue(ctx2, event);
            if (!value.hint) return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send("SCRUBBER.POINTER_UP");
          }
          return callAll2(
            addDomEvent(doc, "mousemove", onMousemove, false),
            addDomEvent(doc, "mouseup", onMouseup, false)
          );
        }
      },
      actions: {
        focusInput(ctx2) {
          if (!ctx2.focusInputOnChange) return;
          const inputEl = dom18.getInputEl(ctx2);
          if (dom18.isActiveElement(ctx2, inputEl)) return;
          raf(() => inputEl == null ? void 0 : inputEl.focus({ preventScroll: true }));
        },
        increment(ctx2, evt) {
          const nextValue = incrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set14.value(ctx2, value);
        },
        decrement(ctx2, evt) {
          const nextValue = decrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set14.value(ctx2, value);
        },
        setClampedValue(ctx2) {
          const nextValue = clampValue(ctx2.valueAsNumber, ctx2.min, ctx2.max);
          set14.value(ctx2, formatValue(ctx2, nextValue));
        },
        setRawValue(ctx2, evt) {
          const parsedValue = parseValue(ctx2, evt.value);
          const value = formatValue(ctx2, clampValue(parsedValue, ctx2.min, ctx2.max));
          set14.value(ctx2, value);
        },
        setValue(ctx2, evt) {
          var _a8;
          const value = ((_a8 = evt.target) == null ? void 0 : _a8.value) ?? evt.value;
          set14.value(ctx2, value);
        },
        clearValue(ctx2) {
          set14.value(ctx2, "");
        },
        incrementToMax(ctx2) {
          const value = formatValue(ctx2, ctx2.max);
          set14.value(ctx2, value);
        },
        decrementToMin(ctx2) {
          const value = formatValue(ctx2, ctx2.min);
          set14.value(ctx2, value);
        },
        setHint(ctx2, evt) {
          ctx2.hint = evt.hint;
        },
        clearHint(ctx2) {
          ctx2.hint = null;
        },
        setHintToSet(ctx2) {
          ctx2.hint = "set";
        },
        invokeOnFocus(ctx2) {
          var _a8;
          (_a8 = ctx2.onFocusChange) == null ? void 0 : _a8.call(ctx2, {
            focused: true,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnBlur(ctx2) {
          var _a8;
          (_a8 = ctx2.onFocusChange) == null ? void 0 : _a8.call(ctx2, {
            focused: false,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnInvalid(ctx2) {
          var _a8;
          if (!ctx2.isOutOfRange) return;
          const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
          (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, {
            reason,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        syncInputElement(ctx2, evt) {
          const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
          sync4.input(ctx2, value);
        },
        setFormattedValue(ctx2) {
          set14.value(ctx2, ctx2.formattedValue);
        },
        setCursorPoint(ctx2, evt) {
          ctx2.scrubberCursorPoint = evt.point;
        },
        clearCursorPoint(ctx2) {
          ctx2.scrubberCursorPoint = null;
        },
        setVirtualCursorPosition(ctx2) {
          const cursorEl = dom18.getCursorEl(ctx2);
          if (!cursorEl || !ctx2.scrubberCursorPoint) return;
          const { x, y } = ctx2.scrubberCursorPoint;
          cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
        },
        setFormatterAndParser(ctx2) {
          if (!ctx2.locale) return;
          ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
          ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
        }
      },
      compareFns: {
        formatOptions: (a, b) => isEqual(a, b),
        scrubberCursorPoint: (a, b) => isEqual(a, b)
      }
    }
  );
}
var sync4 = {
  input(ctx, value) {
    const inputEl = dom18.getInputEl(ctx);
    if (!inputEl) return;
    const sel = recordCursor(inputEl);
    raf(() => {
      setElementValue(inputEl, value);
      restoreCursor(inputEl, sel);
    });
  }
};
var invoke11 = {
  onChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: ctx.value,
      valueAsNumber: ctx.valueAsNumber
    });
  }
};
var set14 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke11.onChange(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input.js
var import_react429 = __toESM(require_react(), 1);
var useNumberInput = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react429.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    locale,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props25.onValueInvalid),
    onFocusChange: useEvent(props25.onFocusChange)
  };
  const [state2, send] = useMachine(machine18(initialContext), { context });
  return connect18(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var NumberInputRoot = (0, import_react431.forwardRef)((props25, ref2) => {
  const [useNumberInputProps, localProps] = createSplitProps2()(props25, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps2(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime199.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime199.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
NumberInputRoot.displayName = "NumberInputRoot";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root-provider.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var import_react433 = __toESM(require_react(), 1);
var NumberInputRootProvider = (0, import_react433.forwardRef)(
  (props25, ref2) => {
    const [{ value: numberInput }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(numberInput.getRootProps(), localProps);
    return (0, import_jsx_runtime200.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime200.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
NumberInputRootProvider.displayName = "NumberInputRootProvider";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-scrubber.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var import_react435 = __toESM(require_react(), 1);
var NumberInputScrubber = (0, import_react435.forwardRef)(
  (props25, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getScrubberProps(), props25);
    return (0, import_jsx_runtime201.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputScrubber.displayName = "NumberInputScrubber";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-value-text.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react437 = __toESM(require_react(), 1);
var NumberInputValueText = (0, import_react437.forwardRef)(
  (props25, ref2) => {
    const { children, ...localProps } = props25;
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps2(numberInput.getValueTextProps(), localProps);
    return (0, import_jsx_runtime202.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || numberInput.value });
  }
);
NumberInputValueText.displayName = "NumberInputValueText";

// node_modules/@ark-ui/react/dist/components/number-input/number-input.js
var number_input_exports = {};
__export(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  RootProvider: () => NumberInputRootProvider,
  Scrubber: () => NumberInputScrubber,
  ValueText: () => NumberInputValueText
});

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input-context.js
var [PinInputProvider, usePinInputContext] = createContext3({
  name: "PinInputContext",
  hookName: "usePinInputContext",
  providerName: "<PinInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-context.js
var PinInputContext = (props25) => props25.children(usePinInputContext());

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-control.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_react439 = __toESM(require_react(), 1);
var PinInputControl = (0, import_react439.forwardRef)((props25, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getControlProps(), props25);
  return (0, import_jsx_runtime203.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PinInputControl.displayName = "PinInputControl";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-hidden-input.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react441 = __toESM(require_react(), 1);
var PinInputHiddenInput = (0, import_react441.forwardRef)(
  (props25, ref2) => {
    const pinInput = usePinInputContext();
    const mergedProps = mergeProps2(pinInput.getHiddenInputProps(), props25);
    const field = useFieldContext();
    return (0, import_jsx_runtime204.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
PinInputHiddenInput.displayName = "PinInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-input.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var import_react443 = __toESM(require_react(), 1);
var PinInputInput = (0, import_react443.forwardRef)((props25, ref2) => {
  const [inputProps2, localProps] = createSplitProps2()(props25, ["index"]);
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime205.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
PinInputInput.displayName = "PinInputInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-label.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react445 = __toESM(require_react(), 1);
var PinInputLabel = (0, import_react445.forwardRef)((props25, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps2(pinInput.getLabelProps(), props25);
  return (0, import_jsx_runtime206.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
PinInputLabel.displayName = "PinInputLabel";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react449 = __toESM(require_react(), 1);

// node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy19 = createAnatomy("pinInput").parts("root", "label", "input", "control");
var parts21 = anatomy19.build();
var dom19 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom19.getById(ctx, dom19.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom19.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom19.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id) => dom19.getById(ctx, dom19.getInputId(ctx, id)),
  getFocusedInputEl: (ctx) => dom19.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom19.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom19.getById(ctx, dom19.getHiddenInputId(ctx))
});
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(ctx, value) {
  var _a8;
  if (!ctx.type) return true;
  return !!((_a8 = REGEX[ctx.type]) == null ? void 0 : _a8.test(value));
}
function isValidValue(ctx, value) {
  if (!ctx.pattern) return isValidType(ctx, value);
  const regex = new RegExp(ctx.pattern, "g");
  return regex.test(value);
}
function connect19(state2, send, normalize2) {
  const complete = state2.context.isValueComplete;
  const invalid = state2.context.invalid;
  const focusedIndex = state2.context.focusedIndex;
  const translations = state2.context.translations;
  function focus() {
    var _a8;
    (_a8 = dom19.getFirstInputEl(state2.context)) == null ? void 0 : _a8.focus();
  }
  return {
    focus,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts21.root.attrs,
        id: dom19.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts21.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom19.getHiddenInputId(state2.context),
        id: dom19.getLabelId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: dom19.getHiddenInputId(state2.context),
        readOnly: state2.context.readOnly,
        disabled: state2.context.disabled,
        required: state2.context.required,
        name: state2.context.name,
        form: state2.context.form,
        style: visuallyHiddenStyle,
        maxLength: state2.context.valueLength,
        defaultValue: state2.context.valueAsString
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts21.control.attrs,
        dir: state2.context.dir,
        id: dom19.getControlId(state2.context)
      });
    },
    getInputProps(props25) {
      const { index } = props25;
      const inputType = state2.context.type === "numeric" ? "tel" : "text";
      return normalize2.input({
        ...parts21.input.attrs,
        dir: state2.context.dir,
        disabled: state2.context.disabled,
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        id: dom19.getInputId(state2.context, index.toString()),
        "data-ownedby": dom19.getRootId(state2.context),
        "aria-label": translations.inputLabel(index, state2.context.valueLength),
        inputMode: state2.context.otp || state2.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        type: state2.context.mask ? "password" : inputType,
        defaultValue: state2.context.value[index] || "",
        readOnly: state2.context.readOnly,
        autoCapitalize: "none",
        autoComplete: state2.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state2.context.placeholder,
        onBeforeInput(event) {
          try {
            const value = getBeforeInputValue(event);
            const isValid = isValidValue(state2.context, value);
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = getNativeEvent(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.currentTarget.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send("INPUT.BACKSPACE");
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          if (isModifierKey(event)) return;
          const keyMap2 = {
            Backspace() {
              send("INPUT.BACKSPACE");
            },
            Delete() {
              send("INPUT.DELETE");
            },
            ArrowLeft() {
              send("INPUT.ARROW_LEFT");
            },
            ArrowRight() {
              send("INPUT.ARROW_RIGHT");
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur() {
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
function machine19(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "pin-input",
      initial: "idle",
      context: {
        value: [],
        placeholder: "○",
        otp: false,
        type: "numeric",
        ...ctx,
        focusedIndex: -1,
        translations: {
          inputLabel: (index, length2) => `pin code ${index + 1} of ${length2}`,
          ...ctx.translations
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join(""),
        focusedValue: (ctx2) => ctx2.value[ctx2.focusedIndex] || ""
      },
      entry: choose([
        {
          guard: "autoFocus",
          actions: ["setupValue", "setFocusIndexToFirst"]
        },
        { actions: ["setupValue"] }
      ]),
      watch: {
        focusedIndex: ["focusInput", "selectInputIfNeeded"],
        value: ["syncInputElements"],
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      on: {
        "VALUE.SET": [
          {
            guard: "hasIndex",
            actions: ["setValueAtIndex"]
          },
          { actions: ["setValue"] }
        ],
        "VALUE.CLEAR": {
          actions: ["clearValue", "setFocusIndexToFirst"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.FOCUS": {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            "INPUT.CHANGE": [
              {
                guard: "isFinalValue",
                actions: ["setFocusedValue", "syncInputValue"]
              },
              {
                actions: ["setFocusedValue", "setNextFocusedIndex", "syncInputValue"]
              }
            ],
            "INPUT.PASTE": {
              actions: ["setPastedValue", "setLastValueFocusIndex"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            "INPUT.DELETE": {
              guard: "hasValue",
              actions: "clearFocusedValue"
            },
            "INPUT.ARROW_LEFT": {
              actions: "setPrevFocusedIndex"
            },
            "INPUT.ARROW_RIGHT": {
              actions: "setNextFocusedIndex"
            },
            "INPUT.BACKSPACE": [
              {
                guard: "hasValue",
                actions: ["clearFocusedValue"]
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue"]
              }
            ],
            "INPUT.ENTER": {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            "VALUE.INVALID": {
              actions: "invokeOnInvalid"
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isFinalValue: (ctx2) => ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue(ctx2) {
          if (ctx2.value.length) return;
          const inputEls = dom19.getInputEls(ctx2);
          const emptyValues = Array.from({ length: inputEls.length }).fill("");
          assignValue(ctx2, emptyValues);
        },
        focusInput(ctx2) {
          var _a8;
          if (ctx2.focusedIndex === -1) return;
          (_a8 = dom19.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        selectInputIfNeeded(ctx2) {
          if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1) return;
          raf(() => {
            var _a8;
            (_a8 = dom19.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.select();
          });
        },
        invokeOnComplete(ctx2) {
          var _a8;
          if (!ctx2.isValueComplete) return;
          (_a8 = ctx2.onValueComplete) == null ? void 0 : _a8.call(ctx2, {
            value: Array.from(ctx2.value),
            valueAsString: ctx2.valueAsString
          });
        },
        invokeOnInvalid(ctx2, evt) {
          var _a8;
          (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, {
            value: evt.value,
            index: ctx2.focusedIndex
          });
        },
        clearFocusedIndex(ctx2) {
          ctx2.focusedIndex = -1;
        },
        setFocusedIndex(ctx2, evt) {
          ctx2.focusedIndex = evt.index;
        },
        setValue(ctx2, evt) {
          set15.value(ctx2, evt.value);
        },
        setFocusedValue(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set15.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);
        },
        revertInputValue(ctx2) {
          const inputEl = dom19.getFocusedInputEl(ctx2);
          dom19.setValue(inputEl, ctx2.focusedValue);
        },
        syncInputValue(ctx2, evt) {
          const inputEl = dom19.getInputEl(ctx2, evt.index.toString());
          dom19.setValue(inputEl, ctx2.value[evt.index]);
        },
        syncInputElements(ctx2) {
          const inputEls = dom19.getInputEls(ctx2);
          inputEls.forEach((inputEl, index) => {
            dom19.setValue(inputEl, ctx2.value[index]);
          });
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);
            const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : "";
            const right = evt.value.substring(0, ctx2.valueLength - startIndex);
            const value = left + right;
            set15.value(ctx2, value.split(""));
          });
        },
        setValueAtIndex(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set15.valueAtIndex(ctx2, evt.index, nextValue);
        },
        clearValue(ctx2) {
          const nextValue = Array.from({ length: ctx2.valueLength }).fill("");
          set15.value(ctx2, nextValue);
        },
        clearFocusedValue(ctx2) {
          set15.valueAtIndex(ctx2, ctx2.focusedIndex, "");
        },
        setFocusIndexToFirst(ctx2) {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex(ctx2) {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete) return;
          raf(() => {
            var _a8;
            (_a8 = dom19.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.blur();
          });
        },
        requestFormSubmit(ctx2) {
          var _a8;
          if (!ctx2.name || !ctx2.isValueComplete) return;
          const inputEl = dom19.getHiddenInputEl(ctx2);
          (_a8 = inputEl == null ? void 0 : inputEl.form) == null ? void 0 : _a8.requestSubmit();
        }
      }
    }
  );
}
function assignValue(ctx, value) {
  const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
  arr.forEach((value2, index) => {
    ctx.value[index] = value2;
  });
}
function getNextValue(current, next2) {
  let nextValue = next2;
  if (current[0] === next2[0]) nextValue = next2[1];
  else if (current[0] === next2[1]) nextValue = next2[0];
  return nextValue.split("")[nextValue.length - 1];
}
var invoke12 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: ctx.valueAsString
    });
    const inputEl = dom19.getHiddenInputEl(ctx);
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
};
var set15 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    assignValue(ctx, value);
    invoke12.change(ctx);
  },
  valueAtIndex(ctx, index, value) {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke12.change(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input.js
var import_react447 = __toESM(require_react(), 1);
var usePinInput = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react447.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onValueComplete: useEvent(props25.onValueComplete),
    onValueInvalid: useEvent(props25.onValueInvalid)
  };
  const [state2, send] = useMachine(machine19(initialContext), { context });
  return connect19(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var PinInputRoot = (0, import_react449.forwardRef)((props25, ref2) => {
  const [usePinInputProps, localProps] = createSplitProps2()(props25, [
    "autoFocus",
    "blurOnComplete",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps2(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime207.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime207.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
PinInputRoot.displayName = "PinInputRoot";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root-provider.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react451 = __toESM(require_react(), 1);
var PinInputRootProvider = (0, import_react451.forwardRef)(
  (props25, ref2) => {
    const [{ value: pinInput }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(pinInput.getRootProps(), localProps);
    return (0, import_jsx_runtime208.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime208.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
PinInputRootProvider.displayName = "PinInputRootProvider";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input.js
var pin_input_exports = {};
__export(pin_input_exports, {
  Context: () => PinInputContext,
  Control: () => PinInputControl,
  HiddenInput: () => PinInputHiddenInput,
  Input: () => PinInputInput,
  Label: () => PinInputLabel,
  Root: () => PinInputRoot,
  RootProvider: () => PinInputRootProvider
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_react453 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress-context.js
var [ProgressProvider, useProgressContext] = createContext3({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var ProgressCircle = (0, import_react453.forwardRef)((props25, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getCircleProps(), props25);
  return (0, import_jsx_runtime209.jsx)(ark.svg, { ref: ref2, ...mergedProps });
});
ProgressCircle.displayName = "ProgressCircle";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-range.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_react455 = __toESM(require_react(), 1);
var ProgressCircleRange = (0, import_react455.forwardRef)(
  (props25, ref2) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps2(progress.getCircleRangeProps(), props25);
    return (0, import_jsx_runtime210.jsx)(ark.circle, { ref: ref2, ...mergedProps });
  }
);
ProgressCircleRange.displayName = "ProgressCircleRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-track.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var import_react457 = __toESM(require_react(), 1);
var ProgressCircleTrack = (0, import_react457.forwardRef)(
  (props25, ref2) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps2(progress.getCircleTrackProps(), props25);
    return (0, import_jsx_runtime211.jsx)(ark.circle, { ref: ref2, ...mergedProps });
  }
);
ProgressCircleTrack.displayName = "ProgressCircleTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-context.js
var ProgressContext = (props25) => props25.children(useProgressContext());

// node_modules/@ark-ui/react/dist/components/progress/progress-label.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react459 = __toESM(require_react(), 1);
var ProgressLabel = (0, import_react459.forwardRef)((props25, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getLabelProps(), props25);
  return (0, import_jsx_runtime212.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ProgressLabel.displayName = "ProgressLabel";

// node_modules/@ark-ui/react/dist/components/progress/progress-range.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react461 = __toESM(require_react(), 1);
var ProgressRange = (0, import_react461.forwardRef)((props25, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getRangeProps(), props25);
  return (0, import_jsx_runtime213.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressRange.displayName = "ProgressRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react465 = __toESM(require_react(), 1);

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy20 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts22 = anatomy20.build();
var dom20 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.circle) ?? `progress-${ctx.id}-circle`;
  }
});
function connect20(state2, send, normalize2) {
  const percent = state2.context.percent;
  const percentAsString = state2.context.isIndeterminate ? "" : `${percent}%`;
  const max4 = state2.context.max;
  const min4 = state2.context.min;
  const orientation = state2.context.orientation;
  const translations = state2.context.translations;
  const indeterminate = state2.context.isIndeterminate;
  const value = state2.context.value;
  const valueAsString = translations.value({ value, max: max4, percent, min: min4 });
  const progressState = getProgressState(value, max4);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max4,
    "aria-valuemin": min4,
    "aria-valuemax": max4,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state2.context);
  return {
    value,
    valueAsString,
    min: min4,
    max: max4,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max4 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min4 });
    },
    getRootProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.root.attrs,
        id: dom20.getRootId(state2.context),
        "data-max": max4,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom20.getLabelId(state2.context),
        ...parts22.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize2.element({
        dir: state2.context.dir,
        "aria-live": "polite",
        ...parts22.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom20.getTrackId(state2.context),
        ...parts22.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [state2.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom20.getCircleId(state2.context),
        ...parts22.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize2.element({
        dir: state2.context.dir,
        "data-orientation": orientation,
        ...parts22.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props25) {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.view.attrs,
        "data-state": props25.state,
        hidden: props25.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: ctx.value === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": ctx.percent,
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
function midValue(min4, max4) {
  return min4 + (max4 - min4) / 2;
}
function machine20(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "progress",
      initial: "idle",
      context: {
        max: ctx.max ?? 100,
        min: ctx.min ?? 0,
        value: midValue(ctx.min ?? 0, ctx.max ?? 100),
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber(ctx2.value)) return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, evt) => {
          set16.value(ctx2, evt.value);
        },
        validateContext: (ctx2) => {
          if (ctx2.value == null) return;
          if (!isValidNumber(ctx2.max)) {
            throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
          }
          if (!isValidMax(ctx2.value, ctx2.max)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
          }
          if (!isValidMin(ctx2.value, ctx2.min)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
          }
        }
      }
    }
  );
}
function isValidNumber(max4) {
  return isNumber(max4) && !isNaN(max4);
}
function isValidMax(value, max4) {
  return isValidNumber(value) && value <= max4;
}
function isValidMin(value, min4) {
  return isValidNumber(value) && value >= min4;
}
var set16 = {
  value(ctx, value) {
    var _a8;
    if (isEqual(ctx.value, value)) return;
    ctx.value = value === null ? null : Math.max(0, Math.min(value, ctx.max));
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value });
  }
};
var props18 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange"
]);
var splitProps19 = createSplitProps(props18);

// node_modules/@ark-ui/react/dist/components/progress/use-progress.js
var import_react463 = __toESM(require_react(), 1);
var useProgress = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react463.useId)(),
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine20(initialContext), { context });
  return connect20(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var ProgressRoot = (0, import_react465.forwardRef)((props25, ref2) => {
  const [progressProps, localProps] = createSplitProps2()(props25, [
    "defaultValue",
    "id",
    "ids",
    "max",
    "min",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps2(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime214.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime214.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ProgressRoot.displayName = "ProgressRoot";

// node_modules/@ark-ui/react/dist/components/progress/progress-root-provider.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react467 = __toESM(require_react(), 1);
var ProgressRootProvider = (0, import_react467.forwardRef)(
  (props25, ref2) => {
    const [{ value: progress }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(progress.getRootProps(), localProps);
    return (0, import_jsx_runtime215.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime215.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ProgressRootProvider.displayName = "ProgressRootProvider";

// node_modules/@ark-ui/react/dist/components/progress/progress-track.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_react469 = __toESM(require_react(), 1);
var ProgressTrack = (0, import_react469.forwardRef)((props25, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getTrackProps(), props25);
  return (0, import_jsx_runtime216.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressTrack.displayName = "ProgressTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-value-text.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var import_react471 = __toESM(require_react(), 1);
var ProgressValueText = (0, import_react471.forwardRef)(
  (props25, ref2) => {
    const { children, ...rest } = props25;
    const progress = useProgressContext();
    const mergedProps = mergeProps2(progress.getValueTextProps(), rest);
    return (0, import_jsx_runtime217.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || progress.percentAsString });
  }
);
ProgressValueText.displayName = "ProgressValueText";

// node_modules/@ark-ui/react/dist/components/progress/progress-view.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var import_react473 = __toESM(require_react(), 1);
var ProgressView = (0, import_react473.forwardRef)((props25, ref2) => {
  const [viewProps2, localProps] = createSplitProps2()(props25, ["state"]);
  const progress = useProgressContext();
  const mergedProps = mergeProps2(progress.getViewProps(viewProps2), localProps);
  return (0, import_jsx_runtime218.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
ProgressView.displayName = "ProgressView";

// node_modules/@ark-ui/react/dist/components/progress/progress.js
var progress_exports = {};
__export(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code-context.js
var [QrCodeProvider, useQrCodeContext] = createContext3({
  name: "QrCodeContext",
  hookName: "useQrCodeContext",
  providerName: "<QrCodeProvider />"
});

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-context.js
var QrCodeContext = (props25) => props25.children(useQrCodeContext());

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-download-trigger.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var import_react475 = __toESM(require_react(), 1);
var QrCodeDownloadTrigger = (0, import_react475.forwardRef)(
  (props25, ref2) => {
    const [downloadTriggerProps, localProps] = createSplitProps2()(props25, [
      "fileName",
      "mimeType",
      "quality"
    ]);
    const qrCode = useQrCodeContext();
    const mergedProps = mergeProps2(qrCode.getDownloadTriggerProps(downloadTriggerProps), localProps);
    return (0, import_jsx_runtime219.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
QrCodeDownloadTrigger.displayName = "QrCodeDownloadTrigger";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-frame.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var import_react477 = __toESM(require_react(), 1);
var QrCodeFrame = (0, import_react477.forwardRef)((props25, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getFrameProps(), props25);
  return (0, import_jsx_runtime220.jsx)(ark.svg, { ...mergedProps, ref: ref2 });
});
QrCodeFrame.displayName = "QrCodeFrame";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-overlay.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_react479 = __toESM(require_react(), 1);
var QrCodeOverlay = (0, import_react479.forwardRef)((props25, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getOverlayProps(), props25);
  return (0, import_jsx_runtime221.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
QrCodeOverlay.displayName = "QrCodeOverlay";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-pattern.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var import_react481 = __toESM(require_react(), 1);
var QrCodePattern = (0, import_react481.forwardRef)((props25, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps2(qrCode.getPatternProps(), props25);
  return (0, import_jsx_runtime222.jsx)(ark.path, { ...mergedProps, ref: ref2 });
});
QrCodePattern.displayName = "QrCodePattern";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react485 = __toESM(require_react(), 1);

// node_modules/proxy-memoize/dist/memoize.js
var targetCache2 = /* @__PURE__ */ new WeakMap();
var HAS_KEY_PROPERTY2 = "h";
var ALL_OWN_KEYS_PROPERTY2 = "w";
var HAS_OWN_KEY_PROPERTY2 = "o";
var KEYS_PROPERTY2 = "k";
var trackMemoUntrackedObjSet = /* @__PURE__ */ new WeakSet();
var isObject6 = (x) => typeof x === "object" && x !== null;
var untrack = (x, seen) => {
  if (!isObject6(x))
    return x;
  const untrackedObj = getUntracked(x);
  if (untrackedObj) {
    trackMemo(x);
    trackMemoUntrackedObjSet.add(untrackedObj);
    return untrackedObj;
  }
  if (!seen.has(x)) {
    seen.add(x);
    Object.entries(x).forEach(([k, v]) => {
      const vv = untrack(v, seen);
      if (!Object.is(vv, v))
        x[k] = vv;
    });
  }
  return x;
};
var touchAffected = (dst, src, affected) => {
  var _a8, _b7, _c6;
  if (!isObject6(dst) || !isObject6(src))
    return;
  const untrackedObj = getUntracked(src);
  const used = affected.get(untrackedObj || src);
  if (!used) {
    if (trackMemoUntrackedObjSet.has(untrackedObj)) {
      trackMemo(dst);
    }
    return;
  }
  (_a8 = used[HAS_KEY_PROPERTY2]) === null || _a8 === void 0 ? void 0 : _a8.forEach((key) => {
    Reflect.has(dst, key);
  });
  if (used[ALL_OWN_KEYS_PROPERTY2] === true) {
    Reflect.ownKeys(dst);
  }
  (_b7 = used[HAS_OWN_KEY_PROPERTY2]) === null || _b7 === void 0 ? void 0 : _b7.forEach((key) => {
    Reflect.getOwnPropertyDescriptor(dst, key);
  });
  (_c6 = used[KEYS_PROPERTY2]) === null || _c6 === void 0 ? void 0 : _c6.forEach((key) => {
    touchAffected(dst[key], src[key], affected);
  });
};
var isOriginalEqual = (x, y) => {
  for (let xx = x; xx; x = xx, xx = getUntracked(xx))
    ;
  for (let yy = y; yy; y = yy, yy = getUntracked(yy))
    ;
  return Object.is(x, y);
};
var OBJ_PROPERTY = "o";
var RESULT_PROPERTY = "r";
var AFFECTED_PROPERTY2 = "a";
function memoize2(fn, options) {
  var _a8;
  let memoListHead = 0;
  const size3 = (_a8 = options === null || options === void 0 ? void 0 : options.size) !== null && _a8 !== void 0 ? _a8 : 1;
  const memoList = [];
  const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj) => {
    const cache2 = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);
    if (cache2) {
      return cache2;
    }
    for (let i = 0; i < size3; i += 1) {
      const memo5 = memoList[(memoListHead + i) % size3];
      if (!memo5)
        break;
      const { [OBJ_PROPERTY]: memoObj, [AFFECTED_PROPERTY2]: memoAffected, [RESULT_PROPERTY]: memoResult } = memo5;
      if (!isChanged(memoObj, obj, memoAffected, /* @__PURE__ */ new WeakMap(), isOriginalEqual)) {
        touchAffected(obj, memoObj, memoAffected);
        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);
        return memoResult;
      }
    }
    const affected = /* @__PURE__ */ new WeakMap();
    const proxy2 = createProxy(obj, affected, void 0, targetCache2);
    const result = untrack(fn(proxy2), /* @__PURE__ */ new WeakSet());
    touchAffected(obj, obj, affected);
    const entry = {
      [OBJ_PROPERTY]: obj,
      [RESULT_PROPERTY]: result,
      [AFFECTED_PROPERTY2]: affected
    };
    memoListHead = (memoListHead - 1 + size3) % size3;
    memoList[memoListHead] = entry;
    resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);
    return result;
  };
  return memoizedFn;
}

// node_modules/uqr/dist/index.mjs
var QrCodeDataType = ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var LOW = [0, 1];
var MEDIUM = [1, 0];
var QUARTILE = [2, 3];
var HIGH = [3, 2];
var EccMap = {
  L: LOW,
  M: MEDIUM,
  Q: QUARTILE,
  H: HIGH
};
var NUMERIC_REGEX = /^[0-9]*$/;
var ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
var ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
var MIN_VERSION = 1;
var MAX_VERSION = 40;
var PENALTY_N1 = 3;
var PENALTY_N2 = 3;
var PENALTY_N3 = 40;
var PENALTY_N4 = 10;
var ECC_CODEWORDS_PER_BLOCK = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
];
var NUM_ERROR_CORRECTION_BLOCKS = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
];
var QrCode = class {
  /* -- Constructor (low level) and fields -- */
  // Creates a new QR Code with the given version number,
  // error correction level, data codeword bytes, and mask number.
  // This is a low-level API that most users should not use directly.
  // A mid-level API is the encodeSegments() function.
  constructor(version2, ecc, dataCodewords, msk) {
    this.version = version2;
    this.ecc = ecc;
    __publicField5(this, "size");
    __publicField5(this, "mask");
    __publicField5(this, "modules", []);
    __publicField5(this, "types", []);
    if (version2 < MIN_VERSION || version2 > MAX_VERSION)
      throw new RangeError("Version value out of range");
    if (msk < -1 || msk > 7)
      throw new RangeError("Mask value out of range");
    this.size = version2 * 4 + 17;
    const row = Array.from({ length: this.size }, () => false);
    for (let i = 0; i < this.size; i++) {
      this.modules.push(row.slice());
      this.types.push(row.map(() => 0));
    }
    this.drawFunctionPatterns();
    const allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk === -1) {
      let minPenalty = 1e9;
      for (let i = 0; i < 8; i++) {
        this.applyMask(i);
        this.drawFormatBits(i);
        const penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = i;
          minPenalty = penalty;
        }
        this.applyMask(i);
      }
    }
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
  }
  /* -- Accessor methods -- */
  // Returns the color of the module (pixel) at the given coordinates, which is false
  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
  // If the given coordinates are out of bounds, then false (light) is returned.
  getModule(x, y) {
    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
  }
  /* -- Private helper methods for constructor: Drawing function modules -- */
  // Reads this object's version field, and draws and marks all function modules.
  drawFunctionPatterns() {
    for (let i = 0; i < this.size; i++) {
      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
    }
    this.drawFinderPattern(3, 3);
    this.drawFinderPattern(this.size - 4, 3);
    this.drawFinderPattern(3, this.size - 4);
    const alignPatPos = this.getAlignmentPatternPositions();
    const numAlign = alignPatPos.length;
    for (let i = 0; i < numAlign; i++) {
      for (let j = 0; j < numAlign; j++) {
        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))
          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
      }
    }
    this.drawFormatBits(0);
    this.drawVersion();
  }
  // Draws two copies of the format bits (with its own error correction code)
  // based on the given mask and this object's error correction level field.
  drawFormatBits(mask) {
    const data = this.ecc[1] << 3 | mask;
    let rem = data;
    for (let i = 0; i < 10; i++)
      rem = rem << 1 ^ (rem >>> 9) * 1335;
    const bits = (data << 10 | rem) ^ 21522;
    for (let i = 0; i <= 5; i++)
      this.setFunctionModule(8, i, getBit(bits, i));
    this.setFunctionModule(8, 7, getBit(bits, 6));
    this.setFunctionModule(8, 8, getBit(bits, 7));
    this.setFunctionModule(7, 8, getBit(bits, 8));
    for (let i = 9; i < 15; i++)
      this.setFunctionModule(14 - i, 8, getBit(bits, i));
    for (let i = 0; i < 8; i++)
      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
    for (let i = 8; i < 15; i++)
      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
    this.setFunctionModule(8, this.size - 8, true);
  }
  // Draws two copies of the version bits (with its own error correction code),
  // based on this object's version field, iff 7 <= version <= 40.
  drawVersion() {
    if (this.version < 7)
      return;
    let rem = this.version;
    for (let i = 0; i < 12; i++)
      rem = rem << 1 ^ (rem >>> 11) * 7973;
    const bits = this.version << 12 | rem;
    for (let i = 0; i < 18; i++) {
      const color = getBit(bits, i);
      const a = this.size - 11 + i % 3;
      const b = Math.floor(i / 3);
      this.setFunctionModule(a, b, color);
      this.setFunctionModule(b, a, color);
    }
  }
  // Draws a 9*9 finder pattern including the border separator,
  // with the center module at (x, y). Modules can be out of bounds.
  drawFinderPattern(x, y) {
    for (let dy = -4; dy <= 4; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        const xx = x + dx;
        const yy = y + dy;
        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
      }
    }
  }
  // Draws a 5*5 alignment pattern, with the center module
  // at (x, y). All modules must be in bounds.
  drawAlignmentPattern(x, y) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        this.setFunctionModule(
          x + dx,
          y + dy,
          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,
          QrCodeDataType.Alignment
        );
      }
    }
  }
  // Sets the color of a module and marks it as a function module.
  // Only used by the constructor. Coordinates must be in bounds.
  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
    this.modules[y][x] = isDark;
    this.types[y][x] = type;
  }
  /* -- Private helper methods for constructor: Codewords and masking -- */
  // Returns a new byte string representing the given data with the appropriate error correction
  // codewords appended to it, based on this object's version and error correction level.
  addEccAndInterleave(data) {
    const ver = this.version;
    const ecl = this.ecc;
    if (data.length !== getNumDataCodewords(ver, ecl))
      throw new RangeError("Invalid argument");
    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
    const blocks = [];
    const rsDiv = reedSolomonComputeDivisor(blockEccLen);
    for (let i = 0, k = 0; i < numBlocks; i++) {
      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
      k += dat.length;
      const ecc = reedSolomonComputeRemainder(dat, rsDiv);
      if (i < numShortBlocks)
        dat.push(0);
      blocks.push(dat.concat(ecc));
    }
    const result = [];
    for (let i = 0; i < blocks[0].length; i++) {
      blocks.forEach((block, j) => {
        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
          result.push(block[i]);
      });
    }
    return result;
  }
  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
  // data area of this QR Code. Function modules need to be marked off before this is called.
  drawCodewords(data) {
    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))
      throw new RangeError("Invalid argument");
    let i = 0;
    for (let right = this.size - 1; right >= 1; right -= 2) {
      if (right === 6)
        right = 5;
      for (let vert = 0; vert < this.size; vert++) {
        for (let j = 0; j < 2; j++) {
          const x = right - j;
          const upward = (right + 1 & 2) === 0;
          const y = upward ? this.size - 1 - vert : vert;
          if (!this.types[y][x] && i < data.length * 8) {
            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
            i++;
          }
        }
      }
    }
  }
  // XORs the codeword modules in this QR Code with the given mask pattern.
  // The function modules must be marked and the codeword bits must be drawn
  // before masking. Due to the arithmetic of XOR, calling applyMask() with
  // the same mask value a second time will undo the mask. A final well-formed
  // QR Code needs exactly one (not zero, two, etc.) mask applied.
  applyMask(mask) {
    if (mask < 0 || mask > 7)
      throw new RangeError("Mask value out of range");
    for (let y = 0; y < this.size; y++) {
      for (let x = 0; x < this.size; x++) {
        let invert;
        switch (mask) {
          case 0:
            invert = (x + y) % 2 === 0;
            break;
          case 1:
            invert = y % 2 === 0;
            break;
          case 2:
            invert = x % 3 === 0;
            break;
          case 3:
            invert = (x + y) % 3 === 0;
            break;
          case 4:
            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
            break;
          case 5:
            invert = x * y % 2 + x * y % 3 === 0;
            break;
          case 6:
            invert = (x * y % 2 + x * y % 3) % 2 === 0;
            break;
          case 7:
            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
            break;
          default:
            throw new Error("Unreachable");
        }
        if (!this.types[y][x] && invert)
          this.modules[y][x] = !this.modules[y][x];
      }
    }
  }
  // Calculates and returns the penalty score based on state of this QR Code's current modules.
  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  getPenaltyScore() {
    let result = 0;
    for (let y = 0; y < this.size; y++) {
      let runColor = false;
      let runX = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let x = 0; x < this.size; x++) {
        if (this.modules[y][x] === runColor) {
          runX++;
          if (runX === 5)
            result += PENALTY_N1;
          else if (runX > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runX, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runX = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
    }
    for (let x = 0; x < this.size; x++) {
      let runColor = false;
      let runY = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let y = 0; y < this.size; y++) {
        if (this.modules[y][x] === runColor) {
          runY++;
          if (runY === 5)
            result += PENALTY_N1;
          else if (runY > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runY, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runY = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
    }
    for (let y = 0; y < this.size - 1; y++) {
      for (let x = 0; x < this.size - 1; x++) {
        const color = this.modules[y][x];
        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])
          result += PENALTY_N2;
      }
    }
    let dark = 0;
    for (const row of this.modules)
      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
    const total = this.size * this.size;
    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
    result += k * PENALTY_N4;
    return result;
  }
  /* -- Private helper functions -- */
  // Returns an ascending list of positions of alignment patterns for this version number.
  // Each position is in the range [0,177), and are used on both the x and y axes.
  // This could be implemented as lookup table of 40 variable-length lists of integers.
  getAlignmentPatternPositions() {
    if (this.version === 1) {
      return [];
    } else {
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step)
        result.splice(1, 0, pos);
      return result;
    }
  }
  // Can only be called immediately after a light run is added, and
  // returns either 0, 1, or 2. A helper function for getPenaltyScore().
  finderPenaltyCountPatterns(runHistory) {
    const n = runHistory[1];
    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
  }
  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
    if (currentRunColor) {
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      currentRunLength = 0;
    }
    currentRunLength += this.size;
    this.finderPenaltyAddHistory(currentRunLength, runHistory);
    return this.finderPenaltyCountPatterns(runHistory);
  }
  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  finderPenaltyAddHistory(currentRunLength, runHistory) {
    if (runHistory[0] === 0)
      currentRunLength += this.size;
    runHistory.pop();
    runHistory.unshift(currentRunLength);
  }
};
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len !== 0)
    throw new RangeError("Value out of range");
  for (let i = len - 1; i >= 0; i--)
    bb.push(val >>> i & 1);
}
function getBit(x, i) {
  return (x >>> i & 1) !== 0;
}
var QrSegment = class {
  // Creates a new QR Code segment with the given attributes and data.
  // The character count (numChars) must agree with the mode and the bit buffer length,
  // but the constraint isn't checked. The given bit buffer is cloned and stored.
  constructor(mode, numChars, bitData) {
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0)
      throw new RangeError("Invalid argument");
    this.bitData = bitData.slice();
  }
  /* -- Methods -- */
  // Returns a new copy of the data bits of this segment.
  getData() {
    return this.bitData.slice();
  }
};
var MODE_NUMERIC = [1, 10, 12, 14];
var MODE_ALPHANUMERIC = [2, 9, 11, 13];
var MODE_BYTE = [4, 8, 16, 16];
function numCharCountBits(mode, ver) {
  return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
  const bb = [];
  for (const b of data)
    appendBits(b, 8, bb);
  return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
  if (!isNumeric(digits))
    throw new RangeError("String contains non-numeric characters");
  const bb = [];
  for (let i = 0; i < digits.length; ) {
    const n = Math.min(digits.length - i, 3);
    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
    i += n;
  }
  return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
  if (!isAlphanumeric(text))
    throw new RangeError("String contains unencodable characters in alphanumeric mode");
  const bb = [];
  let i;
  for (i = 0; i + 2 <= text.length; i += 2) {
    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
    appendBits(temp, 11, bb);
  }
  if (i < text.length)
    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
  if (text === "")
    return [];
  else if (isNumeric(text))
    return [makeNumeric(text)];
  else if (isAlphanumeric(text))
    return [makeAlphanumeric(text)];
  else
    return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
  return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
  return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version2) {
  let result = 0;
  for (const seg of segs) {
    const ccbits = numCharCountBits(seg.mode, version2);
    if (seg.numChars >= 1 << ccbits)
      return Number.POSITIVE_INFINITY;
    result += 4 + ccbits + seg.bitData.length;
  }
  return result;
}
function toUtf8ByteArray(str) {
  str = encodeURI(str);
  const result = [];
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) !== "%") {
      result.push(str.charCodeAt(i));
    } else {
      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
      i += 2;
    }
  }
  return result;
}
function getNumRawDataModules(ver) {
  if (ver < MIN_VERSION || ver > MAX_VERSION)
    throw new RangeError("Version number out of range");
  let result = (16 * ver + 128) * ver + 64;
  if (ver >= 2) {
    const numAlign = Math.floor(ver / 7) + 2;
    result -= (25 * numAlign - 10) * numAlign - 55;
    if (ver >= 7)
      result -= 36;
  }
  return result;
}
function getNumDataCodewords(ver, ecl) {
  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
  if (degree < 1 || degree > 255)
    throw new RangeError("Degree out of range");
  const result = [];
  for (let i = 0; i < degree - 1; i++)
    result.push(0);
  result.push(1);
  let root = 1;
  for (let i = 0; i < degree; i++) {
    for (let j = 0; j < result.length; j++) {
      result[j] = reedSolomonMultiply(result[j], root);
      if (j + 1 < result.length)
        result[j] ^= result[j + 1];
    }
    root = reedSolomonMultiply(root, 2);
  }
  return result;
}
function reedSolomonComputeRemainder(data, divisor) {
  const result = divisor.map((_) => 0);
  for (const b of data) {
    const factor = b ^ result.shift();
    result.push(0);
    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
  }
  return result;
}
function reedSolomonMultiply(x, y) {
  if (x >>> 8 !== 0 || y >>> 8 !== 0)
    throw new RangeError("Byte out of range");
  let z = 0;
  for (let i = 7; i >= 0; i--) {
    z = z << 1 ^ (z >>> 7) * 285;
    z ^= (y >>> i & 1) * x;
  }
  return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
    throw new RangeError("Invalid value");
  let version2;
  let dataUsedBits;
  for (version2 = minVersion; ; version2++) {
    const dataCapacityBits2 = getNumDataCodewords(version2, ecl) * 8;
    const usedBits = getTotalBits(segs, version2);
    if (usedBits <= dataCapacityBits2) {
      dataUsedBits = usedBits;
      break;
    }
    if (version2 >= maxVersion)
      throw new RangeError("Data too long");
  }
  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {
    if (boostEcl && dataUsedBits <= getNumDataCodewords(version2, newEcl) * 8)
      ecl = newEcl;
  }
  const bb = [];
  for (const seg of segs) {
    appendBits(seg.mode[0], 4, bb);
    appendBits(seg.numChars, numCharCountBits(seg.mode, version2), bb);
    for (const b of seg.getData())
      bb.push(b);
  }
  const dataCapacityBits = getNumDataCodewords(version2, ecl) * 8;
  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
  appendBits(0, (8 - bb.length % 8) % 8, bb);
  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
    appendBits(padByte, 8, bb);
  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
  bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
  return new QrCode(version2, ecl, dataCodewords, mask);
}
function encode(data, options) {
  var _a8;
  const {
    ecc = "L",
    boostEcc = false,
    minVersion = 1,
    maxVersion = 40,
    maskPattern = -1,
    border = 1
  } = options || {};
  const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
  if (!segment)
    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
  const qr = encodeSegments(
    segment,
    EccMap[ecc],
    minVersion,
    maxVersion,
    maskPattern,
    boostEcc
  );
  const result = addBorder({
    version: qr.version,
    maskPattern: qr.mask,
    size: qr.size,
    data: qr.modules,
    types: qr.types
  }, border);
  if (options == null ? void 0 : options.invert)
    result.data = result.data.map((row) => row.map((mod2) => !mod2));
  (_a8 = options == null ? void 0 : options.onEncoded) == null ? void 0 : _a8.call(options, result);
  return result;
}
function addBorder(input, border = 1) {
  if (!border)
    return input;
  const { size: size3 } = input;
  const newSize = size3 + border * 2;
  input.size = newSize;
  input.data.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(false);
      row.push(false);
    }
  });
  for (let i = 0; i < border; i++) {
    input.data.unshift(Array.from({ length: newSize }, (_) => false));
    input.data.push(Array.from({ length: newSize }, (_) => false));
  }
  const b = QrCodeDataType.Border;
  input.types.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(b);
      row.push(b);
    }
  });
  for (let i = 0; i < border; i++) {
    input.types.unshift(Array.from({ length: newSize }, (_) => b));
    input.types.push(Array.from({ length: newSize }, (_) => b));
  }
  return input;
}

// node_modules/@zag-js/qr-code/dist/index.mjs
var anatomy21 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
var parts23 = anatomy21.build();
var dom21 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `qrcode:${ctx.id}:root`;
  },
  getFrameId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.frame) ?? `qrcode:${ctx.id}:frame`;
  },
  getFrameEl: (ctx) => dom21.getById(ctx, dom21.getFrameId(ctx))
});
function connect21(state2, send, normalize2) {
  const encoded = state2.context.encoded;
  const pixelSize = state2.context.pixelSize;
  const height = encoded.size * pixelSize;
  const width = encoded.size * pixelSize;
  const paths = [];
  for (let row = 0; row < encoded.size; row++) {
    for (let col = 0; col < encoded.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (encoded.data[row][col]) {
        paths.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
      }
    }
  }
  return {
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    getDataUrl(type, quality) {
      const svgEl = dom21.getFrameEl(state2.context);
      return getDataUrl(svgEl, { type, quality });
    },
    getRootProps() {
      return normalize2.element({
        id: dom21.getRootId(state2.context),
        ...parts23.root.attrs,
        style: {
          "--qrcode-pixel-size": `${pixelSize}px`,
          "--qrcode-width": `${width}px`,
          "--qrcode-height": `${height}px`,
          position: "relative"
        }
      });
    },
    getFrameProps() {
      return normalize2.svg({
        id: dom21.getFrameId(state2.context),
        ...parts23.frame.attrs,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${width} ${height}`
      });
    },
    getPatternProps() {
      return normalize2.path({
        d: paths.join(""),
        ...parts23.pattern.attrs
      });
    },
    getOverlayProps() {
      return normalize2.element({
        ...parts23.overlay.attrs,
        style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          translate: "-50% -50%"
        }
      });
    },
    getDownloadTriggerProps(props25) {
      return normalize2.button({
        type: "button",
        ...parts23.downloadTrigger.attrs,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DOWNLOAD_TRIGGER.CLICK", ...props25 });
        }
      });
    }
  };
}
function machine21(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "qr-code",
      initial: "idle",
      context: {
        value: "",
        ...ctx,
        pixelSize: 10
      },
      computed: {
        encoded: memoize2((ctx2) => encode(ctx2.value, ctx2.encoding))
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "DOWNLOAD_TRIGGER.CLICK": {
          actions: ["downloadQrCode"]
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          set17.value(ctx2, evt.value);
        },
        downloadQrCode(ctx2, evt) {
          const { mimeType, quality, fileName } = evt;
          const svgEl = dom21.getFrameEl(ctx2);
          const doc = dom21.getDoc(ctx2);
          getDataUrl(svgEl, { type: mimeType, quality }).then((dataUri) => {
            const a = doc.createElement("a");
            a.href = dataUri;
            a.rel = "noopener";
            a.download = fileName;
            a.click();
            setTimeout(() => {
              a.remove();
            }, 0);
          });
        }
      }
    }
  );
}
var set17 = {
  value(ctx, value) {
    var _a8;
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value });
  }
};
var props19 = createProps()([
  "ids",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange"
]);
var splitProps20 = createSplitProps(props19);

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code.js
var import_react483 = __toESM(require_react(), 1);
var useQrCode = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react483.useId)(),
    dir,
    value: props25.defaultValue,
    getRootNode,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine21(initialContext), { context });
  return connect21(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var QrCodeRoot = (0, import_react485.forwardRef)((props25, ref2) => {
  const [qrcodeProps, localProps] = createSplitProps2()(props25, [
    "defaultValue",
    "encoding",
    "id",
    "ids",
    "onValueChange",
    "value"
  ]);
  const qrCode = useQrCode(qrcodeProps);
  const mergedProps = mergeProps2(qrCode.getRootProps(), localProps);
  return (0, import_jsx_runtime223.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime223.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
QrCodeRoot.displayName = "QrcodeRoot";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root-provider.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react487 = __toESM(require_react(), 1);
var QrCodeRootProvider = (0, import_react487.forwardRef)(
  (props25, ref2) => {
    const [{ value: qrCode }, localProps] = createSplitProps2()(props25, ["value"]);
    const mergedProps = mergeProps2(qrCode.getRootProps(), localProps);
    return (0, import_jsx_runtime224.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime224.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
QrCodeRootProvider.displayName = "QrCodeRootProvider";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code.js
var qr_code_exports = {};
__export(qr_code_exports, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger,
  Frame: () => QrCodeFrame,
  Overlay: () => QrCodeOverlay,
  Pattern: () => QrCodePattern,
  Root: () => QrCodeRoot,
  RootProvider: () => QrCodeRootProvider
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-context.js
var [SegmentGroupProvider, useSegmentGroupContext] = createContext3(
  {
    name: "SegmentGroupContext",
    hookName: "useSegmentGroupContext",
    providerName: "<SegmentGroupProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-context.js
var SegmentGroupContext = (props25) => props25.children(useSegmentGroupContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_react489 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js
var segmentGroupAnatomy = anatomy10.rename("segment-group");
var parts24 = segmentGroupAnatomy.build();

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var SegmentGroupIndicator = (0, import_react489.forwardRef)(
  (props25, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps2(
      segmentGroup.getIndicatorProps(),
      parts24.indicator.attrs,
      props25
    );
    return (0, import_jsx_runtime225.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupIndicator.displayName = "SegmentGroupIndicator";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var import_react491 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-context.js
var [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext3({
  name: "SegmentGroupItemContext",
  hookName: "useSegmentGroupItemContext",
  providerName: "<SegmentGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-props-context.js
var [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext3({
  name: "SegmentGroupItemPropsContext",
  hookName: "useSegmentGroupItemPropsContext",
  providerName: "<SegmentGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var SegmentGroupItem = (0, import_react491.forwardRef)(
  (props25, ref2) => {
    const [itemProps8, localProps] = createSplitProps2()(props25, [
      "value",
      "disabled",
      "invalid"
    ]);
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps2(
      segmentGroup.getItemProps(itemProps8),
      parts24.item.attrs,
      localProps
    );
    const itemState = segmentGroup.getItemState(itemProps8);
    return (0, import_jsx_runtime226.jsx)(SegmentGroupItemPropsProvider, { value: itemProps8, children: (0, import_jsx_runtime226.jsx)(SegmentGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime226.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
  }
);
SegmentGroupItem.displayName = "SegmentGroupItem";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-context.js
var SegmentGroupItemContext = (props25) => props25.children(useSegmentGroupItemContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-control.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_react493 = __toESM(require_react(), 1);
var SegmentGroupItemControl = (0, import_react493.forwardRef)(
  (props25, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps8 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps2(
      segmentGroup.getItemControlProps(itemProps8),
      parts24.itemControl.attrs,
      props25
    );
    return (0, import_jsx_runtime227.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemControl.displayName = "SegmentGroupItemControl";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-hidden-input.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);
var import_react495 = __toESM(require_react(), 1);
var SegmentGroupItemHiddenInput = (0, import_react495.forwardRef)((props25, ref2) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps8 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps2(segmentGroup.getItemHiddenInputProps(itemProps8), props25);
  return (0, import_jsx_runtime228.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
SegmentGroupItemHiddenInput.displayName = "SegmentGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-text.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var import_react497 = __toESM(require_react(), 1);
var SegmentGroupItemText = (0, import_react497.forwardRef)(
  (props25, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps8 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps2(
      segmentGroup.getItemTextProps(itemProps8),
      parts24.itemText.attrs,
      props25
    );
    return (0, import_jsx_runtime229.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemText.displayName = "SegmentGroupItemText";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-label.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var import_react499 = __toESM(require_react(), 1);
var SegmentGroupLabel = (0, import_react499.forwardRef)(
  (props25, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps2(
      segmentGroup.getLabelProps(),
      parts24.label.attrs,
      props25
    );
    return (0, import_jsx_runtime230.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupLabel.displayName = "SegmentGroupLabel";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);
var import_react503 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group.js
var import_react501 = __toESM(require_react(), 1);
var useSegmentGroup = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react501.useId)(),
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine10(initialContext), {
    context
  });
  return connect10(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var SegmentGroupRoot = (0, import_react503.forwardRef)((props25, ref2) => {
  const [useSegmentGroupProps, localProps] = createSplitProps2()(props25, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps2(
    segmentGroup.getRootProps(),
    parts24.root.attrs,
    localProps
  );
  return (0, import_jsx_runtime231.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime231.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SegmentGroupRoot.displayName = "SegmentGroupRoot";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root-provider.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var import_react505 = __toESM(require_react(), 1);
var SegmentGroupRootProvider = (0, import_react505.forwardRef)(
  (props25, ref2) => {
    const [{ value: segmentGroup }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(
      segmentGroup.getRootProps(),
      parts24.root.attrs,
      localProps
    );
    return (0, import_jsx_runtime232.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime232.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SegmentGroupRootProvider.displayName = "SegmentGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.js
var segment_group_exports = {};
__export(segment_group_exports, {
  Context: () => SegmentGroupContext,
  Indicator: () => SegmentGroupIndicator,
  Item: () => SegmentGroupItem,
  ItemContext: () => SegmentGroupItemContext,
  ItemControl: () => SegmentGroupItemControl,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput,
  ItemText: () => SegmentGroupItemText,
  Label: () => SegmentGroupLabel,
  Root: () => SegmentGroupRoot,
  RootProvider: () => SegmentGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var import_react507 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip-context.js
var [TooltipProvider, useTooltipContext] = createContext3({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var TooltipArrow = (0, import_react507.forwardRef)((props25, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getArrowProps(), props25);
  return (0, import_jsx_runtime233.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow-tip.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var import_react509 = __toESM(require_react(), 1);
var TooltipArrowTip = (0, import_react509.forwardRef)((props25, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getArrowTipProps(), props25);
  return (0, import_jsx_runtime234.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrowTip.displayName = "TooltipArrowTip";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-content.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime(), 1);
var import_react511 = __toESM(require_react(), 1);
var TooltipContent = (0, import_react511.forwardRef)((props25, ref2) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps2(tooltip.getContentProps(), presence.getPresenceProps(), props25);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime235.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
TooltipContent.displayName = "TooltipContent";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-context.js
var TooltipContext = (props25) => props25.children(useTooltipContext());

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-positioner.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime(), 1);
var import_react513 = __toESM(require_react(), 1);
var TooltipPositioner = (0, import_react513.forwardRef)(
  (props25, ref2) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps2(tooltip.getPositionerProps(), props25);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime236.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TooltipPositioner.displayName = "TooltipPositioner";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy22 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts25 = anatomy22.build();
var dom22 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom22.getById(ctx, dom22.getTriggerId(ctx)),
  getContentEl: (ctx) => dom22.getById(ctx, dom22.getContentId(ctx)),
  getPositionerEl: (ctx) => dom22.getById(ctx, dom22.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom22.getById(ctx, dom22.getArrowId(ctx))
});
var store = proxy({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect22(state2, send, normalize2) {
  const id = state2.context.id;
  const hasAriaLabel = state2.context.hasAriaLabel;
  const open = state2.hasTag("open");
  const triggerId = dom22.getTriggerId(state2.context);
  const contentId = dom22.getContentId(state2.context);
  const disabled = state2.context.disabled;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts25.trigger.attrs,
        id: triggerId,
        dir: state2.context.dir,
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnClick) return;
          send({ type: "CLOSE", src: "trigger.click" });
        },
        onFocus(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (state2.event.src === "trigger.pointerdown") return;
          if (!isFocusVisible()) return;
          send({ type: "OPEN", src: "trigger.focus" });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store.id) {
            send({ type: "CLOSE", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnPointerDown) return;
          if (id === store.id) {
            send({ type: "CLOSE", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled) return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled) return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom22.getArrowId(state2.context),
        ...parts25.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts25.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom22.getPositionerId(state2.context),
        ...parts25.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts25.content.attrs,
        dir: state2.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state2.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state2.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and9, not: not10 } = guards;
function machine22(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      activities: ["trackFocusVisible"],
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        closeOnClick: true,
        disabled: false,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and9("noVisibleTooltip", not10("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not10("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom22.getRootNode(ctx2) });
        },
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom22.getPositionerEl(ctx2);
          return getPlacement(dom22.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent(dom22.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          if (!ctx2.closeOnScroll) return;
          const triggerEl = dom22.getTriggerEl(ctx2);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors(triggerEl);
          const cleanups2 = overflowParents.map((overflowParent) => {
            const onScroll = () => {
              send({ type: "CLOSE", src: "scroll" });
            };
            return addDomEvent(overflowParent, "scroll", onScroll, { passive: true, capture: true });
          });
          return () => {
            cleanups2.forEach((fn) => fn == null ? void 0 : fn());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe(store, () => {
            if (store.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id.change" });
            }
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "CLOSE", src: "keydown.escape" });
          };
          return addDomEvent(dom22.getDoc(ctx2), "keydown", onKeyDown, true);
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled) return;
          send({ type: "CLOSE", src: "disabled.change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom22.getPositionerEl(ctx2);
          getPlacement(dom22.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props20 = createProps()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps21 = createSplitProps(props20);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip.js
var import_react515 = __toESM(require_react(), 1);
var useTooltip = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react515.useId)(),
    dir,
    getRootNode,
    open: props25.defaultOpen,
    "open.controlled": props25.open !== void 0,
    ...props25
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props25.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine22(initialContext), { context });
  return connect22(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var TooltipRoot = (props25) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props25);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps2({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime237.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime237.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root-provider.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime(), 1);
var TooltipRootProvider = (props25) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props25);
  const presence = usePresence(mergeProps2({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime238.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime238.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-trigger.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime(), 1);
var import_react519 = __toESM(require_react(), 1);
var TooltipTrigger = (0, import_react519.forwardRef)((props25, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps2(tooltip.getTriggerProps(), props25);
  return (0, import_jsx_runtime239.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TooltipTrigger.displayName = "TooltipTrigger";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow,
  ArrowTip: () => TooltipArrowTip,
  Content: () => TooltipContent,
  Context: () => TooltipContext,
  Positioner: () => TooltipPositioner,
  Root: () => TooltipRoot,
  RootProvider: () => TooltipRootProvider,
  Trigger: () => TooltipTrigger
});

// node_modules/@chakra-ui/react/dist/esm/anatomy.js
var accordionAnatomy = anatomy.extendWith("itemBody");
var actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
var alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
var breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
var blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
var cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
var checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
var dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
var dialogAnatomy = anatomy5.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var drawerAnatomy = anatomy5.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var editableAnatomy = anatomy6.extendWith("textarea");
var emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
var fieldAnatomy2 = fieldAnatomy.extendWith("requiredIndicator");
var fieldsetAnatomy2 = fieldsetAnatomy.extendWith("content");
var fileUploadAnatomy = anatomy7.extendWith(
  "itemContent",
  "dropzoneContent"
);
var listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
var menuAnatomy = anatomy8.extendWith("itemCommand");
var nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
var popoverAnatomy = anatomy9.extendWith(
  "header",
  "body",
  "footer"
);
var radioGroupAnatomy = anatomy10.extendWith(
  "itemAddon",
  "itemIndicator"
);
var radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
var ratingGroupAnatomy = anatomy11.extendWith("itemIndicator");
var selectAnatomy = anatomy12.extendWith("indicatorGroup");
var sliderAnatomy = anatomy13.extendWith("markerIndicator");
var statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
var statusAnatomy = createAnatomy("status").parts("root", "indicator");
var stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
var switchAnatomy = anatomy14.extendWith("indicator");
var tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
var toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
var tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
var tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
var timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js
var accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js
var actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js
var alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js
var avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy15.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js
var blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js
var breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js
var cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js
var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
var checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: (_b = (_a = checkmarkRecipe.variants) == null ? void 0 : _a.size) == null ? void 0 : _b.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: (_d = (_c = checkmarkRecipe.variants) == null ? void 0 : _c.size) == null ? void 0 : _d.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: (_f = (_e = checkmarkRecipe.variants) == null ? void 0 : _e.size) == null ? void 0 : _f.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: (_h = (_g = checkmarkRecipe.variants) == null ? void 0 : _g.size) == null ? void 0 : _h.lg
      }
    },
    variant: {
      outline: {
        control: (_j = (_i = checkmarkRecipe.variants) == null ? void 0 : _i.variant) == null ? void 0 : _j.outline
      },
      solid: {
        control: (_l = (_k = checkmarkRecipe.variants) == null ? void 0 : _k.variant) == null ? void 0 : _l.solid
      },
      subtle: {
        control: (_n = (_m = checkmarkRecipe.variants) == null ? void 0 : _m.variant) == null ? void 0 : _n.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js
var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
var checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8",
        borderColor: "border.subtle"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm"
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: (_a2 = checkmarkRecipe.variants) == null ? void 0 : _a2.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_b2 = checkmarkRecipe.variants) == null ? void 0 : _b2.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_c2 = checkmarkRecipe.variants) == null ? void 0 : _c2.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: (_d2 = checkmarkRecipe.variants) == null ? void 0 : _d2.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: (_e2 = checkmarkRecipe.variants) == null ? void 0 : _e2.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_f2 = checkmarkRecipe.variants) == null ? void 0 : _f2.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_g2 = checkmarkRecipe.variants) == null ? void 0 : _g2.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js
var collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy2.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js
var _a3, _b3, _c3, _d3, _e3, _f3, _g3, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p, _q, _r;
var colorPickerSlotRecipe = defineSlotRecipe({
  className: "colorPicker",
  slots: colorPickerAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm"
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ...colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ...inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: (_b3 = (_a3 = inputRecipe.variants) == null ? void 0 : _a3.size) == null ? void 0 : _b3["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: (_d3 = (_c3 = inputRecipe.variants) == null ? void 0 : _c3.size) == null ? void 0 : _d3.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: (_f3 = (_e3 = inputRecipe.variants) == null ? void 0 : _e3.size) == null ? void 0 : _f3.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: (_h2 = (_g3 = inputRecipe.variants) == null ? void 0 : _g3.size) == null ? void 0 : _h2.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: (_j2 = (_i2 = inputRecipe.variants) == null ? void 0 : _i2.size) == null ? void 0 : _j2.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: (_l2 = (_k2 = inputRecipe.variants) == null ? void 0 : _k2.size) == null ? void 0 : _l2.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: (_n2 = (_m2 = inputRecipe.variants) == null ? void 0 : _m2.size) == null ? void 0 : _n2["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: (_p = (_o = inputRecipe.variants) == null ? void 0 : _o.variant) == null ? void 0 : _p.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: (_r = (_q = inputRecipe.variants) == null ? void 0 : _q.variant) == null ? void 0 : _r.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js
var dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js
var dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js
var drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js
var sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
var editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js
var emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js
var fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy2.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js
var fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: fieldsetAnatomy2.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js
var fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3"
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      alignSelf: "flex-start"
    },
    itemPreviewImage: {
      width: "10",
      height: "10",
      objectFit: "scale-down"
    }
  },
  defaultVariants: {}
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js
var hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy17.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js
var listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert",
          listStylePosition: "inside"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js
var menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemText: {
      flex: "1"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js
var selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js
var _a4, _b4;
var nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: (_a4 = selectSlotRecipe.variants) == null ? void 0 : _a4.variant.outline.trigger
      },
      subtle: {
        field: (_b4 = selectSlotRecipe.variants) == null ? void 0 : _b4.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/utils/entries.js
function mapEntries2(obj, f) {
  const result = {};
  for (const key in obj) {
    const kv = f(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js
var triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
var numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy18.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries2(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js
var { variants: variants2, defaultVariants: defaultVariants2 } = inputRecipe;
var pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy19.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    }
  },
  variants: {
    size: mapEntries2(variants2.size, (key, value) => [key, { input: value }]),
    variant: mapEntries2(variants2.variant, (key, value) => [
      key,
      { input: value }
    ])
  },
  defaultVariants: defaultVariants2
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js
var popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js
var progressSlotRecipe = defineSlotRecipe({
  slots: anatomy20.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js
var progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy20.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js
var qrCodeSlotRecipe = defineSlotRecipe({
  slots: anatomy21.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js
var _a5, _b5, _c4, _d4, _e4, _f4, _g4;
var radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: (_a5 = radiomarkRecipe.variants) == null ? void 0 : _a5.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_b5 = radiomarkRecipe.variants) == null ? void 0 : _b5.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_c4 = radiomarkRecipe.variants) == null ? void 0 : _c4.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: (_d4 = radiomarkRecipe.variants) == null ? void 0 : _d4.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: (_e4 = radiomarkRecipe.variants) == null ? void 0 : _e4.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_f4 = radiomarkRecipe.variants) == null ? void 0 : _f4.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_g4 = radiomarkRecipe.variants) == null ? void 0 : _g4.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js
var _a6, _b6, _c5, _d5, _e5, _f5, _g5, _h3, _i3, _j3, _k3, _l3, _m3, _n3;
var radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: (_b6 = (_a6 = radiomarkRecipe.variants) == null ? void 0 : _a6.variant) == null ? void 0 : _b6.outline
      },
      subtle: {
        itemControl: (_d5 = (_c5 = radiomarkRecipe.variants) == null ? void 0 : _c5.variant) == null ? void 0 : _d5.subtle
      },
      solid: {
        itemControl: (_f5 = (_e5 = radiomarkRecipe.variants) == null ? void 0 : _e5.variant) == null ? void 0 : _f5.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: (_h3 = (_g5 = radiomarkRecipe.variants) == null ? void 0 : _g5.size) == null ? void 0 : _h3.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: (_j3 = (_i3 = radiomarkRecipe.variants) == null ? void 0 : _i3.size) == null ? void 0 : _j3.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: (_l3 = (_k3 = radiomarkRecipe.variants) == null ? void 0 : _k3.size) == null ? void 0 : _l3.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: (_n3 = (_m3 = radiomarkRecipe.variants) == null ? void 0 : _m3.size) == null ? void 0 : _n3.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js
var ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js
var segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted"
    },
    item: {
      display: "flex",
      alignItems: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: "1.5",
        bg: "border",
        width: "1px",
        transition: "opacity 0.2s"
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        root: {
          height: "6"
        },
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1"
        }
      },
      sm: {
        root: {
          height: "8"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      md: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      lg: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "md",
          px: "5",
          gap: "3"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js
var sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label]": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label]": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js
var statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js
var statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js
var stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js
var switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js
var tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js
var tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js
var _a7;
var badgeVariant = (_a7 = badgeRecipe.variants) == null ? void 0 : _a7.variant;
var tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant == null ? void 0 : badgeVariant.subtle
      },
      solid: {
        root: badgeVariant == null ? void 0 : badgeVariant.solid
      },
      outline: {
        root: badgeVariant == null ? void 0 : badgeVariant.outline
      },
      surface: {
        root: badgeVariant == null ? void 0 : badgeVariant.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js
var timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js
var toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js
var tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy22.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js
var slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe,
  colorPicker: colorPickerSlotRecipe,
  qrCode: qrCodeSlotRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js
var textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js
var animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js
var aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js
var blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js
var borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js
var colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js
var cursor2 = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js
var durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js
var easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js
var fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js
var fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js
var fallback2 = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
var fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback2}`
  },
  body: {
    value: `Inter, ${fallback2}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js
var keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js
var letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js
var lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js
var radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js
var spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js
var largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
var namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
var fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
var sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js
var zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/index.js
var defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor: cursor2
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});

// node_modules/@chakra-ui/react/dist/esm/preset.js
var defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
var defaultSystem = createSystem(defaultConfig);

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime(), 1);
var import_react521 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-slot-recipe.js
var import_react520 = __toESM(require_react(), 1);
function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return (0, import_react520.useMemo)(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/create-slot-recipe-context.js
var upperFirst2 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst2(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider2, useStyles] = createContext({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider2, useClassNames3] = createContext({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider62, usePropsContext2] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult6(props25) {
    const { unstyled, ...restProps } = props25;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = slotRecipe.splitVariantProps(restProps);
    const styles = unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps);
    return {
      styles,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider8(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const props25 = mergeProps(defaultProps, usePropsContext2(), inProps);
      const { styles, classNames, props: rootProps } = useRecipeResult6(props25);
      return (0, import_jsx_runtime240.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime240.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime240.jsx)(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider41 = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = (0, import_react521.forwardRef)((inProps, ref2) => {
      var _a8;
      const props25 = mergeProps(defaultProps ?? {}, usePropsContext2(), inProps);
      const { styles, props: rootProps, classNames } = useRecipeResult6(props25);
      const className = classNames[slot];
      const element = (0, import_jsx_runtime240.jsx)(StylesProvider2, { value: styles, children: (0, import_jsx_runtime240.jsx)(ClassNamesProvider2, { value: classNames, children: (0, import_jsx_runtime240.jsx)(
        SuperComponent,
        {
          ref: ref2,
          ...rootProps,
          css: [styles[slot], props25.css],
          className: cx(props25.className, className)
        }
      ) }) });
      return ((_a8 = options2 == null ? void 0 : options2.wrapElement) == null ? void 0 : _a8.call(options2, element, props25)) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext60 = (Component, slot, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = (0, import_react521.forwardRef)((props25, ref2) => {
      const styles = useStyles();
      const classNames = useClassNames3();
      const className = classNames == null ? void 0 : classNames[slot];
      return (0, import_jsx_runtime240.jsx)(
        SuperComponent,
        {
          ...props25,
          css: [slot ? styles[slot] : void 0, props25.css],
          ref: ref2,
          className: cx(props25.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider: StylesProvider2,
    ClassNamesProvider: ClassNamesProvider2,
    PropsProvider: PropsProvider62,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult6,
    withProvider: withProvider41,
    withContext: withContext60,
    withRootProvider: withRootProvider8,
    useStyles,
    useClassNames: useClassNames3
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/recipe-props.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime(), 1);
var [RecipePropsContextProvider, useParentRecipeProps] = createContext({
  name: "RecipePropsContext",
  strict: false
});
function RecipePropsProvider(props25) {
  return (0, import_jsx_runtime241.jsx)(RecipePropsContextProvider, { value: props25.value, children: props25.children });
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/use-token.js
var import_react522 = __toESM(require_react(), 1);
function useToken(category, token2) {
  const sys = useChakraContext();
  return (0, import_react522.useMemo)(() => {
    const arr = Array.isArray(token2) ? token2 : [token2];
    return arr.map((t) => sys.token(`${category}.${t}`, t));
  }, [sys, category, token2]);
}

// node_modules/@chakra-ui/react/dist/esm/components/accordion/accordion.js
var {
  withProvider,
  withContext,
  useStyles: useAccordionStyles,
  PropsProvider
} = createSlotRecipeContext({ key: "accordion" });
var AccordionRootProvider2 = withProvider(accordion_exports.RootProvider, "root", { forwardAsChild: true });
var AccordionRoot2 = withProvider(
  accordion_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AccordionPropsProvider = PropsProvider;
var AccordionItem2 = withContext(
  accordion_exports.Item,
  "item",
  { forwardAsChild: true }
);
var AccordionItemContent2 = withContext(accordion_exports.ItemContent, "itemContent", { forwardAsChild: true });
var AccordionItemBody = withContext("div", "itemBody");
var AccordionItemTrigger2 = withContext(accordion_exports.ItemTrigger, "itemTrigger", { forwardAsChild: true });
var AccordionItemIndicator2 = withContext(accordion_exports.ItemIndicator, "itemIndicator", { forwardAsChild: true });
var AccordionContext2 = accordion_exports.Context;
var AccordionItemContext2 = accordion_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/accordion/namespace.js
var namespace_exports = {};
__export(namespace_exports, {
  Context: () => AccordionContext2,
  Item: () => AccordionItem2,
  ItemBody: () => AccordionItemBody,
  ItemContent: () => AccordionItemContent2,
  ItemContext: () => AccordionItemContext2,
  ItemIndicator: () => AccordionItemIndicator2,
  ItemTrigger: () => AccordionItemTrigger2,
  PropsProvider: () => AccordionPropsProvider,
  Root: () => AccordionRoot2,
  RootProvider: () => AccordionRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/action-bar.js
var {
  withRootProvider,
  withContext: withContext2,
  useStyles: useActionBarStyles,
  PropsProvider: PropsProvider2
} = createSlotRecipeContext({ key: "actionBar" });
var ActionBarRootProvider = withRootProvider(popover_exports.RootProvider, {
  defaultProps: {
    lazyMount: true,
    unmountOnExit: true
  }
});
var ActionBarRoot = withRootProvider(
  popover_exports.Root,
  {
    defaultProps: {
      autoFocus: false,
      lazyMount: true,
      unmountOnExit: true
    }
  }
);
var ActionBarPropsProvider = PropsProvider2;
var ActionBarPositioner = withContext2("div", "positioner", { forwardAsChild: true });
var ActionBarContent = withContext2(popover_exports.Content, "content", { forwardAsChild: true });
var ActionBarSeparator = withContext2("div", "separator");
var ActionBarSelectionTrigger = withContext2("button", "selectionTrigger");
var ActionBarCloseTrigger = withContext2(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var ActionBarContext = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/action-bar/namespace.js
var namespace_exports2 = {};
__export(namespace_exports2, {
  CloseTrigger: () => ActionBarCloseTrigger,
  Content: () => ActionBarContent,
  Context: () => ActionBarContext,
  Positioner: () => ActionBarPositioner,
  PropsProvider: () => ActionBarPropsProvider,
  Root: () => ActionBarRoot,
  RootProvider: () => ActionBarRootProvider,
  SelectionTrigger: () => ActionBarSelectionTrigger,
  Separator: () => ActionBarSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/alert/alert.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime(), 1);
var import_react523 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icons.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime(), 1);
var CheckIcon = (props25) => {
  return (0, import_jsx_runtime242.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props25,
      children: (0, import_jsx_runtime242.jsx)("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
var ChevronUpIcon = (props25) => (0, import_jsx_runtime242.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props25,
    children: (0, import_jsx_runtime242.jsx)("path", { d: "m18 15-6-6-6 6" })
  }
);
var ChevronDownIcon = (props25) => {
  return (0, import_jsx_runtime242.jsx)(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props25,
      children: (0, import_jsx_runtime242.jsx)("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
var ChevronRightIcon = (props25) => (0, import_jsx_runtime242.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props25,
    children: (0, import_jsx_runtime242.jsx)("path", { d: "m9 18 6-6-6-6" })
  }
);
var EllpsisIcon = (props25) => (0, import_jsx_runtime242.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props25,
    children: [
      (0, import_jsx_runtime242.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
      (0, import_jsx_runtime242.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
      (0, import_jsx_runtime242.jsx)("circle", { cx: "5", cy: "12", r: "1" })
    ]
  }
);
var ArrowUpIcon = (props25) => (0, import_jsx_runtime242.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props25,
    children: [
      (0, import_jsx_runtime242.jsx)("path", { d: "m5 12 7-7 7 7" }),
      (0, import_jsx_runtime242.jsx)("path", { d: "M12 19V5" })
    ]
  }
);
var ArrowDownIcon = (props25) => (0, import_jsx_runtime242.jsxs)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props25,
    children: [
      (0, import_jsx_runtime242.jsx)("path", { d: "M12 5v14" }),
      (0, import_jsx_runtime242.jsx)("path", { d: "m19 12-7 7-7-7" })
    ]
  }
);
var CheckCircleIcon = (props25) => (0, import_jsx_runtime242.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props25,
    children: (0, import_jsx_runtime242.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
var WarningIcon = (props25) => (0, import_jsx_runtime242.jsx)(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props25,
    children: (0, import_jsx_runtime242.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
var InfoIcon = (props25) => (0, import_jsx_runtime242.jsx)(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: "0",
    ...props25,
    children: (0, import_jsx_runtime242.jsx)("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" })
  }
);
var QuoteIcon = (props25) => (0, import_jsx_runtime242.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props25, children: (0, import_jsx_runtime242.jsx)("path", { d: "M6.5 10c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.318.142-.686.238-1.028.466-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.945-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 6.5 10zm11 0c-.223 0-.437.034-.65.065.069-.232.14-.468.254-.68.114-.308.292-.575.469-.844.148-.291.409-.488.601-.737.201-.242.475-.403.692-.604.213-.21.492-.315.714-.463.232-.133.434-.28.65-.35l.539-.222.474-.197-.485-1.938-.597.144c-.191.048-.424.104-.689.171-.271.05-.56.187-.882.312-.317.143-.686.238-1.028.467-.344.218-.741.4-1.091.692-.339.301-.748.562-1.05.944-.33.358-.656.734-.909 1.162-.293.408-.492.856-.702 1.299-.19.443-.343.896-.468 1.336-.237.882-.343 1.72-.384 2.437-.034.718-.014 1.315.028 1.747.015.204.043.402.063.539l.025.168.026-.006A4.5 4.5 0 1 0 17.5 10z" }) });
var StarIcon = (props25) => (0, import_jsx_runtime242.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props25, children: (0, import_jsx_runtime242.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) });
var CloseIcon = (props25) => (0, import_jsx_runtime242.jsx)(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props25, children: (0, import_jsx_runtime242.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });

// node_modules/@chakra-ui/react/dist/esm/components/alert/alert.js
var [AlertStatusProvider, useAlertStatusContext] = createContext({
  name: "AlertStatusContext",
  hookName: "useAlertStatusContext",
  providerName: "<Alert />"
});
var {
  withProvider: withProvider2,
  withContext: withContext3,
  useStyles: useAlertStyles,
  PropsProvider: PropsProvider3
} = createSlotRecipeContext({ key: "alert" });
var AlertRoot = withProvider2(
  "div",
  "root",
  {
    forwardAsChild: true,
    wrapElement(element, props25) {
      return (
        // @ts-ignore fix later
        (0, import_jsx_runtime243.jsx)(AlertStatusProvider, { value: { status: props25.status || "info" }, children: element })
      );
    }
  }
);
var AlertPropsProvider = PropsProvider3;
var AlertTitle = withContext3(
  "div",
  "title"
);
var AlertDescription = withContext3("div", "description");
var AlertContent = withContext3(
  "div",
  "content"
);
var iconMap = {
  info: InfoIcon,
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon,
  neutral: InfoIcon
};
var AlertIndicator = (0, import_react523.forwardRef)(
  function AlertIndicator2(props25, ref2) {
    const api = useAlertStatusContext();
    const styles = useAlertStyles();
    const Icon3 = typeof api.status === "string" ? iconMap[api.status] : import_react523.Fragment;
    const { children = (0, import_jsx_runtime243.jsx)(Icon3, {}), ...rest } = props25;
    return (0, import_jsx_runtime243.jsx)(chakra.span, { ref: ref2, ...rest, css: [styles.indicator, props25.css], children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/alert/namespace.js
var namespace_exports3 = {};
__export(namespace_exports3, {
  Content: () => AlertContent,
  Description: () => AlertDescription,
  Indicator: () => AlertIndicator,
  Root: () => AlertRoot,
  RootPropsProvider: () => AlertPropsProvider,
  Title: () => AlertTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/aspect-ratio/aspect-ratio.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime(), 1);
var import_react524 = __toESM(require_react(), 1);
var AspectRatio = (0, import_react524.forwardRef)(
  function AspectRatio2(props25, ref2) {
    const { ratio = 4 / 3, children, className, ...rest } = props25;
    const child = import_react524.Children.only(children);
    return (0, import_jsx_runtime244.jsx)(
      chakra.div,
      {
        ref: ref2,
        position: "relative",
        className: cx("chakra-aspect-ratio", className),
        _before: {
          height: 0,
          content: `""`,
          display: "block",
          paddingBottom: mapObject(ratio, (r) => `${1 / r * 100}%`)
        },
        css: {
          "& > *:not(style)": {
            overflow: "hidden",
            position: "absolute",
            top: "0",
            right: "0",
            bottom: "0",
            left: "0",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            width: "100%",
            height: "100%"
          },
          "& > img, & > video": {
            objectFit: "cover"
          },
          ...props25.css
        },
        ...rest,
        children: child
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/avatar/avatar.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime(), 1);
var import_react525 = __toESM(require_react(), 1);
var {
  withProvider: withProvider3,
  withContext: withContext4,
  useStyles: useAvatarStyles,
  PropsProvider: PropsProvider4
} = createSlotRecipeContext({ key: "avatar" });
var AvatarRootProvider2 = withProvider3(avatar_exports.RootProvider, "root", { forwardAsChild: true });
var AvatarRoot2 = withProvider3(
  avatar_exports.Root,
  "root",
  { forwardAsChild: true }
);
var AvatarPropsProvider = PropsProvider4;
var AvatarFallback2 = withContext4(
  avatar_exports.Fallback,
  "fallback",
  { forwardAsChild: true }
);
var AvatarImage2 = withContext4(
  avatar_exports.Image,
  "image",
  {
    forwardAsChild: true,
    defaultProps: {
      draggable: "false",
      referrerPolicy: "no-referrer"
    }
  }
);
var AvatarIcon = (0, import_react525.forwardRef)(
  function AvatarIcon2(props25, ref2) {
    return (0, import_jsx_runtime245.jsx)(
      chakra.svg,
      {
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0",
        viewBox: "0 0 24 24",
        height: "1.2em",
        width: "1.2em",
        ref: ref2,
        ...props25,
        children: (0, import_jsx_runtime245.jsx)("path", { d: "M20 22H18V20C18 18.3431 16.6569 17 15 17H9C7.34315 17 6 18.3431 6 20V22H4V20C4 17.2386 6.23858 15 9 15H15C17.7614 15 20 17.2386 20 20V22ZM12 13C8.68629 13 6 10.3137 6 7C6 3.68629 8.68629 1 12 1C15.3137 1 18 3.68629 18 7C18 10.3137 15.3137 13 12 13ZM12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z" })
      }
    );
  }
);
var AvatarContext2 = avatar_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/avatar/namespace.js
var namespace_exports4 = {};
__export(namespace_exports4, {
  Context: () => AvatarContext2,
  Fallback: () => AvatarFallback2,
  Icon: () => AvatarIcon,
  Image: () => AvatarImage2,
  PropsProvider: () => AvatarPropsProvider,
  Root: () => AvatarRoot2,
  RootProvider: () => AvatarRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/badge/badge.js
var { PropsProvider: PropsProvider5, withContext: withContext5 } = createRecipeContext({
  key: "badge"
});
var Badge = withContext5("span");
var BadgePropsProvider = PropsProvider5;

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime(), 1);
var import_react526 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/unit.js
var lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%";
var lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`;
var lengthRegExp = new RegExp(
  `^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`
);
var isCssUnit = (v) => typeof v === "string" && lengthRegExp.test(v);

// node_modules/@chakra-ui/react/dist/esm/components/bleed/bleed.js
var valueFn = (v) => isCssUnit(v) || isCssVar(v) ? v : `token(spacing.${v}, ${v})`;
var Bleed = (0, import_react526.forwardRef)(
  function Bleed2(props25, ref2) {
    const {
      inline: inline2,
      inlineStart,
      inlineEnd,
      block,
      blockStart,
      blockEnd,
      ...rest
    } = props25;
    return (0, import_jsx_runtime246.jsx)(
      chakra.div,
      {
        ref: ref2,
        ...rest,
        css: {
          "--bleed-inline-start": mapObject(inline2 ?? inlineStart, valueFn),
          "--bleed-inline-end": mapObject(inline2 ?? inlineEnd, valueFn),
          "--bleed-block-start": mapObject(block ?? blockStart, valueFn),
          "--bleed-block-end": mapObject(block ?? blockEnd, valueFn),
          marginInlineStart: "calc(var(--bleed-inline-start, 0) * -1)",
          marginInlineEnd: "calc(var(--bleed-inline-end, 0) * -1)",
          marginBlockStart: "calc(var(--bleed-block-start, 0) * -1)",
          marginBlockEnd: "calc(var(--bleed-block-end, 0) * -1)"
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/blockquote.js
var {
  withProvider: withProvider4,
  withContext: withContext6,
  useStyles: useBlockquoteStyles,
  PropsProvider: PropsProvider6
} = createSlotRecipeContext({ key: "blockquote" });
var BlockquoteRoot = withProvider4(
  "figure",
  "root"
);
var BlockquotePropsProvider = PropsProvider6;
var BlockquoteContent = withContext6("blockquote", "content");
var BlockquoteCaption = withContext6("figcaption", "caption");
var BlockquoteIcon = withContext6(
  QuoteIcon,
  "icon"
);

// node_modules/@chakra-ui/react/dist/esm/components/blockquote/namespace.js
var namespace_exports5 = {};
__export(namespace_exports5, {
  Caption: () => BlockquoteCaption,
  Content: () => BlockquoteContent,
  Icon: () => BlockquoteIcon,
  PropsProvider: () => BlockquotePropsProvider,
  Root: () => BlockquoteRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/box/box.js
var Box = chakra("div");
Box.displayName = "Box";

// node_modules/@chakra-ui/react/dist/esm/components/box/square.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime(), 1);
var import_react527 = __toESM(require_react(), 1);
var Square = (0, import_react527.forwardRef)(
  function Square2(props25, ref2) {
    const { size: size3, ...rest } = props25;
    return (0, import_jsx_runtime247.jsx)(
      Box,
      {
        ...rest,
        ref: ref2,
        boxSize: size3,
        css: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          flexGrow: 0,
          ...props25.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/circle.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime(), 1);
var import_react528 = __toESM(require_react(), 1);
var Circle = (0, import_react528.forwardRef)(
  function Circle2(props25, ref2) {
    const { size: size3, ...rest } = props25;
    return (0, import_jsx_runtime248.jsx)(Square, { size: size3, ref: ref2, borderRadius: "9999px", ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/box/span.js
var Span = chakra("span");

// node_modules/@chakra-ui/react/dist/esm/components/box/sticky.js
var Sticky = chakra("div", {
  base: {
    position: "sticky",
    top: 0
  }
});
Sticky.displayName = "Sticky";

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/breadcrumb.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider5,
  withContext: withContext7,
  useStyles: useBreadcrumbStyles,
  PropsProvider: PropsProvider7
} = createSlotRecipeContext({ key: "breadcrumb" });
var BreadcrumbRoot = withProvider5(
  "nav",
  "root",
  {
    defaultProps: { "aria-label": "breadcrumb" }
  }
);
var BreadcrumbPropsProvider = PropsProvider7;
var BreadcrumbList = withContext7(
  "ol",
  "list"
);
var BreadcrumbItem = withContext7(
  "li",
  "item"
);
var BreadcrumbLink = withContext7("a", "link");
var BreadcrumbCurrentLink = withContext7("span", "currentLink", {
  defaultProps: {
    role: "link",
    "aria-current": "page"
  }
});
var BreadcrumbSeparator = withContext7("li", "separator", {
  defaultProps: {
    children: (0, import_jsx_runtime249.jsx)(ChevronRightIcon, {})
  }
});
var BreadcrumbEllipsis = withContext7("span", "ellipsis", {
  defaultProps: {
    role: "presentation",
    "aria-hidden": true,
    children: (0, import_jsx_runtime249.jsx)(EllpsisIcon, {})
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/breadcrumb/namespace.js
var namespace_exports6 = {};
__export(namespace_exports6, {
  CurrentLink: () => BreadcrumbCurrentLink,
  Ellipsis: () => BreadcrumbEllipsis,
  Item: () => BreadcrumbItem,
  Link: () => BreadcrumbLink,
  List: () => BreadcrumbList,
  PropsProvider: () => BreadcrumbPropsProvider,
  Root: () => BreadcrumbRoot,
  Separator: () => BreadcrumbSeparator
});

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var import_jsx_runtime251 = __toESM(require_jsx_runtime(), 1);
var import_react529 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime(), 1);
var React6 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/center/absolute-center.js
var AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        transform: "translateX(-50%)"
      },
      vertical: {
        top: "50%",
        transform: "translateY(-50%)"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";

// node_modules/@chakra-ui/react/dist/esm/components/spinner/spinner.js
var { withContext: withContext8, PropsProvider: PropsProvider8 } = createRecipeContext({
  key: "spinner"
});
var Spinner = withContext8("span");
var SpinnerPropsProvider = PropsProvider8;

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader.js
var Loader = React6.forwardRef(
  function Loader2(props25, ref2) {
    const {
      spinner = (0, import_jsx_runtime250.jsx)(Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
      spinnerPlacement = "start",
      children,
      text,
      visible = true,
      ...rest
    } = props25;
    if (!visible) return children;
    if (text) {
      return (0, import_jsx_runtime250.jsxs)(Span, { ref: ref2, display: "contents", ...rest, children: [
        spinnerPlacement === "start" && spinner,
        text,
        spinnerPlacement === "end" && spinner
      ] });
    }
    if (spinner) {
      return (0, import_jsx_runtime250.jsxs)(Span, { ref: ref2, display: "contents", ...rest, children: [
        (0, import_jsx_runtime250.jsx)(AbsoluteCenter, { display: "inline-flex", children: spinner }),
        (0, import_jsx_runtime250.jsx)(Span, { opacity: 0, children })
      ] });
    }
    return (0, import_jsx_runtime250.jsx)(Span, { ref: ref2, display: "contents", ...rest, children });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button.js
var { useRecipeResult: useRecipeResult2, PropsProvider: PropsProvider9, usePropsContext } = createRecipeContext(
  { key: "button" }
);
var Button = (0, import_react529.forwardRef)(
  function Button2(inProps, ref2) {
    const propsContext = usePropsContext();
    const props25 = (0, import_react529.useMemo)(
      () => mergeProps(propsContext, inProps),
      [propsContext, inProps]
    );
    const result = useRecipeResult2(props25);
    const {
      loading,
      loadingText,
      children,
      spinner,
      spinnerPlacement,
      ...rest
    } = result.props;
    return (0, import_jsx_runtime251.jsx)(
      chakra.button,
      {
        type: "button",
        ref: ref2,
        ...rest,
        disabled: loading || rest.disabled,
        className: cx(result.className, props25.className),
        css: [result.styles, props25.css],
        children: !props25.asChild && loading ? (0, import_jsx_runtime251.jsx)(
          Loader,
          {
            spinner,
            text: loadingText,
            spinnerPlacement,
            children
          }
        ) : children
      }
    );
  }
);
var ButtonPropsProvider = PropsProvider9;

// node_modules/@chakra-ui/react/dist/esm/components/button/icon-button.js
var import_jsx_runtime252 = __toESM(require_jsx_runtime(), 1);
var import_react530 = __toESM(require_react(), 1);
var IconButton = (0, import_react530.forwardRef)(
  function IconButton2(props25, ref2) {
    return (0, import_jsx_runtime252.jsx)(
      Button,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref: ref2,
        ...props25
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button-group.js
var import_jsx_runtime254 = __toESM(require_jsx_runtime(), 1);
var import_react532 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var import_jsx_runtime253 = __toESM(require_jsx_runtime(), 1);
var import_react531 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/utils/attr.js
var dataAttr2 = (condition) => condition ? "" : void 0;

// node_modules/@chakra-ui/react/dist/esm/components/group/group.js
var StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
var Group = (0, import_react531.memo)(
  (0, import_react531.forwardRef)(function Group2(props25, ref2) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap5,
      ...rest
    } = props25;
    const count = import_react531.Children.count(children);
    const _children = (0, import_react531.useMemo)(() => {
      const childArray = import_react531.Children.toArray(children).filter(
        import_react531.isValidElement
      );
      return childArray.map((child, index) => {
        const childProps = child.props;
        return (0, import_react531.cloneElement)(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr2(index === 0),
          "data-last": dataAttr2(index === count - 1),
          "data-between": dataAttr2(index > 0 && index < count - 1),
          style: {
            "--group-count": count,
            "--group-index": index,
            ...(childProps == null ? void 0 : childProps.style) ?? {}
          }
        });
      });
    }, [children, count]);
    return (0, import_jsx_runtime253.jsx)(
      StyledGroup,
      {
        ref: ref2,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap5,
        ...rest,
        children: _children
      }
    );
  })
);

// node_modules/@chakra-ui/react/dist/esm/components/button/button-group.js
var ButtonGroup = (0, import_react532.forwardRef)(
  function ButtonGroup2(props25, ref2) {
    const recipe = useRecipe({ key: "button" });
    const [variantProps, otherProps] = recipe.splitVariantProps(props25);
    return (0, import_jsx_runtime254.jsx)(ButtonPropsProvider, { value: variantProps, children: (0, import_jsx_runtime254.jsx)(Group, { ref: ref2, ...otherProps }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/card/card.js
var {
  withProvider: withProvider6,
  withContext: withContext9,
  useStyles: useCardStyles,
  PropsProvider: PropsProvider10
} = createSlotRecipeContext({ key: "card" });
var CardRoot = withProvider6(
  "div",
  "root"
);
var CardPropsProvider = PropsProvider10;
var CardBody = withContext9(
  "div",
  "body"
);
var CardHeader = withContext9(
  "div",
  "header"
);
var CardFooter = withContext9(
  "div",
  "footer"
);
var CardTitle = withContext9(
  "h3",
  "title"
);
var CardDescription = withContext9("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/card/namespace.js
var namespace_exports7 = {};
__export(namespace_exports7, {
  Body: () => CardBody,
  Description: () => CardDescription,
  Footer: () => CardFooter,
  Header: () => CardHeader,
  PropsProvider: () => CardPropsProvider,
  Root: () => CardRoot,
  Title: () => CardTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/center/center.js
var Center = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    inline: {
      true: {
        display: "inline-flex"
      }
    }
  }
});
Center.displayName = "Center";

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var import_jsx_runtime256 = __toESM(require_jsx_runtime(), 1);
var import_react534 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/checkmark/checkmark.js
var import_jsx_runtime255 = __toESM(require_jsx_runtime(), 1);
var import_react533 = __toESM(require_react(), 1);
var Checkmark = (0, import_react533.forwardRef)(
  function Checkmark2(props25, ref2) {
    const recipe = useRecipe({ key: "checkmark", recipe: props25.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props25);
    const { checked, indeterminate, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime255.jsx)(
      chakra.svg,
      {
        ref: ref2,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "3px",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        "data-state": indeterminate ? "indeterminate" : checked ? "checked" : "unchecked",
        "data-disabled": dataAttr2(disabled),
        css: [styles, props25.css],
        ...rest,
        children: indeterminate ? (0, import_jsx_runtime255.jsx)("path", { d: "M5 12h14" }) : checked ? (0, import_jsx_runtime255.jsx)("polyline", { points: "20 6 9 17 4 12" }) : null
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/checkbox.js
var {
  withProvider: withProvider7,
  withContext: withContext10,
  useStyles: useCheckboxStyles,
  PropsProvider: PropsProvider11
} = createSlotRecipeContext({ key: "checkbox" });
var CheckboxRootProvider2 = withProvider7(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxRoot2 = withProvider7(
  checkbox_exports.Root,
  "root",
  { forwardAsChild: true }
);
var CheckboxPropsProvider = PropsProvider11;
var CheckboxLabel2 = withContext10(
  checkbox_exports.Label,
  "label",
  { forwardAsChild: true }
);
var CheckboxControl2 = withContext10(
  checkbox_exports.Control,
  "control",
  { forwardAsChild: true }
);
var CheckboxIndicator2 = (0, import_react534.forwardRef)(function CheckboxIndicator22(props25, ref2) {
  const { checked, indeterminate, ...rest } = props25;
  const api = useCheckboxContext();
  const styles = useCheckboxStyles();
  if (checked && api.checked) {
    return (0, import_jsx_runtime256.jsx)(
      chakra.svg,
      {
        ref: ref2,
        asChild: true,
        ...rest,
        css: [styles.indicator, props25.css],
        children: checked
      }
    );
  }
  if (indeterminate && api.indeterminate) {
    return (0, import_jsx_runtime256.jsx)(
      chakra.svg,
      {
        ref: ref2,
        asChild: true,
        ...rest,
        css: [styles.indicator, props25.css],
        children: indeterminate
      }
    );
  }
  return (0, import_jsx_runtime256.jsx)(
    Checkmark,
    {
      ref: ref2,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...rest,
      css: [styles.indicator, props25.css]
    }
  );
});
var CheckboxGroup2 = chakra(
  checkbox_exports.Group,
  {
    base: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    }
  },
  { forwardAsChild: true }
);
var CheckboxContext2 = checkbox_exports.Context;
var CheckboxHiddenInput2 = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox/namespace.js
var namespace_exports8 = {};
__export(namespace_exports8, {
  Context: () => CheckboxContext2,
  Control: () => CheckboxControl2,
  Group: () => CheckboxGroup2,
  HiddenInput: () => CheckboxHiddenInput2,
  Indicator: () => CheckboxIndicator2,
  Label: () => CheckboxLabel2,
  PropsProvider: () => CheckboxPropsProvider,
  Root: () => CheckboxRoot2,
  RootProvider: () => CheckboxRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/checkbox-card.js
var import_jsx_runtime257 = __toESM(require_jsx_runtime(), 1);
var import_react535 = __toESM(require_react(), 1);
var {
  withProvider: withProvider8,
  withContext: withContext11,
  useStyles: useCheckboxCardStyles,
  PropsProvider: PropsProvider12
} = createSlotRecipeContext({ key: "checkboxCard" });
var CheckboxCardRootProvider = withProvider8(checkbox_exports.RootProvider, "root", { forwardAsChild: true });
var CheckboxCardRoot = withProvider8(checkbox_exports.Root, "root", { forwardAsChild: true });
var CheckboxCardRootPropsProvider = PropsProvider12;
var CheckboxCardLabel = withContext11(checkbox_exports.Label, "label", { forwardAsChild: true });
var CheckboxCardDescription = withContext11("div", "description");
var CheckboxCardControl = withContext11(checkbox_exports.Control, "control", { forwardAsChild: true });
var CheckboxCardContent = withContext11("div", "content");
var CheckboxCardIndicator = (0, import_react535.forwardRef)(function CheckboxCardIndicator2(props25, ref2) {
  const api = useCheckboxContext();
  const styles = useCheckboxCardStyles();
  return (0, import_jsx_runtime257.jsx)(
    Checkmark,
    {
      ref: ref2,
      checked: api.checked,
      indeterminate: api.indeterminate,
      disabled: api.disabled,
      unstyled: true,
      ...props25,
      css: [styles.indicator, props25.css]
    }
  );
});
var CheckboxCardAddon = withContext11("div", "addon");
var CheckboxCardContext = checkbox_exports.Context;
var CheckboxCardHiddenInput = checkbox_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/checkbox-card/namespace.js
var namespace_exports9 = {};
__export(namespace_exports9, {
  Addon: () => CheckboxCardAddon,
  Content: () => CheckboxCardContent,
  Context: () => CheckboxCardContext,
  Control: () => CheckboxCardControl,
  Description: () => CheckboxCardDescription,
  HiddenInput: () => CheckboxCardHiddenInput,
  Indicator: () => CheckboxCardIndicator,
  Label: () => CheckboxCardLabel,
  Root: () => CheckboxCardRoot,
  RootPropsProvider: () => CheckboxCardRootPropsProvider,
  RootProvider: () => CheckboxCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var import_jsx_runtime259 = __toESM(require_jsx_runtime(), 1);
var import_react537 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/show/show.js
var import_jsx_runtime258 = __toESM(require_jsx_runtime(), 1);
var import_react536 = __toESM(require_react(), 1);
function Show(props25) {
  const { when, fallback: fallback3, children } = props25;
  let result;
  if (!when) {
    result = fallback3;
  } else {
    result = typeof children === "function" ? children(when) : children;
  }
  return (0, import_react536.isValidElement)(result) ? result : (0, import_jsx_runtime258.jsx)(import_jsx_runtime258.Fragment, { children: result });
}

// node_modules/@chakra-ui/react/dist/esm/components/client-only/client-only.js
var ClientOnly = (props25) => {
  const { children, fallback: fallback3 } = props25;
  const [hasMounted, setHasMounted] = (0, import_react537.useState)(false);
  (0, import_react537.useEffect)(() => {
    setHasMounted(true);
  }, []);
  return (0, import_jsx_runtime259.jsx)(Show, { when: hasMounted, fallback: fallback3, children });
};

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard-context.js
var [ClipboardProvider, useClipboardContext] = createContext3({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-context.js
var ClipboardContext = (props25) => props25.children(useClipboardContext());

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-control.js
var import_jsx_runtime260 = __toESM(require_jsx_runtime(), 1);
var import_react539 = __toESM(require_react(), 1);
var ClipboardControl = (0, import_react539.forwardRef)((props25, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getControlProps(), props25);
  return (0, import_jsx_runtime260.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ClipboardControl.displayName = "ClipboardControl";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-indicator.js
var import_jsx_runtime261 = __toESM(require_jsx_runtime(), 1);
var import_react541 = __toESM(require_react(), 1);
var ClipboardIndicator = (0, import_react541.forwardRef)(
  (props25, ref2) => {
    const { children, copied, ...localProps } = props25;
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps2(
      clipboard.getIndicatorProps({ copied: clipboard.copied }),
      localProps
    );
    return (0, import_jsx_runtime261.jsx)(ark.div, { ...mergedProps, ref: ref2, children: clipboard.copied ? copied : children });
  }
);
ClipboardIndicator.displayName = "ClipboardIndicator";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-input.js
var import_jsx_runtime262 = __toESM(require_jsx_runtime(), 1);
var import_react543 = __toESM(require_react(), 1);
var ClipboardInput = (0, import_react543.forwardRef)((props25, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getInputProps(), props25);
  return (0, import_jsx_runtime262.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
ClipboardInput.displayName = "ClipboardInput";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-label.js
var import_jsx_runtime263 = __toESM(require_jsx_runtime(), 1);
var import_react545 = __toESM(require_react(), 1);
var ClipboardLabel = (0, import_react545.forwardRef)((props25, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps2(clipboard.getLabelProps(), props25);
  return (0, import_jsx_runtime263.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ClipboardLabel.displayName = "ClipboardLabel";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var import_jsx_runtime264 = __toESM(require_jsx_runtime(), 1);
var import_react549 = __toESM(require_react(), 1);

// node_modules/@zag-js/clipboard/dist/index.mjs
var anatomy23 = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts26 = anatomy23.build();
var dom23 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `clip:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `clip:${ctx.id}:input`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `clip:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom23.getById(ctx, dom23.getInputId(ctx)),
  writeToClipboard: (ctx) => copyText(dom23.getDoc(ctx), ctx.value)
});
function createNode(doc, text) {
  const node2 = doc.createElement("pre");
  Object.assign(node2.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node2.textContent = text;
  return node2;
}
function copyNode(node2) {
  const win = getWindow(node2);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node2.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node2);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  var _a8;
  const win = doc.defaultView || window;
  if (((_a8 = win.navigator.clipboard) == null ? void 0 : _a8.writeText) !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node2 = createNode(doc, text);
  doc.body.appendChild(node2);
  copyNode(node2);
  doc.body.removeChild(node2);
  return Promise.resolve();
}
function connect23(state2, send, normalize2) {
  const copied = state2.matches("copied");
  return {
    copied,
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts26.root.attrs,
        "data-copied": dataAttr(copied),
        id: dom23.getRootId(state2.context)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts26.label.attrs,
        htmlFor: dom23.getInputId(state2.context),
        "data-copied": dataAttr(copied),
        id: dom23.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts26.control.attrs,
        "data-copied": dataAttr(copied)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts26.input.attrs,
        defaultValue: state2.context.value,
        "data-copied": dataAttr(copied),
        readOnly: true,
        "data-readonly": "true",
        id: dom23.getInputId(state2.context),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts26.trigger.attrs,
        type: "button",
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props25) {
      return normalize2.element({
        ...parts26.indicator.attrs,
        hidden: props25.copied !== copied
      });
    }
  };
}
function machine23(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "clipboard",
      initial: "idle",
      context: {
        value: "",
        timeout: 3e3,
        ...ctx
      },
      watch: {
        value: ["syncInputElement"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.COPY": {
              target: "copied",
              actions: ["invokeOnCopy"]
            }
          }
        },
        copied: {
          after: {
            COPY_TIMEOUT: "idle"
          },
          on: {
            COPY: {
              target: "copied",
              actions: ["copyToClipboard", "invokeOnCopy"]
            },
            "INPUT.COPY": {
              actions: ["invokeOnCopy"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        copyToClipboard(ctx2) {
          dom23.writeToClipboard(ctx2);
        },
        invokeOnCopy(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { copied: true });
        },
        syncInputElement(ctx2) {
          dom23.setValue(dom23.getInputEl(ctx2), ctx2.value);
        }
      },
      delays: {
        COPY_TIMEOUT: (ctx2) => ctx2.timeout
      }
    }
  );
}
var props21 = createProps()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "timeout",
  "onStatusChange"
]);
var contextProps = createSplitProps(props21);
var indicatorProps = createProps()(["copied"]);
var splitIndicatorProps = createSplitProps(indicatorProps);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard.js
var import_react547 = __toESM(require_react(), 1);
var useClipboard = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react547.useId)(),
    getRootNode,
    ...props25
  };
  const context = {
    ...initialContext
  };
  const [state2, send] = useMachine(machine23(initialContext), { context });
  return connect23(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var ClipboardRoot = (0, import_react549.forwardRef)((props25, ref2) => {
  const [useClipboardProps, localProps] = createSplitProps2()(props25, [
    "id",
    "ids",
    "onStatusChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps2(clipboard.getRootProps(), localProps);
  return (0, import_jsx_runtime264.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime264.jsx)(ark.div, { ref: ref2, ...mergedProps }) });
});
ClipboardRoot.displayName = "ClipboardRoot";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root-provider.js
var import_jsx_runtime265 = __toESM(require_jsx_runtime(), 1);
var import_react551 = __toESM(require_react(), 1);
var ClipboardRootProvider = (0, import_react551.forwardRef)(
  (props25, ref2) => {
    const [{ value: clipboard }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(clipboard.getRootProps(), localProps);
    return (0, import_jsx_runtime265.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime265.jsx)(ark.div, { ref: ref2, ...mergedProps }) });
  }
);
ClipboardRootProvider.displayName = "ClipboardRootProvider";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-trigger.js
var import_jsx_runtime266 = __toESM(require_jsx_runtime(), 1);
var import_react553 = __toESM(require_react(), 1);
var ClipboardTrigger = (0, import_react553.forwardRef)(
  (props25, ref2) => {
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps2(clipboard.getTriggerProps(), props25);
    return (0, import_jsx_runtime266.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ClipboardTrigger.displayName = "ClipboardTrigger";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-value-text.js
var import_jsx_runtime267 = __toESM(require_jsx_runtime(), 1);
var import_react554 = __toESM(require_react(), 1);
var ClipboardValueText = (0, import_react554.forwardRef)(
  (props25, ref2) => {
    const clipboard = useClipboardContext();
    return (0, import_jsx_runtime267.jsx)(ark.span, { ...props25, ref: ref2, children: props25.children || clipboard.value });
  }
);
ClipboardValueText.displayName = "ClipboardValueText";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard.js
var clipboard_exports = {};
__export(clipboard_exports, {
  Context: () => ClipboardContext,
  Control: () => ClipboardControl,
  Indicator: () => ClipboardIndicator,
  Input: () => ClipboardInput,
  Label: () => ClipboardLabel,
  Root: () => ClipboardRoot,
  RootProvider: () => ClipboardRootProvider,
  Trigger: () => ClipboardTrigger,
  ValueText: () => ClipboardValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/clipboard.js
var {
  withProvider: withProvider9,
  withContext: withContext12,
  useStyles: useClipboardStyles,
  PropsProvider: PropsProvider13
} = createSlotRecipeContext({ key: "clipboard" });
var ClipboardRootProvider2 = withProvider9(clipboard_exports.RootProvider, "root", { forwardAsChild: true });
var ClipboardRoot2 = withProvider9(
  clipboard_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ClipboardPropsProvider = PropsProvider13;
var ClipboardTrigger2 = withContext12(clipboard_exports.Trigger, "trigger", { forwardAsChild: true });
var ClipboardControl2 = withContext12(clipboard_exports.Control, "control", { forwardAsChild: true });
var ClipboardIndicator2 = withContext12(clipboard_exports.Indicator, "indicator", { forwardAsChild: true });
var ClipboardInput2 = withContext12(clipboard_exports.Input, "input", { forwardAsChild: true });
var ClipboardLabel2 = withContext12(clipboard_exports.Label, "label", { forwardAsChild: true });
var ClipboardContext2 = clipboard_exports.Context;
var ClipboardValueText2 = withContext12(clipboard_exports.ValueText, "valueText", { forwardAsChild: true });

// node_modules/@chakra-ui/react/dist/esm/components/clipboard/namespace.js
var namespace_exports10 = {};
__export(namespace_exports10, {
  Context: () => ClipboardContext2,
  Control: () => ClipboardControl2,
  Indicator: () => ClipboardIndicator2,
  Input: () => ClipboardInput2,
  Label: () => ClipboardLabel2,
  PropsProvider: () => ClipboardPropsProvider,
  Root: () => ClipboardRoot2,
  RootProvider: () => ClipboardRootProvider2,
  Trigger: () => ClipboardTrigger2,
  ValueText: () => ClipboardValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/code/code.js
var { withContext: withContext13, PropsProvider: PropsProvider14 } = createRecipeContext({
  key: "code"
});
var Code = withContext13("code");
var CodePropsProvider = PropsProvider14;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/collapsible.js
var {
  withProvider: withProvider10,
  withContext: withContext14,
  useStyles: useCollapsibleStyles,
  PropsProvider: PropsProvider15
} = createSlotRecipeContext({ key: "collapsible" });
var CollapsibleRootProvider2 = withProvider10(collapsible_exports.RootProvider, "root", { forwardAsChild: true });
var CollapsibleRoot2 = withProvider10(collapsible_exports.Root, "root", { forwardAsChild: true });
var CollapsiblePropsProvider = PropsProvider15;
var CollapsibleTrigger2 = withContext14(collapsible_exports.Trigger, "trigger", { forwardAsChild: true });
var CollapsibleContent2 = withContext14(collapsible_exports.Content, "content", { forwardAsChild: true });
var CollapsibleContext2 = collapsible_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/collapsible/namespace.js
var namespace_exports11 = {};
__export(namespace_exports11, {
  Content: () => CollapsibleContent2,
  Context: () => CollapsibleContext2,
  PropsProvider: () => CollapsiblePropsProvider,
  Root: () => CollapsibleRoot2,
  RootProvider: () => CollapsibleRootProvider2,
  Trigger: () => CollapsibleTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/color-picker.js
var {
  withProvider: withProvider11,
  withContext: withContext15,
  useStyles: useColorPickerStyles,
  PropsProvider: PropsProvider16
} = createSlotRecipeContext({ key: "colorPicker" });
var ColorPickerRootProvider2 = withProvider11(color_picker_exports.RootProvider, "root", { forwardAsChild: true });
var ColorPickerRoot2 = withProvider11(color_picker_exports.Root, "root", { forwardAsChild: true });
var ColorPickerPropsProvider = PropsProvider16;
var ColorPickerLabel2 = withContext15(color_picker_exports.Label, "label", { forwardAsChild: true });
var ColorPickerControl2 = withContext15(color_picker_exports.Control, "control", { forwardAsChild: true });
var ColorPickerTrigger2 = withContext15(color_picker_exports.Trigger, "trigger", { forwardAsChild: true });
var ColorPickerPositioner2 = withContext15(color_picker_exports.Positioner, "positioner", { forwardAsChild: true });
var ColorPickerContent2 = withContext15(color_picker_exports.Content, "content", { forwardAsChild: true });
var ColorPickerArea2 = withContext15(color_picker_exports.Area, "area", { forwardAsChild: true });
var ColorPickerAreaBackground2 = withContext15(color_picker_exports.AreaBackground, "areaBackground", { forwardAsChild: true });
var ColorPickerAreaThumb2 = withContext15(color_picker_exports.AreaThumb, "areaThumb", { forwardAsChild: true });
var ColorPickerChannelSlider2 = withContext15(color_picker_exports.ChannelSlider, "channelSlider", { forwardAsChild: true });
var ColorPickerChannelSliderTrack2 = withContext15(color_picker_exports.ChannelSliderTrack, "channelSliderTrack", {
  forwardAsChild: true
});
var ColorPickerChannelSliderThumb2 = withContext15(color_picker_exports.ChannelSliderThumb, "channelSliderThumb", {
  forwardAsChild: true
});
var ColorPickerChannelInput2 = withContext15(color_picker_exports.ChannelInput, "channelInput", { forwardAsChild: true });
var ColorPickerTransparencyGrid2 = withContext15(color_picker_exports.TransparencyGrid, "transparencyGrid", { forwardAsChild: true });
var ColorPickerSwatchGroup2 = withContext15(color_picker_exports.SwatchGroup, "swatchGroup", { forwardAsChild: true });
var ColorPickerSwatchTrigger2 = withContext15(color_picker_exports.SwatchTrigger, "swatchTrigger", { forwardAsChild: true });
var ColorPickerSwatch2 = withContext15(color_picker_exports.Swatch, "swatch", { forwardAsChild: true });
var ColorPickerSwatchIndicator2 = withContext15(color_picker_exports.SwatchIndicator, "swatchIndicator", { forwardAsChild: true });
var ColorPickerValueText2 = withContext15(color_picker_exports.ValueText, "valueText", { forwardAsChild: true });
var ColorPickerValueSwatch2 = withContext15(color_picker_exports.ValueSwatch, "swatch", { forwardAsChild: true });
var ColorPickerView2 = withContext15(color_picker_exports.View, "view", { forwardAsChild: true });
var ColorPickerFormatTrigger2 = withContext15(color_picker_exports.FormatTrigger, "formatTrigger", { forwardAsChild: true });
var ColorPickerFormatSelect2 = withContext15(color_picker_exports.FormatSelect, "formatSelect", { forwardAsChild: true });
var ColorPickerEyeDropperTrigger2 = withContext15(color_picker_exports.EyeDropperTrigger, "eyeDropperTrigger", {
  forwardAsChild: true
});
var ColorPickerChannelSliderValueText2 = withContext15(color_picker_exports.ChannelSliderValueText, "channelSliderValueText", {
  forwardAsChild: true
});
var ColorPickerChannelSliderLabel2 = withContext15(color_picker_exports.ChannelSliderLabel, "channelSliderLabel", {
  forwardAsChild: true
});
var ColorPickerHiddenInput2 = color_picker_exports.HiddenInput;
var ColorPickerContext2 = color_picker_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/color-picker/namespace.js
var namespace_exports12 = {};
__export(namespace_exports12, {
  Area: () => ColorPickerArea2,
  AreaBackground: () => ColorPickerAreaBackground2,
  AreaThumb: () => ColorPickerAreaThumb2,
  ChannelInput: () => ColorPickerChannelInput2,
  ChannelSlider: () => ColorPickerChannelSlider2,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel2,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb2,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack2,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText2,
  Content: () => ColorPickerContent2,
  Context: () => ColorPickerContext2,
  Control: () => ColorPickerControl2,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger2,
  FormatSelect: () => ColorPickerFormatSelect2,
  FormatTrigger: () => ColorPickerFormatTrigger2,
  HiddenInput: () => ColorPickerHiddenInput2,
  Label: () => ColorPickerLabel2,
  Positioner: () => ColorPickerPositioner2,
  PropsProvider: () => ColorPickerPropsProvider,
  Root: () => ColorPickerRoot2,
  RootProvider: () => ColorPickerRootProvider2,
  Swatch: () => ColorPickerSwatch2,
  SwatchGroup: () => ColorPickerSwatchGroup2,
  SwatchIndicator: () => ColorPickerSwatchIndicator2,
  SwatchTrigger: () => ColorPickerSwatchTrigger2,
  TransparencyGrid: () => ColorPickerTransparencyGrid2,
  Trigger: () => ColorPickerTrigger2,
  ValueSwatch: () => ColorPickerValueSwatch2,
  ValueText: () => ColorPickerValueText2,
  View: () => ColorPickerView2
});

// node_modules/@chakra-ui/react/dist/esm/components/container/container.js
var { withContext: withContext16, PropsProvider: PropsProvider17 } = createRecipeContext({
  key: "container"
});
var Container = withContext16("div");
var ContainerPropsProvider = PropsProvider17;

// node_modules/@chakra-ui/react/dist/esm/components/data-list/data-list.js
var {
  withProvider: withProvider12,
  withContext: withContext17,
  useStyles: useDataListStyles,
  PropsProvider: PropsProvider18
} = createSlotRecipeContext({ key: "dataList" });
var DataListRoot = withProvider12(
  "dl",
  "root"
);
var DataListPropsProvider = PropsProvider18;
var DataListItem = withContext17(
  "div",
  "item"
);
var DataListItemLabel = withContext17("dt", "itemLabel");
var DataListItemValue = withContext17("dd", "itemValue");

// node_modules/@chakra-ui/react/dist/esm/components/data-list/namespace.js
var namespace_exports13 = {};
__export(namespace_exports13, {
  Item: () => DataListItem,
  ItemLabel: () => DataListItemLabel,
  ItemValue: () => DataListItemValue,
  PropsProvider: () => DataListPropsProvider,
  Root: () => DataListRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/dialog/dialog.js
var import_jsx_runtime268 = __toESM(require_jsx_runtime(), 1);
var import_react555 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider2,
  withContext: withContext18,
  useStyles: useDialogStyles,
  PropsProvider: PropsProvider19
} = createSlotRecipeContext({ key: "dialog" });
var DialogRootProvider2 = withRootProvider2(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DialogRoot2 = withRootProvider2(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DialogPropsProvider = PropsProvider19;
var DialogTrigger2 = withContext18(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DialogPositioner2 = withContext18(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DialogContent2 = withContext18(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DialogDescription2 = withContext18(dialog_exports.Description, "description", { forwardAsChild: true });
var DialogTitle2 = withContext18(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DialogCloseTrigger2 = withContext18(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DialogActionTrigger = (0, import_react555.forwardRef)(function DialogActionTrigger2(props25, ref2) {
  const dialog = useDialogContext();
  return (0, import_jsx_runtime268.jsx)(chakra.button, { ...props25, ref: ref2, onClick: () => dialog.setOpen(false) });
});
var DialogBackdrop2 = withContext18(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DialogBody = withContext18(
  "div",
  "body"
);
var DialogFooter = withContext18(
  "div",
  "footer"
);
var DialogHeader = withContext18(
  "div",
  "header"
);
var DialogContext2 = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/dialog/namespace.js
var namespace_exports14 = {};
__export(namespace_exports14, {
  ActionTrigger: () => DialogActionTrigger,
  Backdrop: () => DialogBackdrop2,
  Body: () => DialogBody,
  CloseTrigger: () => DialogCloseTrigger2,
  Content: () => DialogContent2,
  Context: () => DialogContext2,
  Description: () => DialogDescription2,
  Footer: () => DialogFooter,
  Header: () => DialogHeader,
  Positioner: () => DialogPositioner2,
  PropsProvider: () => DialogPropsProvider,
  Root: () => DialogRoot2,
  RootProvider: () => DialogRootProvider2,
  Title: () => DialogTitle2,
  Trigger: () => DialogTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/drawer/drawer.js
var import_jsx_runtime269 = __toESM(require_jsx_runtime(), 1);
var import_react556 = __toESM(require_react(), 1);
var {
  withRootProvider: withRootProvider3,
  withContext: withContext19,
  useStyles: useDrawerStyles,
  PropsProvider: PropsProvider20
} = createSlotRecipeContext({ key: "drawer" });
var DrawerRootProvider = withRootProvider3(
  dialog_exports.RootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
var DrawerRoot = withRootProvider3(dialog_exports.Root, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
var DrawerRootPropsProvider = PropsProvider20;
var DrawerTrigger = withContext19(
  dialog_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var DrawerPositioner = withContext19(dialog_exports.Positioner, "positioner", { forwardAsChild: true });
var DrawerContent = withContext19(
  dialog_exports.Content,
  "content",
  { forwardAsChild: true }
);
var DrawerDescription = withContext19(dialog_exports.Description, "description", { forwardAsChild: true });
var DrawerTitle = withContext19(
  dialog_exports.Title,
  "title",
  { forwardAsChild: true }
);
var DrawerCloseTrigger = withContext19(dialog_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var DrawerActionTrigger = (0, import_react556.forwardRef)(function DrawerActionTrigger2(props25, ref2) {
  const drawer = useDialogContext();
  return (0, import_jsx_runtime269.jsx)(chakra.button, { ...props25, ref: ref2, onClick: () => drawer.setOpen(false) });
});
var DrawerBackdrop = withContext19(
  dialog_exports.Backdrop,
  "backdrop",
  { forwardAsChild: true }
);
var DrawerBody = withContext19(
  "div",
  "body"
);
var DrawerFooter = withContext19(
  "div",
  "footer"
);
var DrawerHeader = withContext19(
  "div",
  "header"
);
var DrawerContext = dialog_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/drawer/namespace.js
var namespace_exports15 = {};
__export(namespace_exports15, {
  ActionTrigger: () => DrawerActionTrigger,
  Backdrop: () => DrawerBackdrop,
  Body: () => DrawerBody,
  CloseTrigger: () => DrawerCloseTrigger,
  Content: () => DrawerContent,
  Context: () => DrawerContext,
  Description: () => DrawerDescription,
  Footer: () => DrawerFooter,
  Header: () => DrawerHeader,
  Positioner: () => DrawerPositioner,
  Root: () => DrawerRoot,
  RootPropsProvider: () => DrawerRootPropsProvider,
  RootProvider: () => DrawerRootProvider,
  Title: () => DrawerTitle,
  Trigger: () => DrawerTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/editable/editable.js
var import_jsx_runtime270 = __toESM(require_jsx_runtime(), 1);
var import_react557 = __toESM(require_react(), 1);
var {
  withProvider: withProvider13,
  withContext: withContext20,
  useStyles: useEditableStyles,
  PropsProvider: PropsProvider21
} = createSlotRecipeContext({ key: "editable" });
var EditableRootProvider2 = withProvider13(editable_exports.RootProvider, "root", { forwardAsChild: true });
var EditableRoot2 = withProvider13(
  editable_exports.Root,
  "root",
  { forwardAsChild: true }
);
var EditablePropsProvider = PropsProvider21;
var EditablePreview2 = withContext20(editable_exports.Preview, "preview", { forwardAsChild: true });
var EditableInput2 = withContext20(
  editable_exports.Input,
  "input",
  { forwardAsChild: true }
);
var ArkEditableTextarea = (0, import_react557.forwardRef)(function EditableTextarea2(props25, ref2) {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getInputProps(), props25);
  return (0, import_jsx_runtime270.jsx)(ark.textarea, { ref: ref2, ...mergedProps });
});
var EditableTextarea = withContext20(ArkEditableTextarea, "input", { forwardAsChild: true });
var EditableControl2 = withContext20(editable_exports.Control, "control", { forwardAsChild: true });
var EditableArea2 = withContext20(
  editable_exports.Area,
  "area",
  { forwardAsChild: true }
);
var EditableEditTrigger2 = withContext20(editable_exports.EditTrigger, "editTrigger", { forwardAsChild: true });
var EditableSubmitTrigger2 = withContext20(editable_exports.SubmitTrigger, "submitTrigger", { forwardAsChild: true });
var EditableCancelTrigger2 = withContext20(editable_exports.CancelTrigger, "cancelTrigger", { forwardAsChild: true });
var EditableContext2 = editable_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/editable/namespace.js
var namespace_exports16 = {};
__export(namespace_exports16, {
  Area: () => EditableArea2,
  CancelTrigger: () => EditableCancelTrigger2,
  Context: () => EditableContext2,
  Control: () => EditableControl2,
  EditTrigger: () => EditableEditTrigger2,
  Input: () => EditableInput2,
  Preview: () => EditablePreview2,
  PropsProvider: () => EditablePropsProvider,
  Root: () => EditableRoot2,
  RootProvider: () => EditableRootProvider2,
  SubmitTrigger: () => EditableSubmitTrigger2,
  Textarea: () => EditableTextarea
});

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/empty-state.js
var {
  withProvider: withProvider14,
  withContext: withContext21,
  useStyles: useEmptyStateStyles,
  PropsProvider: PropsProvider22
} = createSlotRecipeContext({ key: "emptyState" });
var EmptyStateRoot = withProvider14(
  "div",
  "root"
);
var EmptyStatePropsProvider = PropsProvider22;
var EmptyStateContent = withContext21("div", "content");
var EmptyStateIndicator = withContext21("div", "indicator");
var EmptyStateTitle = withContext21("h3", "title");
var EmptyStateDescription = withContext21("p", "description");

// node_modules/@chakra-ui/react/dist/esm/components/empty-state/namespace.js
var namespace_exports17 = {};
__export(namespace_exports17, {
  Content: () => EmptyStateContent,
  Description: () => EmptyStateDescription,
  Indicator: () => EmptyStateIndicator,
  PropsProvider: () => EmptyStatePropsProvider,
  Root: () => EmptyStateRoot,
  Title: () => EmptyStateTitle
});

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var import_jsx_runtime271 = __toESM(require_jsx_runtime(), 1);
var import_react558 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/run-if-fn.js
var isFunction3 = (value) => typeof value === "function";
var runIfFn2 = (valueOrFn, ...args) => isFunction3(valueOrFn) ? valueOrFn(...args) : valueOrFn;

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var EnvironmentProvider = (props25) => {
  const { value, children } = props25;
  const [spanRef, setSpanRef] = (0, import_react558.useState)();
  const getRootNode = (0, import_react558.useMemo)(() => {
    return () => runIfFn2(value) ?? (spanRef == null ? void 0 : spanRef.ownerDocument) ?? document;
  }, [value, spanRef]);
  const environment = (0, import_react558.useMemo)(
    () => ({
      getRootNode,
      getWindow: () => getWindow(getRootNode()),
      getDocument: () => getDocument(getRootNode())
    }),
    [getRootNode]
  );
  return (0, import_jsx_runtime271.jsxs)(EnvironmentContextProvider, { value: environment, children: [
    children,
    !value && (0, import_jsx_runtime271.jsx)("span", { hidden: true, ref: setSpanRef })
  ] });
};

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var import_jsx_runtime274 = __toESM(require_jsx_runtime(), 1);
var import_react560 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
var import_jsx_runtime273 = __toESM(require_jsx_runtime(), 1);
var import_react559 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/icon/icon.js
var import_jsx_runtime272 = __toESM(require_jsx_runtime(), 1);
var React7 = __toESM(require_react(), 1);
var { useRecipeResult: useRecipeResult3, PropsProvider: PropsProvider23 } = createRecipeContext({ key: "icon" });
var Icon = React7.forwardRef(
  function Icon2(props25, ref2) {
    const {
      styles,
      className,
      props: otherProps
    } = useRecipeResult3({ asChild: !props25.as, ...props25 });
    return (0, import_jsx_runtime272.jsx)(
      chakra.svg,
      {
        ref: ref2,
        focusable: false,
        "aria-hidden": "true",
        ...otherProps,
        css: [styles, props25.css],
        className: cx(className, props25.className)
      }
    );
  }
);
var IconPropsProvider = PropsProvider23;

// node_modules/@chakra-ui/react/dist/esm/components/icon/create-icon.js
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path = import_react559.Children.toArray(options.path);
  const Comp = (0, import_react559.forwardRef)((props25, ref2) => (0, import_jsx_runtime273.jsx)(
    Icon,
    {
      ref: ref2,
      asChild: false,
      viewBox,
      ...defaultProps,
      ...props25,
      children: path.length ? path : (0, import_jsx_runtime273.jsx)("path", { fill: "currentColor", d: pathDefinition })
    }
  ));
  Comp.displayName = displayName;
  return Comp;
}

// node_modules/@chakra-ui/react/dist/esm/components/field/field.js
var {
  withProvider: withProvider15,
  withContext: withContext22,
  useStyles: useFieldStyles,
  useClassNames,
  PropsProvider: PropsProvider24
} = createSlotRecipeContext({ key: "field" });
var FieldRoot2 = withProvider15(
  field_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FieldPropsProvider = PropsProvider24;
var FieldLabel2 = withContext22(
  field_exports.Label,
  "label",
  { forwardAsChild: true }
);
var FieldHelperText2 = withContext22(field_exports.HelperText, "helperText", { forwardAsChild: true });
var FieldErrorText2 = withContext22(
  field_exports.ErrorText,
  "errorText",
  { forwardAsChild: true }
);
var FieldErrorIcon = createIcon({
  d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
});
var FieldRequiredIndicator2 = (0, import_react560.forwardRef)(function RequiredIndicator(props25, ref2) {
  const { fallback: fallback3, children = "*", ...restProps } = props25;
  const field = useFieldContext();
  const classNames = useClassNames();
  const styles = useFieldStyles();
  if (!(field == null ? void 0 : field.required)) {
    return fallback3;
  }
  return (0, import_jsx_runtime274.jsx)(
    chakra.span,
    {
      ref: ref2,
      "aria-hidden": "true",
      ...restProps,
      className: cx(classNames.requiredIndicator, props25.className),
      css: [styles.requiredIndicator, props25.css],
      children
    }
  );
});

// node_modules/@chakra-ui/react/dist/esm/components/field/namespace.js
var namespace_exports18 = {};
__export(namespace_exports18, {
  ErrorIcon: () => FieldErrorIcon,
  ErrorText: () => FieldErrorText2,
  HelperText: () => FieldHelperText2,
  Label: () => FieldLabel2,
  PropsProvider: () => FieldPropsProvider,
  RequiredIndicator: () => FieldRequiredIndicator2,
  Root: () => FieldRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/fieldset.js
var { withProvider: withProvider16, withContext: withContext23 } = createSlotRecipeContext({
  key: "fieldset"
});
var FieldsetRoot2 = withProvider16(fieldset_exports.Root, "root");
var FieldsetErrorText2 = withContext23(fieldset_exports.ErrorText, "errorText");
var FieldsetHelperText2 = withContext23(fieldset_exports.HelperText, "helperText");
var FieldsetLegend2 = withContext23(fieldset_exports.Legend, "legend");
var FieldsetContent = withContext23(ark.div, "content");
var FieldsetContext2 = fieldset_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/fieldset/namespace.js
var namespace_exports19 = {};
__export(namespace_exports19, {
  Content: () => FieldsetContent,
  Context: () => FieldsetContext2,
  ErrorText: () => FieldsetErrorText2,
  HelperText: () => FieldsetHelperText2,
  Legend: () => FieldsetLegend2,
  Root: () => FieldsetRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/file-upload.js
var import_jsx_runtime275 = __toESM(require_jsx_runtime(), 1);
var import_react561 = __toESM(require_react(), 1);
var {
  withProvider: withProvider17,
  withContext: withContext24,
  useStyles: useFileUploadStyles,
  PropsProvider: PropsProvider25
} = createSlotRecipeContext({ key: "fileUpload" });
var FileUploadRootProvider2 = withProvider17(file_upload_exports.RootProvider, "root", { forwardAsChild: true });
var FileUploadRoot2 = withProvider17(
  file_upload_exports.Root,
  "root",
  { forwardAsChild: true }
);
var FileUploadPropsProvider = PropsProvider25;
var FileUploadClearTrigger2 = (0, import_react561.forwardRef)(function FileUploadClearTrigger22(props25, ref2) {
  const fileUpload = useFileUploadContext();
  return (0, import_jsx_runtime275.jsx)(
    chakra.button,
    {
      ref: ref2,
      type: "button",
      "data-scope": "file-upload",
      "data-part": "clear-trigger",
      "aria-label": "Clear selected files",
      hidden: fileUpload.acceptedFiles.length === 0,
      ...props25,
      onClick: (event) => {
        var _a8;
        (_a8 = props25.onClick) == null ? void 0 : _a8.call(props25, event);
        if (event.defaultPrevented) return;
        fileUpload.clearFiles();
      }
    }
  );
});
var FileUploadDropzone2 = withContext24(file_upload_exports.Dropzone, "dropzone", { forwardAsChild: true });
var FileUploadDropzoneContent = withContext24("div", "dropzoneContent");
var FileUploadItem2 = withContext24(
  file_upload_exports.Item,
  "item",
  { forwardAsChild: true }
);
var FileUploadItemContent = withContext24("div", "itemContent");
var FileUploadItemDeleteTrigger2 = withContext24(file_upload_exports.ItemDeleteTrigger, "itemDeleteTrigger", {
  forwardAsChild: true
});
var FileUploadItemGroup2 = withContext24(file_upload_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var FileUploadItemName2 = withContext24(file_upload_exports.ItemName, "itemName", { forwardAsChild: true });
var FileUploadItemPreview2 = withContext24(file_upload_exports.ItemPreview, "itemPreview", { forwardAsChild: true });
var FileUploadItemPreviewImage2 = withContext24(file_upload_exports.ItemPreviewImage, "itemPreviewImage", { forwardAsChild: true });
var FileUploadItemSizeText2 = withContext24(file_upload_exports.ItemSizeText, "itemSizeText", { forwardAsChild: true });
var FileUploadLabel2 = withContext24(file_upload_exports.Label, "label", { forwardAsChild: true });
var FileUploadTrigger2 = withContext24(file_upload_exports.Trigger, "trigger", { forwardAsChild: true });
var FileUploadContext2 = file_upload_exports.Context;
var FileUploadHiddenInput2 = file_upload_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/file-upload/namespace.js
var namespace_exports20 = {};
__export(namespace_exports20, {
  ClearTrigger: () => FileUploadClearTrigger2,
  Context: () => FileUploadContext2,
  Dropzone: () => FileUploadDropzone2,
  DropzoneContent: () => FileUploadDropzoneContent,
  HiddenInput: () => FileUploadHiddenInput2,
  Item: () => FileUploadItem2,
  ItemContent: () => FileUploadItemContent,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger2,
  ItemGroup: () => FileUploadItemGroup2,
  ItemName: () => FileUploadItemName2,
  ItemPreview: () => FileUploadItemPreview2,
  ItemPreviewImage: () => FileUploadItemPreviewImage2,
  ItemSizeText: () => FileUploadItemSizeText2,
  Label: () => FileUploadLabel2,
  PropsProvider: () => FileUploadPropsProvider,
  Root: () => FileUploadRoot2,
  RootProvider: () => FileUploadRootProvider2,
  Trigger: () => FileUploadTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js
var import_jsx_runtime276 = __toESM(require_jsx_runtime(), 1);
var import_react562 = __toESM(require_react(), 1);
var Flex = (0, import_react562.forwardRef)(
  function Flex2(props25, ref2) {
    const {
      direction,
      align,
      justify,
      wrap: wrap5,
      basis,
      grow,
      shrink,
      inline: inline2,
      ...rest
    } = props25;
    return (0, import_jsx_runtime276.jsx)(
      chakra.div,
      {
        ref: ref2,
        ...rest,
        css: {
          display: inline2 ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap5,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props25.css
        }
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/float/float.js
var import_jsx_runtime277 = __toESM(require_jsx_runtime(), 1);
var import_react563 = __toESM(require_react(), 1);
var Float = (0, import_react563.forwardRef)(
  function Float2(props25, ref2) {
    const {
      offsetX,
      offsetY,
      offset: offset3 = "0",
      placement = "top-end",
      ...rest
    } = props25;
    const styles = (0, import_react563.useMemo)(
      () => ({
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        position: "absolute",
        insetBlockStart: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map = {
            top: offsetY ?? offset3,
            middle: "50%",
            bottom: "auto"
          };
          return map[side];
        }),
        insetBlockEnd: mapObject(placement, (v) => {
          const [side] = v.split("-");
          const map = {
            top: "auto",
            middle: "50%",
            bottom: offsetY ?? offset3
          };
          return map[side];
        }),
        insetStart: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map = {
            start: offsetX ?? offset3,
            center: "50%",
            end: "auto"
          };
          return map[align];
        }),
        insetEnd: mapObject(placement, (v) => {
          const [, align] = v.split("-");
          const map = {
            start: "auto",
            center: "50%",
            end: offsetX ?? offset3
          };
          return map[align];
        }),
        translate: mapObject(placement, (v) => {
          const [side, align] = v.split("-");
          const mapX = { start: "-50%", center: "-50%", end: "50%" };
          const mapY = { top: "-50%", middle: "-50%", bottom: "50%" };
          return `${mapX[align]} ${mapY[side]}`;
        })
      }),
      [offset3, offsetX, offsetY, placement]
    );
    return (0, import_jsx_runtime277.jsx)(chakra.div, { ref: ref2, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/for/for.js
function For(props25) {
  const { each: each2, fallback: fallback3, children } = props25;
  if ((each2 == null ? void 0 : each2.length) === 0) {
    return fallback3 || null;
  }
  return each2 == null ? void 0 : each2.map(children);
}

// node_modules/@chakra-ui/react/dist/esm/components/grid/grid-item.js
var import_jsx_runtime278 = __toESM(require_jsx_runtime(), 1);
var import_react564 = __toESM(require_react(), 1);
function spanFn(span) {
  return mapObject(
    span,
    (value) => value === "auto" ? "auto" : `span ${value}/span ${value}`
  );
}
var GridItem = (0, import_react564.forwardRef)(
  function GridItem2(props25, ref2) {
    const {
      area,
      colSpan,
      colStart,
      colEnd,
      rowEnd,
      rowSpan,
      rowStart,
      ...rest
    } = props25;
    const styles = compact({
      gridArea: area,
      gridColumn: spanFn(colSpan),
      gridRow: spanFn(rowSpan),
      gridColumnStart: colStart,
      gridColumnEnd: colEnd,
      gridRowStart: rowStart,
      gridRowEnd: rowEnd
    });
    return (0, import_jsx_runtime278.jsx)(chakra.div, { ref: ref2, css: styles, ...rest });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/grid/simple-grid.js
var import_jsx_runtime279 = __toESM(require_jsx_runtime(), 1);
var import_react565 = __toESM(require_react(), 1);
var SimpleGrid = (0, import_react565.forwardRef)(
  function SimpleGrid2(props25, ref2) {
    const { columns, minChildWidth, ...rest } = props25;
    const sys = useChakraContext();
    const templateColumns = minChildWidth ? widthToColumns(minChildWidth, sys) : countToColumns(columns);
    return (0, import_jsx_runtime279.jsx)(Grid, { ref: ref2, templateColumns, ...rest });
  }
);
function toPx2(n) {
  return typeof n === "number" ? `${n}px` : n;
}
function widthToColumns(width, sys) {
  return mapObject(width, (value) => {
    const _value = sys.tokens.getVar(`sizes.${value}`, toPx2(value));
    return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
  });
}
function countToColumns(count) {
  return mapObject(
    count,
    (value) => value === null ? null : `repeat(${value}, minmax(0, 1fr))`
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
var import_jsx_runtime281 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/highlight/highlight.js
var import_jsx_runtime280 = __toESM(require_jsx_runtime(), 1);
var import_react567 = __toESM(require_react(), 1);

// node_modules/@zag-js/highlight-word/dist/index.mjs
var normalizeSpan = (spans, len) => {
  const result = [];
  const append2 = (start, end, match5) => {
    if (end - start > 0) result.push({ start, end, match: match5 });
  };
  if (spans.length === 0) {
    append2(0, len, false);
  } else {
    let lastIndex = 0;
    for (const chunk2 of spans) {
      append2(lastIndex, chunk2.start, false);
      append2(chunk2.start, chunk2.end, true);
      lastIndex = chunk2.end;
    }
    append2(lastIndex, len, false);
  }
  return result;
};
function highlightFirst(props25) {
  const { text, query: query2, ignoreCase } = props25;
  const searchText = ignoreCase ? text.toLowerCase() : text;
  const searchQuery = ignoreCase ? typeof query2 === "string" ? query2.toLowerCase() : query2 : query2;
  const start = typeof searchText === "string" ? searchText.indexOf(searchQuery) : -1;
  if (start === -1) {
    return [{ text, match: false }];
  }
  const end = start + searchQuery.length;
  const spans = [{ start, end }];
  return normalizeSpan(spans, text.length).map((chunk2) => ({
    text: text.slice(chunk2.start, chunk2.end),
    match: !!chunk2.match
  }));
}
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char2) => `\\${char2}`);
var buildRegex = (queryProp, flags) => {
  const query2 = queryProp.filter(Boolean).map((text) => escapeRegexp(text));
  return new RegExp(`(${query2.join("|")})`, flags);
};
var getRegexFlags = (ignoreCase, matchAll = true) => `${ignoreCase ? "i" : ""}${matchAll ? "g" : ""}`;
function highlightMultiple(props25) {
  const { text, query: query2, ignoreCase, matchAll } = props25;
  if (query2.length === 0) {
    return [{ text, match: false }];
  }
  const flags = getRegexFlags(ignoreCase, matchAll);
  const regex = buildRegex(Array.isArray(query2) ? query2 : [query2], flags);
  const spans = [...text.matchAll(regex)].map((match5) => ({
    start: match5.index || 0,
    end: (match5.index || 0) + match5[0].length
  }));
  return normalizeSpan(spans, props25.text.length).map((chunk2) => ({
    text: props25.text.slice(chunk2.start, chunk2.end),
    match: !!chunk2.match
  }));
}
var highlightWord = (props25) => {
  if (props25.matchAll == null) {
    props25.matchAll = Array.isArray(props25.query);
  }
  if (!props25.matchAll && Array.isArray(props25.query)) {
    throw new Error("matchAll must be true when using multiple queries");
  }
  return props25.matchAll ? highlightMultiple(props25) : highlightFirst(props25);
};

// node_modules/@ark-ui/react/dist/components/highlight/use-highlight.js
var import_react566 = __toESM(require_react(), 1);
var useHighlight = (props25) => {
  return (0, import_react566.useMemo)(() => highlightWord(props25), [props25]);
};

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
var import_react568 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/typography/mark.js
var { withContext: withContext25, PropsProvider: PropsProvider26 } = createRecipeContext({
  key: "mark"
});
var Mark = withContext25("mark");
var MarkPropsProvider = PropsProvider26;

// node_modules/@chakra-ui/react/dist/esm/components/highlight/highlight.js
function Highlight2(props25) {
  const { children, query: query2, ignoreCase, matchAll, styles } = props25;
  if (typeof children !== "string") {
    throw new Error("The children prop of Highlight must be a string");
  }
  const chunks = useHighlight({
    query: query2,
    text: children,
    matchAll,
    ignoreCase
  });
  return (0, import_jsx_runtime281.jsx)(For, { each: chunks, children: (chunk2, index) => {
    return chunk2.match ? (0, import_jsx_runtime281.jsx)(Mark, { css: styles, children: chunk2.text }, index) : (0, import_jsx_runtime281.jsx)(import_react568.Fragment, { children: chunk2.text }, index);
  } });
}

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/hover-card.js
var {
  withRootProvider: withRootProvider4,
  withContext: withContext26,
  useStyles: useHoverCardStyles,
  PropsProvider: PropsProvider27
} = createSlotRecipeContext({ key: "hoverCard" });
var HoverCardRootProvider2 = withRootProvider4(hover_card_exports.RootProvider);
var HoverCardRoot2 = withRootProvider4(
  hover_card_exports.Root
);
var HoverCardPropsProvider = PropsProvider27;
var HoverCardTrigger2 = withContext26(hover_card_exports.Trigger, "trigger", { forwardAsChild: true });
var HoverCardPositioner2 = withContext26(hover_card_exports.Positioner, "positioner", { forwardAsChild: true });
var HoverCardContent2 = withContext26(hover_card_exports.Content, "content", { forwardAsChild: true });
var HoverCardArrow2 = withContext26(
  hover_card_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var HoverCardArrowTip2 = withContext26(hover_card_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var HoverCardContext2 = hover_card_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/hover-card/namespace.js
var namespace_exports21 = {};
__export(namespace_exports21, {
  Arrow: () => HoverCardArrow2,
  ArrowTip: () => HoverCardArrowTip2,
  Content: () => HoverCardContent2,
  Context: () => HoverCardContext2,
  Positioner: () => HoverCardPositioner2,
  PropsProvider: () => HoverCardPropsProvider,
  Root: () => HoverCardRoot2,
  RootProvider: () => HoverCardRootProvider2,
  Trigger: () => HoverCardTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/image/image.js
var import_jsx_runtime282 = __toESM(require_jsx_runtime(), 1);
var import_react569 = __toESM(require_react(), 1);
var Image = (0, import_react569.forwardRef)(
  function Image2(props25, ref2) {
    const { align, fit = "cover", ...rest } = props25;
    return (0, import_jsx_runtime282.jsx)(
      chakra.img,
      {
        ref: ref2,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props25.className),
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input.js
var { withContext: withContext27, PropsProvider: PropsProvider28 } = createRecipeContext({
  key: "input"
});
var Input = withContext27(field_exports.Input);
var InputPropsProvider = PropsProvider28;

// node_modules/@chakra-ui/react/dist/esm/components/input/input-addon.js
var import_jsx_runtime283 = __toESM(require_jsx_runtime(), 1);
var import_react570 = __toESM(require_react(), 1);
var InputAddon = (0, import_react570.forwardRef)(
  function InputAddon2({ unstyled, ...props25 }, ref2) {
    const recipe = useRecipe({ key: "inputAddon", recipe: props25.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props25);
    const styles = unstyled ? EMPTY_SLOT_STYLES : recipe(variantProps);
    return (0, import_jsx_runtime283.jsx)(chakra.div, { ref: ref2, ...localProps, css: [styles, props25.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/input/input-element.js
var InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.subtle",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/kbd/kbd.js
var { withContext: withContext28, PropsProvider: PropsProvider29 } = createRecipeContext({
  key: "kbd"
});
var Kbd = withContext28("kbd");

// node_modules/@chakra-ui/react/dist/esm/components/link/link.js
var { withContext: withContext29, PropsProvider: PropsProvider30 } = createRecipeContext({
  key: "link"
});
var Link = withContext29("a");
var LinkPropsProvider = PropsProvider30;

// node_modules/@chakra-ui/react/dist/esm/components/link/link-box.js
var import_jsx_runtime284 = __toESM(require_jsx_runtime(), 1);
var import_react571 = __toESM(require_react(), 1);
var LinkOverlay = (0, import_react571.forwardRef)(
  function LinkOverlay2(props25, ref2) {
    const { rel, className, ...rest } = props25;
    return (0, import_jsx_runtime284.jsx)(
      chakra.a,
      {
        ...rest,
        ref: ref2,
        className: cx("chakra-linkbox__overlay", className),
        css: [
          {
            position: "static",
            "&::before": {
              content: "''",
              cursor: "inherit",
              display: "block",
              position: "absolute",
              top: 0,
              left: 0,
              zIndex: 0,
              width: "100%",
              height: "100%"
            }
          },
          props25.css
        ]
      }
    );
  }
);
var LinkBox = (0, import_react571.forwardRef)(
  function LinkBox2(props25, ref2) {
    const { className, ...rest } = props25;
    return (0, import_jsx_runtime284.jsx)(
      chakra.div,
      {
        ref: ref2,
        position: "relative",
        ...rest,
        className: cx("chakra-linkbox", className),
        css: [
          {
            /* Elevate the links and abbreviations up */
            "& a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
              position: "relative",
              zIndex: 1
            }
          },
          props25.css
        ]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/list/list.js
var {
  withProvider: withProvider18,
  withContext: withContext30,
  useStyles: useListStyles,
  PropsProvider: PropsProvider31
} = createSlotRecipeContext({ key: "list" });
var ListRoot = withProvider18(
  "ul",
  "root",
  { defaultProps: { role: "list" } }
);
var ListRootPropsProvider = PropsProvider31;
var ListItem = withContext30("li", "item");
var ListIndicator = withContext30(
  "span",
  "indicator"
);

// node_modules/@chakra-ui/react/dist/esm/components/list/namespace.js
var namespace_exports22 = {};
__export(namespace_exports22, {
  Indicator: () => ListIndicator,
  Item: () => ListItem,
  Root: () => ListRoot,
  RootPropsProvider: () => ListRootPropsProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/loader/loader-overlay.js
var LoaderOverlay = chakra("div", {
  base: {
    pos: "absolute",
    inset: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    boxSize: "full",
    gap: "2"
  }
});

// node_modules/@ark-ui/react/dist/providers/locale/locale-provider.js
var import_jsx_runtime285 = __toESM(require_jsx_runtime(), 1);
var LocaleProvider = (props25) => {
  const { children, locale } = props25;
  const context = {
    locale,
    dir: isRTL(locale) ? "rtl" : "ltr"
  };
  return (0, import_jsx_runtime285.jsx)(LocaleContextProvider, { value: context, children });
};

// node_modules/@chakra-ui/react/dist/esm/components/menu/menu.js
var {
  withRootProvider: withRootProvider5,
  withContext: withContext31,
  useStyles: useMenuStyles,
  PropsProvider: PropsProvider32
} = createSlotRecipeContext({ key: "menu" });
var MenuRootProvider2 = withRootProvider5(
  menu_exports.RootProvider
);
var MenuRoot2 = withRootProvider5(menu_exports.Root);
var MenuPropsProvider = PropsProvider32;
var MenuTrigger2 = withContext31(
  menu_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var MenuContextTrigger2 = withContext31(menu_exports.ContextTrigger, "contextTrigger", { forwardAsChild: true });
var MenuPositioner2 = withContext31(
  menu_exports.Positioner,
  "positioner",
  { forwardAsChild: true }
);
var MenuSeparator2 = withContext31(
  menu_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var MenuContent2 = withContext31(
  menu_exports.Content,
  "content",
  { forwardAsChild: true }
);
var MenuArrow2 = withContext31(
  menu_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var MenuArrowTip2 = withContext31(
  menu_exports.ArrowTip,
  "arrowTip",
  { forwardAsChild: true }
);
var MenuIndicator2 = withContext31(
  menu_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var MenuItemGroup2 = withContext31(
  menu_exports.ItemGroup,
  "itemGroup",
  { forwardAsChild: true }
);
var MenuItemGroupLabel2 = withContext31(menu_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var MenuItem2 = withContext31(
  menu_exports.Item,
  "item",
  { forwardAsChild: true }
);
var MenuTriggerItem2 = withContext31(menu_exports.TriggerItem, "item", { forwardAsChild: true });
var MenuItemText2 = withContext31(
  menu_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var MenuItemCommand = withContext31(
  "kbd",
  "itemCommand"
);
var MenuItemIndicator2 = withContext31(menu_exports.ItemIndicator, "itemIndicator", { forwardAsChild: true });
var MenuCheckboxItem2 = withContext31(menu_exports.CheckboxItem, "item", { forwardAsChild: true });
var MenuRadioItemGroup2 = withContext31(menu_exports.RadioItemGroup, "itemGroup", { forwardAsChild: true });
var MenuRadioItem2 = withContext31(
  menu_exports.RadioItem,
  "item",
  { forwardAsChild: true }
);
var MenuContext2 = menu_exports.Context;
var MenuItemContext2 = menu_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/menu/namespace.js
var namespace_exports23 = {};
__export(namespace_exports23, {
  Arrow: () => MenuArrow2,
  ArrowTip: () => MenuArrowTip2,
  CheckboxItem: () => MenuCheckboxItem2,
  Content: () => MenuContent2,
  Context: () => MenuContext2,
  ContextTrigger: () => MenuContextTrigger2,
  Indicator: () => MenuIndicator2,
  Item: () => MenuItem2,
  ItemCommand: () => MenuItemCommand,
  ItemContext: () => MenuItemContext2,
  ItemGroup: () => MenuItemGroup2,
  ItemGroupLabel: () => MenuItemGroupLabel2,
  ItemIndicator: () => MenuItemIndicator2,
  ItemText: () => MenuItemText2,
  Positioner: () => MenuPositioner2,
  RadioItem: () => MenuRadioItem2,
  RadioItemGroup: () => MenuRadioItemGroup2,
  Root: () => MenuRoot2,
  RootPropsProvider: () => MenuPropsProvider,
  RootProvider: () => MenuRootProvider2,
  Separator: () => MenuSeparator2,
  Trigger: () => MenuTrigger2,
  TriggerItem: () => MenuTriggerItem2
});

// node_modules/@chakra-ui/react/dist/esm/components/native-select/native-select.js
var import_jsx_runtime286 = __toESM(require_jsx_runtime(), 1);
var import_react572 = __toESM(require_react(), 1);
var [NativeSelectBasePropsProvider, useNativeSelectBaseProps] = createContext({
  name: "NativeSelectBasePropsContext",
  hookName: "useNativeSelectBaseProps",
  providerName: "<NativeSelectRoot />",
  strict: false
});
var {
  withProvider: withProvider19,
  useClassNames: useClassNames2,
  useStyles: useNativeSelectStyles,
  PropsProvider: PropsProvider33
} = createSlotRecipeContext({ key: "nativeSelect" });
var NativeSelectRoot = withProvider19("div", "root", {
  wrapElement(element, props25) {
    const field = useFieldContext();
    const disabled = Boolean((field == null ? void 0 : field.disabled) ?? props25.disabled);
    const invalid = Boolean((field == null ? void 0 : field.invalid) ?? props25.invalid);
    return (0, import_jsx_runtime286.jsx)(NativeSelectBasePropsProvider, { value: { disabled, invalid }, children: element });
  }
});
var NativeSelectPropsProvider = PropsProvider33;
var StyledSelect = chakra(field_exports.Select, {}, { forwardAsChild: true });
var NativeSelectField = (0, import_react572.forwardRef)(function NativeSelectField2(props25, ref2) {
  const { children, placeholder, ...restProps } = props25;
  const { disabled, invalid } = useNativeSelectBaseProps();
  const styles = useNativeSelectStyles();
  const classNames = useClassNames2();
  return (0, import_jsx_runtime286.jsxs)(
    StyledSelect,
    {
      disabled,
      "data-invalid": dataAttr2(invalid),
      ...restProps,
      ref: ref2,
      className: cx(classNames.field, props25.className),
      css: [styles.field, props25.css],
      children: [
        placeholder && (0, import_jsx_runtime286.jsx)("option", { value: "", children: placeholder }),
        children
      ]
    }
  );
});
function NativeSelectIndicator(props25) {
  const styles = useNativeSelectStyles();
  const { disabled, invalid } = useNativeSelectBaseProps();
  const classNames = useClassNames2();
  return (0, import_jsx_runtime286.jsx)(
    chakra.div,
    {
      ...props25,
      "data-disabled": dataAttr2(disabled),
      "data-invalid": dataAttr2(invalid),
      className: cx(classNames.indicator, props25.className),
      css: [styles.indicator, props25.css],
      children: props25.children ?? (0, import_jsx_runtime286.jsx)(ChevronDownIcon, {})
    }
  );
}

// node_modules/@chakra-ui/react/dist/esm/components/native-select/namespace.js
var namespace_exports24 = {};
__export(namespace_exports24, {
  Field: () => NativeSelectField,
  Indicator: () => NativeSelectIndicator,
  PropsProvider: () => NativeSelectPropsProvider,
  Root: () => NativeSelectRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/number-input/number-input.js
var import_jsx_runtime287 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider20,
  withContext: withContext32,
  useStyles: useNumberInputStyles,
  PropsProvider: PropsProvider34
} = createSlotRecipeContext({ key: "numberInput" });
var NumberInputRootProvider2 = withProvider20(number_input_exports.RootProvider, "root", { forwardAsChild: true });
var NumberInputRoot2 = withProvider20(number_input_exports.Root, "root", { forwardAsChild: true });
var NumberInputPropsProvider = PropsProvider34;
var NumberInputControl2 = withContext32(number_input_exports.Control, "control", { forwardAsChild: true });
var NumberInputLabel2 = withContext32(number_input_exports.Label, "label", { forwardAsChild: true });
var NumberInputInput2 = withContext32(number_input_exports.Input, "input", { forwardAsChild: true });
var NumberInputIncrementTrigger2 = withContext32(number_input_exports.IncrementTrigger, "incrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime287.jsx)(ChevronUpIcon, {}) }
});
var NumberInputDecrementTrigger2 = withContext32(number_input_exports.DecrementTrigger, "decrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: (0, import_jsx_runtime287.jsx)(ChevronDownIcon, {}) }
});
var NumberInputScrubber2 = withContext32(number_input_exports.Scrubber, "scrubber", { forwardAsChild: true });
var NumberInputValueText2 = withContext32(number_input_exports.ValueText, "valueText", { forwardAsChild: true });
var NumberInputContext2 = number_input_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/number-input/namespace.js
var namespace_exports25 = {};
__export(namespace_exports25, {
  Context: () => NumberInputContext2,
  Control: () => NumberInputControl2,
  DecrementTrigger: () => NumberInputDecrementTrigger2,
  IncrementTrigger: () => NumberInputIncrementTrigger2,
  Input: () => NumberInputInput2,
  Label: () => NumberInputLabel2,
  PropsProvider: () => NumberInputPropsProvider,
  Root: () => NumberInputRoot2,
  RootProvider: () => NumberInputRootProvider2,
  Scrubber: () => NumberInputScrubber2,
  ValueText: () => NumberInputValueText2
});

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination-context.js
var [PaginationProvider, usePaginationContext] = createContext3({
  name: "PaginationContext",
  hookName: "usePaginationContext",
  providerName: "<PaginationProvider />"
});

// node_modules/@ark-ui/react/dist/components/pagination/pagination-context.js
var PaginationContext = (props25) => props25.children(usePaginationContext());

// node_modules/@ark-ui/react/dist/components/pagination/pagination-ellipsis.js
var import_jsx_runtime288 = __toESM(require_jsx_runtime(), 1);
var import_react574 = __toESM(require_react(), 1);
var PaginationEllipsis = (0, import_react574.forwardRef)(
  (props25, ref2) => {
    const [ellipsisProps2, localProps] = createSplitProps2()(props25, ["index"]);
    const pagination = usePaginationContext();
    const mergedProps = mergeProps2(pagination.getEllipsisProps(ellipsisProps2), localProps);
    return (0, import_jsx_runtime288.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PaginationEllipsis.displayName = "PaginationEllipsis";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-item.js
var import_jsx_runtime289 = __toESM(require_jsx_runtime(), 1);
var import_react576 = __toESM(require_react(), 1);
var PaginationItem = (0, import_react576.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, ["value", "type"]);
  const pagination = usePaginationContext();
  const mergedProps = mergeProps2(pagination.getItemProps(itemProps8), localProps);
  return (0, import_jsx_runtime289.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PaginationItem.displayName = "PaginationItem";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-next-trigger.js
var import_jsx_runtime290 = __toESM(require_jsx_runtime(), 1);
var import_react578 = __toESM(require_react(), 1);
var PaginationNextTrigger = (0, import_react578.forwardRef)(
  (props25, ref2) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps2(pagination.getNextTriggerProps(), props25);
    return (0, import_jsx_runtime290.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PaginationNextTrigger.displayName = "PaginationNextTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-prev-trigger.js
var import_jsx_runtime291 = __toESM(require_jsx_runtime(), 1);
var import_react580 = __toESM(require_react(), 1);
var PaginationPrevTrigger = (0, import_react580.forwardRef)(
  (props25, ref2) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps2(pagination.getPrevTriggerProps(), props25);
    return (0, import_jsx_runtime291.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PaginationPrevTrigger.displayName = "PaginationPrevTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var import_jsx_runtime292 = __toESM(require_jsx_runtime(), 1);
var import_react584 = __toESM(require_react(), 1);

// node_modules/@zag-js/pagination/dist/index.mjs
var anatomy24 = createAnatomy("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts27 = anatomy24.build();
var dom24 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pagination:${ctx.id}`;
  },
  getPrevTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) ?? `pagination:${ctx.id}:prev`;
  },
  getNextTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) ?? `pagination:${ctx.id}:next`;
  },
  getEllipsisId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.ellipsis) == null ? void 0 : _b7.call(_a8, index)) ?? `pagination:${ctx.id}:ellipsis:${index}`;
  },
  getItemId: (ctx, page) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, page)) ?? `pagination:${ctx.id}:item:${page}`;
  }
});
var range = (start, end) => {
  let length2 = end - start + 1;
  return Array.from({ length: length2 }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number") return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = ctx.totalPages;
  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));
function connect24(state2, send, normalize2) {
  const totalPages = state2.context.totalPages;
  const page = state2.context.page;
  const translations = state2.context.translations;
  const count = state2.context.count;
  const previousPage = state2.context.previousPage;
  const nextPage = state2.context.nextPage;
  const pageRange = state2.context.pageRange;
  const type = state2.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange(state2.context);
  return {
    count,
    page,
    pageSize: state2.context.pageSize,
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count2) {
      send({ type: "SET_COUNT", count: count2 });
    },
    setPageSize(size3) {
      send({ type: "SET_PAGE_SIZE", size: size3 });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize2.element({
        id: dom24.getRootId(state2.context),
        ...parts27.root.attrs,
        dir: state2.context.dir,
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props25) {
      return normalize2.element({
        id: dom24.getEllipsisId(state2.context, props25.index),
        ...parts27.ellipsis.attrs,
        dir: state2.context.dir
      });
    },
    getItemProps(props25) {
      var _a8;
      const index = props25.value;
      const isCurrentPage = index === state2.context.page;
      return normalize2.element({
        id: dom24.getItemId(state2.context, index),
        ...parts27.item.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-selected": dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": (_a8 = translations.itemLabel) == null ? void 0 : _a8.call(translations, { page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize2.element({
        id: dom24.getPrevTriggerId(state2.context),
        ...parts27.prevTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize2.element({
        id: dom24.getNextTriggerId(state2.context),
        ...parts27.nextTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}
var defaultTranslations = {
  rootLabel: "pagination",
  prevTriggerLabel: "previous page",
  nextTriggerLabel: "next page",
  itemLabel({ page, totalPages }) {
    const isLastPage = totalPages > 1 && page === totalPages;
    return `${isLastPage ? "last page, " : ""}page ${page}`;
  }
};
function machine24(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          ...defaultTranslations,
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = Math.min(start + ctx2.pageSize, ctx2.count);
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        FIRST_PAGE: {
          actions: "goToFirstPage"
        },
        LAST_PAGE: {
          actions: "goToLastPage"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          set18.page(ctx2, evt.page);
        },
        setPageSize(ctx2, evt) {
          set18.pageSize(ctx2, evt.size);
        },
        goToFirstPage(ctx2) {
          set18.page(ctx2, 1);
        },
        goToLastPage(ctx2) {
          set18.page(ctx2, ctx2.totalPages);
        },
        goToPrevPage(ctx2) {
          set18.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set18.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage) return;
          set18.page(ctx2, 1);
        }
      }
    }
  );
}
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var set18 = {
  pageSize: (ctx, value) => {
    var _a8;
    if (isEqual(ctx.pageSize, value)) return;
    ctx.pageSize = value;
    (_a8 = ctx.onPageSizeChange) == null ? void 0 : _a8.call(ctx, { pageSize: ctx.pageSize });
  },
  page: (ctx, value) => {
    var _a8;
    if (isEqual(ctx.page, value)) return;
    ctx.page = clampPage(value, ctx.totalPages);
    (_a8 = ctx.onPageChange) == null ? void 0 : _a8.call(ctx, { page: ctx.page, pageSize: ctx.pageSize });
  }
};
var props22 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps22 = createSplitProps(props22);
var itemProps7 = createProps()(["value", "type"]);
var splitItemProps7 = createSplitProps(itemProps7);
var ellipsisProps = createProps()(["index"]);
var splitEllipsisProps = createSplitProps(ellipsisProps);

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination.js
var import_react582 = __toESM(require_react(), 1);
var usePagination = (props25) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react582.useId)(),
    dir,
    getRootNode,
    page: props25.defaultPage,
    ...props25
  };
  const context = {
    ...initialContext,
    page: props25.page,
    onPageChange: useEvent(props25.onPageChange, { sync: true })
  };
  const [state2, send] = useMachine(machine24(initialContext), { context });
  return connect24(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var PaginationRoot = (0, import_react584.forwardRef)((props25, ref2) => {
  const [paginationProps, localProps] = createSplitProps2()(props25, [
    "count",
    "defaultPage",
    "id",
    "ids",
    "onPageChange",
    "onPageSizeChange",
    "page",
    "pageSize",
    "siblingCount",
    "translations",
    "type"
  ]);
  const pagination = usePagination(paginationProps);
  const mergedProps = mergeProps2(pagination.getRootProps(), localProps);
  return (0, import_jsx_runtime292.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime292.jsx)(ark.nav, { ...mergedProps, ref: ref2 }) });
});
PaginationRoot.displayName = "PaginationRoot";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root-provider.js
var import_jsx_runtime293 = __toESM(require_jsx_runtime(), 1);
var import_react586 = __toESM(require_react(), 1);
var PaginationRootProvider = (0, import_react586.forwardRef)(
  (props25, ref2) => {
    const [{ value: pagination }, localProps] = createSplitProps2()(props25, [
      "value"
    ]);
    const mergedProps = mergeProps2(pagination.getRootProps(), localProps);
    return (0, import_jsx_runtime293.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime293.jsx)(ark.nav, { ...mergedProps, ref: ref2 }) });
  }
);
PaginationRootProvider.displayName = "PaginationRootProvider";

// node_modules/@ark-ui/react/dist/components/pagination/pagination.js
var pagination_exports = {};
__export(pagination_exports, {
  Context: () => PaginationContext,
  Ellipsis: () => PaginationEllipsis,
  Item: () => PaginationItem,
  NextTrigger: () => PaginationNextTrigger,
  PrevTrigger: () => PaginationPrevTrigger,
  Root: () => PaginationRoot,
  RootProvider: () => PaginationRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/pagination/pagination.js
var {
  withProvider: withProvider21,
  withContext: withContext33,
  useStyles: usePaginationStyles,
  PropsProvider: PropsProvider35
} = createSlotRecipeContext({ key: "pagination" });
var PaginationRootProvider2 = withProvider21(pagination_exports.RootProvider, "root", {
  forwardAsChild: true,
  forwardProps: ["page"]
});
var PaginationRoot2 = withProvider21(
  pagination_exports.Root,
  "root",
  { forwardAsChild: true, forwardProps: ["page"] }
);
var PaginationPropsProvider = PropsProvider35;
var PaginationEllipsis2 = withContext33(pagination_exports.Ellipsis, "ellipsis", { forwardAsChild: true });
var PaginationItem2 = withContext33(pagination_exports.Item, "item", { forwardAsChild: true });
var PaginationNextTrigger2 = withContext33(pagination_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var PaginationPrevTrigger2 = withContext33(pagination_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var PaginationContext2 = pagination_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/pagination/namespace.js
var namespace_exports26 = {};
__export(namespace_exports26, {
  Context: () => PaginationContext2,
  Ellipsis: () => PaginationEllipsis2,
  Item: () => PaginationItem2,
  NextTrigger: () => PaginationNextTrigger2,
  PrevTrigger: () => PaginationPrevTrigger2,
  PropsProvider: () => PaginationPropsProvider,
  Root: () => PaginationRoot2,
  RootProvider: () => PaginationRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/pin-input.js
var {
  withProvider: withProvider22,
  withContext: withContext34,
  useStyles: usePinInputStyles,
  PropsProvider: PropsProvider36
} = createSlotRecipeContext({ key: "pinInput" });
var PinInputRootProvider2 = withProvider22(pin_input_exports.RootProvider, "root", { forwardAsChild: true });
var PinInputRoot2 = withProvider22(
  pin_input_exports.Root,
  "root",
  { forwardProps: ["mask"], forwardAsChild: true }
);
var PinInputPropsProvider = PropsProvider36;
var PinInputControl2 = withContext34(pin_input_exports.Control, "control", { forwardAsChild: true });
var PinInputInput2 = withContext34(
  pin_input_exports.Input,
  "input",
  { forwardAsChild: true }
);
var PinInputLabel2 = withContext34(
  pin_input_exports.Label,
  "label",
  { forwardAsChild: true }
);
var PinInputContext2 = pin_input_exports.Context;
var PinInputHiddenInput2 = pin_input_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/pin-input/namespace.js
var namespace_exports27 = {};
__export(namespace_exports27, {
  Context: () => PinInputContext2,
  Control: () => PinInputControl2,
  HiddenInput: () => PinInputHiddenInput2,
  Input: () => PinInputInput2,
  Label: () => PinInputLabel2,
  PropsProvider: () => PinInputPropsProvider,
  Root: () => PinInputRoot2,
  RootProvider: () => PinInputRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/popover/popover.js
var {
  withRootProvider: withRootProvider6,
  withContext: withContext35,
  useStyles: usePopoverStyles,
  PropsProvider: PropsProvider37
} = createSlotRecipeContext({ key: "popover" });
var PopoverRootProvider2 = withRootProvider6(
  popover_exports.RootProvider
);
var PopoverRoot2 = withRootProvider6(popover_exports.Root);
var PopoverPropsProvider = PropsProvider37;
var PopoverTrigger2 = withContext35(popover_exports.Trigger, "trigger", { forwardAsChild: true });
var PopoverPositioner2 = withContext35(popover_exports.Positioner, "positioner", { forwardAsChild: true });
var PopoverContent2 = withContext35(
  popover_exports.Content,
  "content",
  { forwardAsChild: true }
);
var PopoverArrow2 = withContext35(
  popover_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var PopoverArrowTip2 = withContext35(popover_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var PopoverCloseTrigger2 = withContext35(popover_exports.CloseTrigger, "closeTrigger", { forwardAsChild: true });
var PopoverIndicator2 = withContext35(popover_exports.Indicator, "indicator", { forwardAsChild: true });
var PopoverTitle2 = withContext35(
  popover_exports.Title,
  "title",
  { forwardAsChild: true }
);
var PopoverDescription2 = withContext35(popover_exports.Description, "description", { forwardAsChild: true });
var PopoverFooter = withContext35(
  "footer",
  "footer"
);
var PopoverHeader = withContext35(
  "header",
  "header"
);
var PopoverBody = withContext35(
  "div",
  "body"
);
var PopoverAnchor2 = withContext35(
  popover_exports.Anchor,
  void 0,
  { forwardAsChild: true }
);
var PopoverContext2 = popover_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/popover/namespace.js
var namespace_exports28 = {};
__export(namespace_exports28, {
  Anchor: () => PopoverAnchor2,
  Arrow: () => PopoverArrow2,
  ArrowTip: () => PopoverArrowTip2,
  Body: () => PopoverBody,
  CloseTrigger: () => PopoverCloseTrigger2,
  Content: () => PopoverContent2,
  Context: () => PopoverContext2,
  Description: () => PopoverDescription2,
  Footer: () => PopoverFooter,
  Header: () => PopoverHeader,
  Positioner: () => PopoverPositioner2,
  PropsProvider: () => PopoverPropsProvider,
  Root: () => PopoverRoot2,
  RootProvider: () => PopoverRootProvider2,
  Title: () => PopoverTitle2,
  Trigger: () => PopoverTrigger2,
  usePopoverStyles: () => usePopoverStyles
});

// node_modules/@ark-ui/react/dist/components/portal/portal.js
var import_jsx_runtime294 = __toESM(require_jsx_runtime(), 1);
var import_react587 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var Portal = (props25) => {
  var _a8;
  const { children, disabled } = props25;
  const [container, setContainer] = (0, import_react587.useState)((_a8 = props25.container) == null ? void 0 : _a8.current);
  const isServer = (0, import_react587.useSyncExternalStore)(
    subscribe2,
    () => false,
    () => true
  );
  const { getRootNode } = useEnvironmentContext();
  (0, import_react587.useEffect)(() => {
    setContainer(() => {
      var _a9;
      return (_a9 = props25.container) == null ? void 0 : _a9.current;
    });
  }, [props25.container]);
  if (isServer || disabled) return (0, import_jsx_runtime294.jsx)(import_jsx_runtime294.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode);
  return (0, import_jsx_runtime294.jsx)(import_jsx_runtime294.Fragment, { children: import_react587.Children.map(children, (child) => (0, import_react_dom2.createPortal)(child, mountNode)) });
};
var getPortalNode = (cb) => {
  const node2 = cb == null ? void 0 : cb();
  const rootNode = node2.getRootNode();
  if (isShadowRoot(rootNode)) return rootNode;
  return getDocument(node2).body;
};
var subscribe2 = () => () => {
};

// node_modules/@chakra-ui/react/dist/esm/components/progress/progress.js
var {
  withProvider: withProvider23,
  withContext: withContext36,
  useStyles: useProgressStyles,
  PropsProvider: PropsProvider38
} = createSlotRecipeContext({ key: "progress" });
var ProgressRootProvider2 = withProvider23(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressRoot2 = withProvider23(
  progress_exports.Root,
  "root"
);
var ProgressPropsProvider = PropsProvider38;
var ProgressLabel2 = withContext36(
  progress_exports.Label,
  "label",
  { forwardAsChild: true }
);
var ProgressTrack2 = withContext36(
  progress_exports.Track,
  "track",
  { forwardAsChild: true }
);
var ProgressRange2 = withContext36(
  progress_exports.Range,
  "range",
  { forwardAsChild: true }
);
var ProgressValueText2 = withContext36(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressContext2 = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress/namespace.js
var namespace_exports29 = {};
__export(namespace_exports29, {
  Context: () => ProgressContext2,
  Label: () => ProgressLabel2,
  PropsProvider: () => ProgressPropsProvider,
  Range: () => ProgressRange2,
  Root: () => ProgressRoot2,
  RootProvider: () => ProgressRootProvider2,
  Track: () => ProgressTrack2,
  ValueText: () => ProgressValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/progress-circle.js
var {
  withProvider: withProvider24,
  withContext: withContext37,
  useStyles: useProgressCircleStyles,
  PropsProvider: PropsProvider39
} = createSlotRecipeContext({ key: "progressCircle" });
var ProgressCircleRootProvider = withProvider24(progress_exports.RootProvider, "root", { forwardAsChild: true });
var ProgressCircleRoot = withProvider24(progress_exports.Root, "root", { forwardAsChild: true });
var ProgressCirclePropsProvider = PropsProvider39;
var ProgressCircleLabel = withContext37(progress_exports.Label, "label", { forwardAsChild: true });
var ProgressCircleCircle = withContext37(progress_exports.Circle, "circle", { forwardAsChild: true });
var ProgressCircleTrack2 = withContext37(progress_exports.CircleTrack, "circleTrack", { forwardAsChild: true });
var ProgressCircleRange2 = withContext37(progress_exports.CircleRange, "circleRange", { forwardAsChild: true });
var ProgressCircleValueText = withContext37(progress_exports.ValueText, "valueText", { forwardAsChild: true });
var ProgressCircleContext = progress_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/progress-circle/namespace.js
var namespace_exports30 = {};
__export(namespace_exports30, {
  Circle: () => ProgressCircleCircle,
  Label: () => ProgressCircleLabel,
  PropsProvider: () => ProgressCirclePropsProvider,
  Range: () => ProgressCircleRange2,
  Root: () => ProgressCircleRoot,
  RootProvider: () => ProgressCircleRootProvider,
  Track: () => ProgressCircleTrack2,
  ValueText: () => ProgressCircleValueText
});

// node_modules/@chakra-ui/react/dist/esm/components/qr-code/qr-code.js
var {
  withProvider: withProvider25,
  withContext: withContext38,
  useStyles: useQrCodeStyles,
  PropsProvider: PropsProvider40
} = createSlotRecipeContext({ key: "qrCode" });
var QrCodeRoot2 = withProvider25(
  qr_code_exports.Root,
  "root",
  { forwardAsChild: true }
);
var QrCodeRootProvider2 = withProvider25(qr_code_exports.RootProvider, "root", { forwardAsChild: true });
var QrCodePropsProvider = PropsProvider40;
var QrCodeFrame2 = withContext38(
  qr_code_exports.Frame,
  "frame",
  { forwardAsChild: true }
);
var QrCodePattern2 = withContext38(
  qr_code_exports.Pattern,
  "pattern",
  { forwardAsChild: true }
);
var QrCodeOverlay2 = withContext38(
  qr_code_exports.Overlay,
  "overlay",
  { forwardAsChild: true }
);
var QrCodeDownloadTrigger2 = withContext38(qr_code_exports.DownloadTrigger, "downloadTrigger", { forwardAsChild: true });

// node_modules/@chakra-ui/react/dist/esm/components/qr-code/namespace.js
var namespace_exports31 = {};
__export(namespace_exports31, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger2,
  Frame: () => QrCodeFrame2,
  Overlay: () => QrCodeOverlay2,
  Pattern: () => QrCodePattern2,
  PropsProvider: () => QrCodePropsProvider,
  Root: () => QrCodeRoot2,
  RootProvider: () => QrCodeRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var import_jsx_runtime296 = __toESM(require_jsx_runtime(), 1);
var import_react589 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/radiomark/radiomark.js
var import_jsx_runtime295 = __toESM(require_jsx_runtime(), 1);
var import_react588 = __toESM(require_react(), 1);
var Radiomark = (0, import_react588.forwardRef)(
  function Radiomark2(props25, ref2) {
    const recipe = useRecipe({ key: "radiomark", recipe: props25.recipe });
    const [variantProps, restProps] = recipe.splitVariantProps(props25);
    const { checked, disabled, unstyled, children, ...rest } = restProps;
    const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
    const sharedProps = {
      ref: ref2,
      "data-checked": dataAttr2(checked),
      "data-disabled": dataAttr2(disabled),
      ...rest,
      css: [styles, props25.css]
    };
    return (0, import_jsx_runtime295.jsx)(chakra.span, { ...sharedProps, children: checked && (0, import_jsx_runtime295.jsx)("span", { className: "dot" }) });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/radio-card.js
var {
  withProvider: withProvider26,
  withContext: withContext39,
  useStyles: useRadioCardStyles,
  PropsProvider: PropsProvider41
} = createSlotRecipeContext({ key: "radioCard" });
var RadioCardRootProvider = withProvider26(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioCardRoot = withProvider26(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioCardPropsProvider = PropsProvider41;
var RadioCardLabel = withContext39(
  radio_group_exports.Label,
  "label",
  { forwardAsChild: true }
);
var RadioCardItem = withContext39(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioCardItemText = withContext39(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioCardItemDescription = withContext39("div", "itemDescription", { forwardAsChild: true });
var RadioCardItemControl = withContext39(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioCardItemContent = withContext39("div", "itemContent");
var RadioCardItemAddon = withContext39("div", "itemAddon");
var RadioCardItemIndicator = (0, import_react589.forwardRef)(function RadioGroupItemIndicator(props25, ref2) {
  const { checked, ...rest } = props25;
  const styles = useRadioCardStyles();
  const itemContext = useRadioGroupItemContext();
  if (checked && itemContext.checked) {
    return (0, import_jsx_runtime296.jsx)(
      chakra.span,
      {
        ref: ref2,
        asChild: true,
        ...rest,
        css: [styles["itemIndicator"], props25.css],
        children: checked
      }
    );
  }
  return (0, import_jsx_runtime296.jsx)(
    Radiomark,
    {
      ref: ref2,
      unstyled: true,
      ...props25,
      checked: itemContext.checked,
      disabled: itemContext.disabled,
      css: [styles["itemIndicator"], props25.css]
    }
  );
});
var RadioCardContext = radio_group_exports.Context;
var RadioCardItemContext = radio_group_exports.ItemContext;
var RadioCardItemHiddenInput = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-card/namespace.js
var namespace_exports32 = {};
__export(namespace_exports32, {
  Context: () => RadioCardContext,
  Item: () => RadioCardItem,
  ItemAddon: () => RadioCardItemAddon,
  ItemContent: () => RadioCardItemContent,
  ItemContext: () => RadioCardItemContext,
  ItemControl: () => RadioCardItemControl,
  ItemDescription: () => RadioCardItemDescription,
  ItemHiddenInput: () => RadioCardItemHiddenInput,
  ItemIndicator: () => RadioCardItemIndicator,
  ItemText: () => RadioCardItemText,
  Label: () => RadioCardLabel,
  PropsProvider: () => RadioCardPropsProvider,
  Root: () => RadioCardRoot,
  RootProvider: () => RadioCardRootProvider
});

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/radio-group.js
var import_jsx_runtime297 = __toESM(require_jsx_runtime(), 1);
var import_react590 = __toESM(require_react(), 1);
var {
  withProvider: withProvider27,
  withContext: withContext40,
  useStyles: useRadioGroupStyles,
  PropsProvider: PropsProvider42
} = createSlotRecipeContext({ key: "radioGroup" });
var RadioGroupRootProvider2 = withProvider27(radio_group_exports.RootProvider, "root", { forwardAsChild: true });
var RadioGroupRoot2 = withProvider27(
  radio_group_exports.Root,
  "root",
  { forwardAsChild: true }
);
var RadioGroupPropsProvider = PropsProvider42;
var RadioGroupLabel2 = withContext40(radio_group_exports.Label, "label", { forwardAsChild: true });
var RadioGroupItem2 = withContext40(
  radio_group_exports.Item,
  "item",
  { forwardAsChild: true }
);
var RadioGroupItemText2 = withContext40(radio_group_exports.ItemText, "itemText", { forwardAsChild: true });
var RadioGroupItemControl2 = withContext40(radio_group_exports.ItemControl, "itemControl", { forwardAsChild: true });
var RadioGroupItemIndicator2 = (0, import_react590.forwardRef)(function RadioGroupItemIndicator22(props25, ref2) {
  const styles = useRadioGroupStyles();
  return (0, import_jsx_runtime297.jsx)(radio_group_exports.ItemContext, { children: (itemState) => (0, import_jsx_runtime297.jsx)(radio_group_exports.ItemControl, { asChild: true, children: (0, import_jsx_runtime297.jsx)(
    Radiomark,
    {
      ref: ref2,
      unstyled: true,
      ...props25,
      checked: itemState.checked,
      disabled: itemState.disabled,
      css: [styles["itemControl"], props25.css]
    }
  ) }) });
});
var RadioGroupContext2 = radio_group_exports.Context;
var RadioGroupItemContext2 = radio_group_exports.ItemContext;
var RadioGroupItemHiddenInput2 = radio_group_exports.ItemHiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/radio-group/namespace.js
var namespace_exports33 = {};
__export(namespace_exports33, {
  Context: () => RadioGroupContext2,
  Item: () => RadioGroupItem2,
  ItemContext: () => RadioGroupItemContext2,
  ItemControl: () => RadioGroupItemControl2,
  ItemHiddenInput: () => RadioGroupItemHiddenInput2,
  ItemIndicator: () => RadioGroupItemIndicator2,
  ItemText: () => RadioGroupItemText2,
  Label: () => RadioGroupLabel2,
  PropsProvider: () => RadioGroupPropsProvider,
  Root: () => RadioGroupRoot2,
  RootProvider: () => RadioGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/rating-group.js
var import_jsx_runtime298 = __toESM(require_jsx_runtime(), 1);
var import_react591 = __toESM(require_react(), 1);
var {
  withProvider: withProvider28,
  withContext: withContext41,
  useStyles: useRatingGroupStyles,
  PropsProvider: PropsProvider43
} = createSlotRecipeContext({ key: "ratingGroup" });
var RatingGroupRootProvider2 = withProvider28(rating_group_exports.RootProvider, "root", { forwardAsChild: true });
var RatingGroupRoot2 = withProvider28(rating_group_exports.Root, "root", { forwardAsChild: true });
var RatingGroupPropsProvider = PropsProvider43;
var RatingGroupLabel2 = withContext41(rating_group_exports.Label, "label", { forwardAsChild: true });
var RatingGroupControl2 = withContext41(rating_group_exports.Control, "control", { forwardAsChild: true });
var RatingGroupItem2 = withContext41(rating_group_exports.Item, "item", { forwardAsChild: true });
function cloneIcon(icon, type) {
  if (!(0, import_react591.isValidElement)(icon)) return null;
  const props25 = { [`data-${type}`]: "", "aria-hidden": "" };
  return (0, import_react591.cloneElement)(icon, props25);
}
var RatingGroupItemIndicator = (0, import_react591.forwardRef)(function RatingGroupItemIndicator2(props25, ref2) {
  const { icon = (0, import_jsx_runtime298.jsx)(StarIcon, {}), ...rest } = props25;
  const styles = useRatingGroupStyles();
  const itemState = useRatingGroupItemContext();
  return (0, import_jsx_runtime298.jsxs)(
    chakra.span,
    {
      ...rest,
      "data-highlighted": itemState.highlighted ? "" : void 0,
      "data-checked": itemState.checked ? "" : void 0,
      "data-half": itemState.half ? "" : void 0,
      css: [styles.itemIndicator, props25.css],
      ref: ref2,
      children: [
        cloneIcon(icon, "bg"),
        cloneIcon(icon, "fg")
      ]
    }
  );
});
var RatingGroupContext2 = rating_group_exports.Context;
var RatingGroupItemContext2 = rating_group_exports.ItemContext;
var RatingGroupHiddenInput2 = rating_group_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/rating-group/namespace.js
var namespace_exports34 = {};
__export(namespace_exports34, {
  Context: () => RatingGroupContext2,
  Control: () => RatingGroupControl2,
  HiddenInput: () => RatingGroupHiddenInput2,
  Item: () => RatingGroupItem2,
  ItemContext: () => RatingGroupItemContext2,
  ItemIndicator: () => RatingGroupItemIndicator,
  Label: () => RatingGroupLabel2,
  PropsProvider: () => RatingGroupPropsProvider,
  Root: () => RatingGroupRoot2,
  RootProvider: () => RatingGroupRootProvider2,
  useRatingGroupStyles: () => useRatingGroupStyles
});

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/segment-group.js
var {
  withProvider: withProvider29,
  withContext: withContext42,
  useStyles: useSegmentGroupStyles,
  PropsProvider: PropsProvider44
} = createSlotRecipeContext({ key: "segmentGroup" });
var SegmentGroupRootProvider2 = withProvider29(segment_group_exports.RootProvider, "root", { forwardAsChild: true });
var SegmentGroupRoot2 = withProvider29(segment_group_exports.Root, "root", { forwardAsChild: true });
var SegmentGroupPropsProvider = PropsProvider44;
var SegmentGroupItem2 = withContext42(segment_group_exports.Item, "item", { forwardAsChild: true });
var SegmentGroupItemText2 = withContext42(segment_group_exports.ItemText, "itemText", { forwardAsChild: true });
var SegmentGroupIndicator2 = withContext42(segment_group_exports.Indicator, "indicator", { forwardAsChild: true });
var SegmentGroupItemHiddenInput2 = segment_group_exports.ItemHiddenInput;
var SegmentGroupContext2 = segment_group_exports.Context;
var SegmentGroupItemContext2 = segment_group_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/segment-group/namespace.js
var namespace_exports35 = {};
__export(namespace_exports35, {
  Context: () => SegmentGroupContext2,
  Indicator: () => SegmentGroupIndicator2,
  Item: () => SegmentGroupItem2,
  ItemContext: () => SegmentGroupItemContext2,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput2,
  ItemText: () => SegmentGroupItemText2,
  PropsProvider: () => SegmentGroupPropsProvider,
  Root: () => SegmentGroupRoot2,
  RootProvider: () => SegmentGroupRootProvider2
});

// node_modules/@chakra-ui/react/dist/esm/components/select/select.js
var import_jsx_runtime299 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider30,
  withContext: withContext43,
  useStyles: useSelectStyles,
  PropsProvider: PropsProvider45
} = createSlotRecipeContext({ key: "select" });
var SelectRootProvider2 = withProvider30(select_exports.RootProvider, "root", {
  forwardAsChild: true
});
var SelectRoot2 = withProvider30(
  select_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SelectPropsProvider = PropsProvider45;
var SelectTrigger2 = withContext43(
  select_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var SelectPositioner2 = withContext43(select_exports.Positioner, "positioner", { forwardAsChild: true });
var SelectContent2 = withContext43(
  select_exports.Content,
  "content",
  { forwardAsChild: true }
);
var SelectValueText2 = withContext43(select_exports.ValueText, "valueText", { forwardAsChild: true });
var SelectClearTrigger2 = withContext43(select_exports.ClearTrigger, "clearTrigger", { forwardAsChild: true });
var SelectItemGroup2 = withContext43(select_exports.ItemGroup, "itemGroup", { forwardAsChild: true });
var SelectItemGroupLabel2 = withContext43(select_exports.ItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
var SelectItem2 = withContext43(
  select_exports.Item,
  "item",
  { forwardAsChild: true }
);
var SelectItemText2 = withContext43(
  select_exports.ItemText,
  "itemText",
  { forwardAsChild: true }
);
var SelectItemIndicator2 = withContext43(select_exports.ItemIndicator, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime299.jsx)(CheckIcon, {})
  }
});
var SelectIndicatorGroup = withContext43("div", "indicatorGroup");
var SelectIndicator2 = withContext43(select_exports.Indicator, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime299.jsx)(ChevronDownIcon, {})
  }
});
var SelectControl2 = withContext43(
  select_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SelectLabel2 = withContext43(
  select_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SelectContext2 = select_exports.Context;
var SelectHiddenSelect2 = select_exports.HiddenSelect;
var SelectItemContext2 = select_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/select/namespace.js
var namespace_exports36 = {};
__export(namespace_exports36, {
  ClearTrigger: () => SelectClearTrigger2,
  Content: () => SelectContent2,
  Context: () => SelectContext2,
  Control: () => SelectControl2,
  HiddenSelect: () => SelectHiddenSelect2,
  Indicator: () => SelectIndicator2,
  IndicatorGroup: () => SelectIndicatorGroup,
  Item: () => SelectItem2,
  ItemContext: () => SelectItemContext2,
  ItemGroup: () => SelectItemGroup2,
  ItemGroupLabel: () => SelectItemGroupLabel2,
  ItemIndicator: () => SelectItemIndicator2,
  ItemText: () => SelectItemText2,
  Label: () => SelectLabel2,
  Positioner: () => SelectPositioner2,
  PropsProvider: () => SelectPropsProvider,
  Root: () => SelectRoot2,
  RootProvider: () => SelectRootProvider2,
  Trigger: () => SelectTrigger2,
  ValueText: () => SelectValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/separator/separator.js
var import_jsx_runtime300 = __toESM(require_jsx_runtime(), 1);
var import_react592 = __toESM(require_react(), 1);
var { useRecipeResult: useRecipeResult4, PropsProvider: PropsProvider46 } = createRecipeContext({
  key: "separator"
});
var Separator = (0, import_react592.forwardRef)(
  function Separator2(props25, ref2) {
    const { styles, className, props: otherProps } = useRecipeResult4(props25);
    const orientation = props25.orientation || "horizontal";
    return (0, import_jsx_runtime300.jsx)(
      chakra.span,
      {
        ref: ref2,
        role: isString(orientation) ? "separator" : "presentation",
        "aria-orientation": isString(orientation) ? orientation : void 0,
        ...omit(otherProps, ["orientation"]),
        className: cx(className, props25.className),
        css: [styles, props25.css]
      }
    );
  }
);
var SeparatorPropsProvider = PropsProvider46;

// node_modules/@chakra-ui/react/dist/esm/components/skeleton/skeleton.js
var { withContext: withContext44, PropsProvider: PropsProvider47 } = createRecipeContext({
  key: "skeleton"
});
var Skeleton = withContext44("div");
var SkeletonPropsProvider = PropsProvider47;

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-link.js
var import_jsx_runtime301 = __toESM(require_jsx_runtime(), 1);
var import_react593 = __toESM(require_react(), 1);
var fallbackId = "chakra-skip-nav";
var SkipNavLink = (0, import_react593.forwardRef)(
  function SkipNavLink2(props25, ref2) {
    const recipe = useRecipe({ key: "skipNavLink", recipe: props25.recipe });
    const [variantProps, localProps] = recipe.splitVariantProps(props25);
    const styles = recipe(variantProps);
    localProps.id || (localProps.id = fallbackId);
    return (0, import_jsx_runtime301.jsx)(
      chakra.a,
      {
        ...localProps,
        ref: ref2,
        href: `#${localProps.id}`,
        css: [styles, props25.css]
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/skip-nav/skip-nav-content.js
var import_jsx_runtime302 = __toESM(require_jsx_runtime(), 1);
var import_react594 = __toESM(require_react(), 1);
var SkipNavContent = (0, import_react594.forwardRef)(
  function SkipNavContent2(props25, ref2) {
    const { id = fallbackId, ...rest } = props25;
    return (0, import_jsx_runtime302.jsx)(
      chakra.div,
      {
        ref: ref2,
        id,
        tabIndex: -1,
        style: { outline: 0 },
        ...rest
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/slider/slider.js
var {
  withProvider: withProvider31,
  withContext: withContext45,
  useStyles: useSliderStyles,
  PropsProvider: PropsProvider48
} = createSlotRecipeContext({ key: "slider" });
var SliderRootProvider2 = withProvider31(slider_exports.RootProvider, "root", { forwardAsChild: true });
var SliderRoot2 = withProvider31(
  slider_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SliderPropsProvider = PropsProvider48;
var SliderControl2 = withContext45(
  slider_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SliderTrack2 = withContext45(
  slider_exports.Track,
  "track",
  { forwardAsChild: true }
);
var SliderRange2 = withContext45(
  slider_exports.Range,
  "range",
  { forwardAsChild: true }
);
var SliderThumb2 = withContext45(
  slider_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SliderValueText2 = withContext45(slider_exports.ValueText, "valueText", { forwardAsChild: true });
var SliderLabel2 = withContext45(
  slider_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SliderMarkerGroup2 = withContext45(slider_exports.MarkerGroup, "markerGroup", { forwardAsChild: true });
var SliderMarker2 = withContext45(
  slider_exports.Marker,
  "marker",
  { forwardAsChild: true }
);
var SliderMarkerIndicator = withContext45("div", "markerIndicator");
var SliderDraggingIndicator2 = withContext45(slider_exports.DraggingIndicator, "draggingIndicator", { forwardAsChild: true });
var SliderContext2 = slider_exports.Context;
var SliderHiddenInput2 = slider_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/slider/namespace.js
var namespace_exports37 = {};
__export(namespace_exports37, {
  Context: () => SliderContext2,
  Control: () => SliderControl2,
  DraggingIndicator: () => SliderDraggingIndicator2,
  HiddenInput: () => SliderHiddenInput2,
  Label: () => SliderLabel2,
  Marker: () => SliderMarker2,
  MarkerGroup: () => SliderMarkerGroup2,
  MarkerIndicator: () => SliderMarkerIndicator,
  PropsProvider: () => SliderPropsProvider,
  Range: () => SliderRange2,
  Root: () => SliderRoot2,
  RootProvider: () => SliderRootProvider2,
  Thumb: () => SliderThumb2,
  Track: () => SliderTrack2,
  ValueText: () => SliderValueText2
});

// node_modules/@chakra-ui/react/dist/esm/components/spacer/spacer.js
var Spacer = chakra("div", {
  base: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
Spacer.displayName = "Spacer";

// node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js
var import_jsx_runtime304 = __toESM(require_jsx_runtime(), 1);
var import_react596 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
var import_jsx_runtime303 = __toESM(require_jsx_runtime(), 1);
var import_react595 = __toESM(require_react(), 1);

// node_modules/@chakra-ui/react/dist/esm/components/stack/get-separator-style.js
function getSeparatorStyles(options) {
  const { gap, direction } = options;
  const styles = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles[value])
  };
}

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack.js
function getValidChildren(children) {
  return import_react595.Children.toArray(children).filter(
    (child) => (0, import_react595.isValidElement)(child)
  );
}
var Stack = (0, import_react595.forwardRef)(
  function Stack2(props25, ref2) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap5,
      children,
      separator,
      className,
      ...rest
    } = props25;
    const separatorStyle = (0, import_react595.useMemo)(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = (0, import_react595.useMemo)(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = (0, import_react595.cloneElement)(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return (0, import_jsx_runtime303.jsxs)(import_react595.Fragment, { children: [
          child,
          index === arr.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return (0, import_jsx_runtime303.jsx)(
      chakra.div,
      {
        ref: ref2,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap5,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js
var HStack = (0, import_react596.forwardRef)(
  function HStack2(props25, ref2) {
    return (0, import_jsx_runtime304.jsx)(Stack, { align: "center", ...props25, direction: "row", ref: ref2 });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/v-stack.js
var import_jsx_runtime305 = __toESM(require_jsx_runtime(), 1);
var import_react597 = __toESM(require_react(), 1);
var VStack = (0, import_react597.forwardRef)(
  function VStack2(props25, ref2) {
    return (0, import_jsx_runtime305.jsx)(Stack, { align: "center", ...props25, direction: "column", ref: ref2 });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/stack/stack-separator.js
var StackSeparator = chakra("div", {
  base: {
    borderWidth: 0,
    alignSelf: "stretch",
    borderColor: "inherit",
    width: "auto",
    height: "auto"
  }
});
StackSeparator.displayName = "StackSeparator";

// node_modules/@chakra-ui/react/dist/esm/components/stat/stat.js
var import_jsx_runtime306 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider32,
  withContext: withContext46,
  useStyles: useStatStyles,
  PropsProvider: PropsProvider49
} = createSlotRecipeContext({ key: "stat" });
var StatRoot = withProvider32(
  "dl",
  "root"
);
var StatPropsProvider = PropsProvider49;
var StatLabel = withContext46("dt", "label");
var StatValueText = withContext46(
  "dd",
  "valueText"
);
var StatHelpText = withContext46(
  "span",
  "helpText"
);
var StatValueUnit = withContext46(
  "span",
  "valueUnit"
);
var StatUpIndicator = withContext46(
  "span",
  "indicator",
  {
    defaultProps: {
      "data-type": "up",
      children: (0, import_jsx_runtime306.jsx)(ArrowUpIcon, {})
    }
  }
);
var StatDownIndicator = withContext46("span", "indicator", {
  defaultProps: {
    "data-type": "down",
    children: (0, import_jsx_runtime306.jsx)(ArrowDownIcon, {})
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/stat/namespace.js
var namespace_exports38 = {};
__export(namespace_exports38, {
  DownIndicator: () => StatDownIndicator,
  HelpText: () => StatHelpText,
  Label: () => StatLabel,
  PropsProvider: () => StatPropsProvider,
  Root: () => StatRoot,
  UpIndicator: () => StatUpIndicator,
  ValueText: () => StatValueText,
  ValueUnit: () => StatValueUnit
});

// node_modules/@chakra-ui/react/dist/esm/components/status/namespace.js
var namespace_exports39 = {};
__export(namespace_exports39, {
  Indicator: () => StatusIndicator,
  PropsProvider: () => StatusPropsProvider,
  Root: () => StatusRoot
});

// node_modules/@chakra-ui/react/dist/esm/components/status/status.js
var {
  withProvider: withProvider33,
  withContext: withContext47,
  useStyles: useStatusStyles,
  PropsProvider: PropsProvider50
} = createSlotRecipeContext({ key: "status" });
var StatusRoot = withProvider33(
  "div",
  "root"
);
var StatusPropsProvider = PropsProvider50;
var StatusIndicator = withContext47("div", "indicator");

// node_modules/@chakra-ui/react/dist/esm/components/steps/steps.js
var import_jsx_runtime319 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var import_jsx_runtime307 = __toESM(require_jsx_runtime(), 1);
var import_react599 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-context.js
var [StepsProvider, useStepsContext] = createContext3({
  name: "StepsContext",
  hookName: "useStepsContext",
  providerName: "<StepsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-completed-content.js
var StepsCompletedContent = (0, import_react599.forwardRef)(
  (props25, ref2) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps2(steps.getContentProps({ index: steps.count }), props25);
    return (0, import_jsx_runtime307.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
StepsCompletedContent.displayName = "StepsCompletedContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-content.js
var import_jsx_runtime308 = __toESM(require_jsx_runtime(), 1);
var import_react601 = __toESM(require_react(), 1);
var StepsContent = (0, import_react601.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getContentProps(itemProps8), localProps);
  return (0, import_jsx_runtime308.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsContent.displayName = "StepsContent";

// node_modules/@ark-ui/react/dist/components/steps/steps-context.js
var StepsContext = (props25) => {
  const context = useStepsContext();
  return props25.children(context);
};
StepsContext.displayName = "StepsContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var import_jsx_runtime309 = __toESM(require_jsx_runtime(), 1);
var import_react603 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-props-context.js
var [StepsItemPropsProvider, useStepsItemPropsContext] = createContext3({
  name: "StepsItemPropsContext",
  hookName: "useStepsItemPropsContext",
  providerName: "<StepsItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-indicator.js
var StepsIndicator = (0, import_react603.forwardRef)((props25, ref2) => {
  const steps = useStepsContext();
  const itemProps8 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getIndicatorProps(itemProps8), props25);
  return (0, import_jsx_runtime309.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsIndicator.displayName = "StepsIndicator";

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var import_jsx_runtime310 = __toESM(require_jsx_runtime(), 1);
var import_react605 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/steps/use-steps-item-context.js
var [StepsItemProvider, useStepsItemContext] = createContext3({
  name: "StepsItemContext",
  hookName: "useStepsItemContext",
  providerName: "<StepsItem />"
});

// node_modules/@ark-ui/react/dist/components/steps/steps-item.js
var StepsItem = (0, import_react605.forwardRef)((props25, ref2) => {
  const [itemProps8, localProps] = createSplitProps2()(props25, ["index"]);
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getItemProps(itemProps8), localProps);
  const itemState = steps.getItemState(itemProps8);
  return (0, import_jsx_runtime310.jsx)(StepsItemPropsProvider, { value: itemProps8, children: (0, import_jsx_runtime310.jsx)(StepsItemProvider, { value: itemState, children: (0, import_jsx_runtime310.jsx)(ark.li, { ...mergedProps, ref: ref2 }) }) });
});
StepsItem.displayName = "StepsItem";

// node_modules/@ark-ui/react/dist/components/steps/steps-item-context.js
var StepsItemContext = (props25) => {
  return props25.children(useStepsItemContext());
};
StepsItemContext.displayName = "StepsItemContext";

// node_modules/@ark-ui/react/dist/components/steps/steps-list.js
var import_jsx_runtime311 = __toESM(require_jsx_runtime(), 1);
var import_react607 = __toESM(require_react(), 1);
var StepsList = (0, import_react607.forwardRef)((props25, ref2) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getListProps(), props25);
  return (0, import_jsx_runtime311.jsx)(ark.ol, { ...mergedProps, ref: ref2 });
});
StepsList.displayName = "StepsList";

// node_modules/@ark-ui/react/dist/components/steps/steps-next-trigger.js
var import_jsx_runtime312 = __toESM(require_jsx_runtime(), 1);
var import_react609 = __toESM(require_react(), 1);
var StepsNextTrigger = (0, import_react609.forwardRef)(
  (props25, ref2) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps2(steps.getNextTriggerProps(), props25);
    return (0, import_jsx_runtime312.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
StepsNextTrigger.displayName = "StepsNextTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-prev-trigger.js
var import_jsx_runtime313 = __toESM(require_jsx_runtime(), 1);
var import_react611 = __toESM(require_react(), 1);
var StepsPrevTrigger = (0, import_react611.forwardRef)(
  (props25, ref2) => {
    const steps = useStepsContext();
    const mergedProps = mergeProps2(steps.getPrevTriggerProps(), props25);
    return (0, import_jsx_runtime313.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
StepsPrevTrigger.displayName = "StepsPrevTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps-progress.js
var import_jsx_runtime314 = __toESM(require_jsx_runtime(), 1);
var import_react613 = __toESM(require_react(), 1);
var StepsProgress = (0, import_react613.forwardRef)((props25, ref2) => {
  const steps = useStepsContext();
  const mergedProps = mergeProps2(steps.getProgressProps(), props25);
  return (0, import_jsx_runtime314.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsProgress.displayName = "StepsProgress";

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var import_jsx_runtime315 = __toESM(require_jsx_runtime(), 1);
var import_react617 = __toESM(require_react(), 1);

// node_modules/@zag-js/steps/dist/index.mjs
var anatomy25 = createAnatomy("steps").parts(
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "nextTrigger",
  "prevTrigger",
  "progress"
);
var parts28 = anatomy25.build();
var dom25 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `steps:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.list) ?? `steps:${ctx.id}:list`;
  },
  getTriggerId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.triggerId) == null ? void 0 : _b7.call(_a8, index)) ?? `steps:${ctx.id}:trigger:${index}`;
  },
  getContentId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.contentId) == null ? void 0 : _b7.call(_a8, index)) ?? `steps:${ctx.id}:content:${index}`;
  }
});
function connect25(state2, send, normalize2) {
  const step = state2.context.step;
  const count = state2.context.count;
  const percent = state2.context.percent;
  const hasNextStep = state2.context.hasNextStep;
  const hasPrevStep = state2.context.hasPrevStep;
  const getItemState = (props25) => ({
    triggerId: dom25.getTriggerId(state2.context, props25.index),
    contentId: dom25.getContentId(state2.context, props25.index),
    current: props25.index === step,
    completed: props25.index < step,
    incomplete: props25.index > step,
    index: props25.index,
    first: props25.index === 0,
    last: props25.index === count - 1
  });
  const goToNextStep = () => {
    send({ type: "STEP.NEXT", src: "next.trigger.click" });
  };
  const goToPrevStep = () => {
    send({ type: "STEP.PREV", src: "prev.trigger.click" });
  };
  const resetStep = () => {
    send({ type: "STEP.RESET", src: "reset.trigger.click" });
  };
  const setStep = (value) => {
    send({ type: "STEP.SET", value, src: "api.setValue" });
  };
  return {
    value: step,
    count,
    percent,
    hasNextStep,
    hasPrevStep,
    isCompleted: state2.context.completed,
    goToNextStep,
    goToPrevStep,
    resetStep,
    getItemState,
    setStep,
    getRootProps() {
      return normalize2.element({
        ...parts28.root.attrs,
        id: dom25.getRootId(state2.context),
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--percent": `${percent}%`
        }
      });
    },
    getListProps() {
      const arr = fromLength(state2.context.count);
      const triggerIds = arr.map((_, index) => dom25.getTriggerId(state2.context, index));
      return normalize2.element({
        ...parts28.list.attrs,
        dir: state2.context.dir,
        id: dom25.getListId(state2.context),
        role: "tablist",
        "aria-owns": triggerIds.join(" "),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts28.item.attrs,
        dir: state2.context.dir,
        "aria-current": itemState.current ? "step" : void 0,
        "data-orientation": state2.context.orientation
      });
    },
    getTriggerProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.button({
        ...parts28.trigger.attrs,
        id: itemState.triggerId,
        role: "tab",
        dir: state2.context.dir,
        tabIndex: !state2.context.linear || itemState.current ? 0 : -1,
        "aria-selected": itemState.current,
        "aria-controls": itemState.contentId,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": state2.context.orientation,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (state2.context.linear) return;
          send({ type: "STEP.SET", value: props25.index, src: "trigger.click" });
        }
      });
    },
    getContentProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts28.content.attrs,
        dir: state2.context.dir,
        id: itemState.contentId,
        role: "tabpanel",
        tabIndex: 0,
        hidden: !itemState.current,
        "data-state": itemState.current ? "open" : "closed",
        "data-orientation": state2.context.orientation,
        "aria-labelledby": itemState.triggerId
      });
    },
    getIndicatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts28.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getSeparatorProps(props25) {
      const itemState = getItemState(props25);
      return normalize2.element({
        ...parts28.separator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-complete": dataAttr(itemState.completed),
        "data-current": dataAttr(itemState.current),
        "data-incomplete": dataAttr(itemState.incomplete)
      });
    },
    getNextTriggerProps() {
      return normalize2.button({
        ...parts28.nextTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled: !hasNextStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToNextStep();
        }
      });
    },
    getPrevTriggerProps() {
      return normalize2.button({
        dir: state2.context.dir,
        ...parts28.prevTrigger.attrs,
        type: "button",
        disabled: !hasPrevStep,
        onClick(event) {
          if (event.defaultPrevented) return;
          goToPrevStep();
        }
      });
    },
    getProgressProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts28.progress.attrs,
        role: "progressbar",
        "aria-valuenow": percent,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuetext": `${percent}% complete`,
        "data-complete": dataAttr(percent === 100)
      });
    }
  };
}
function machine25(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "steps",
      initial: "idle",
      context: {
        step: 0,
        count: 1,
        linear: false,
        orientation: "horizontal",
        ...ctx
      },
      computed: {
        percent: (ctx2) => ctx2.step / ctx2.count * 100,
        hasNextStep: (ctx2) => ctx2.step < ctx2.count,
        hasPrevStep: (ctx2) => ctx2.step > 0,
        completed: (ctx2) => ctx2.step === ctx2.count
      },
      states: {
        idle: {
          on: {
            "STEP.SET": {
              actions: "setStep"
            },
            "STEP.NEXT": {
              actions: "goToNextStep"
            },
            "STEP.PREV": {
              actions: "goToPrevStep"
            },
            "STEP.RESET": {
              actions: "resetStep"
            }
          }
        }
      }
    },
    {
      actions: {
        goToNextStep(ctx2) {
          const value = Math.min(ctx2.step + 1, ctx2.count);
          set19.value(ctx2, value);
        },
        goToPrevStep(ctx2) {
          const value = Math.max(ctx2.step - 1, 0);
          set19.value(ctx2, value);
        },
        resetStep(ctx2) {
          set19.value(ctx2, 0);
        },
        setStep(ctx2, evt) {
          set19.value(ctx2, evt.value);
        }
      }
    }
  );
}
var validateStep = (ctx, step) => {
  if (!isValueWithinRange(step, 0, ctx.count)) {
    throw new RangeError(`[zag-js/steps] step index ${step} is out of bounds`);
  }
};
var set19 = {
  value(ctx, step) {
    var _a8, _b7;
    if (isEqual(ctx.step, step)) return;
    validateStep(ctx, step);
    ctx.step = step;
    (_a8 = ctx.onStepChange) == null ? void 0 : _a8.call(ctx, { step });
    if (ctx.completed) {
      (_b7 = ctx.onStepComplete) == null ? void 0 : _b7.call(ctx);
    }
  }
};
var props23 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "linear",
  "onStepChange",
  "onStepComplete",
  "orientation",
  "step"
]);
var splitProps23 = createSplitProps(props23);

// node_modules/@ark-ui/react/dist/components/steps/use-steps.js
var import_react615 = __toESM(require_react(), 1);
function useSteps(props25 = {}) {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react615.useId)(),
    dir,
    getRootNode,
    step: props25.defaultStep,
    ...props25
  };
  const context = {
    ...initialContext,
    step: props25.step,
    onStepChange: useEvent(props25.onStepChange),
    onStepComplete: useEvent(props25.onStepComplete)
  };
  const [state2, send] = useMachine(machine25(initialContext), {
    context
  });
  return connect25(state2, send, normalizeProps);
}

// node_modules/@ark-ui/react/dist/components/steps/steps-root.js
var StepsRoot = (0, import_react617.forwardRef)((props25, ref2) => {
  const [useStepsProps, localProps] = createSplitProps2()(props25, [
    "defaultStep",
    "id",
    "ids",
    "count",
    "linear",
    "onStepChange",
    "onStepComplete",
    "orientation",
    "step"
  ]);
  const steps = useSteps(useStepsProps);
  const mergedProps = mergeProps2(steps.getRootProps(), localProps);
  return (0, import_jsx_runtime315.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime315.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
StepsRoot.displayName = "StepsRoot";

// node_modules/@ark-ui/react/dist/components/steps/steps-root-provider.js
var import_jsx_runtime316 = __toESM(require_jsx_runtime(), 1);
var import_react619 = __toESM(require_react(), 1);
var StepsRootProvider = (0, import_react619.forwardRef)(
  (props25, ref2) => {
    const [{ value: steps }, rootProps] = createSplitProps2()(props25, ["value"]);
    const mergedProps = mergeProps2(steps.getRootProps(), rootProps);
    return (0, import_jsx_runtime316.jsx)(StepsProvider, { value: steps, children: (0, import_jsx_runtime316.jsx)(ark.div, { ...mergedProps, ref: ref2, children: props25.children }) });
  }
);
StepsRootProvider.displayName = "StepsRootProvider";

// node_modules/@ark-ui/react/dist/components/steps/steps-separator.js
var import_jsx_runtime317 = __toESM(require_jsx_runtime(), 1);
var import_react621 = __toESM(require_react(), 1);
var StepsSeparator = (0, import_react621.forwardRef)((props25, ref2) => {
  const steps = useStepsContext();
  const itemProps8 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getSeparatorProps(itemProps8), props25);
  return (0, import_jsx_runtime317.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
StepsSeparator.displayName = "StepsSeparator";

// node_modules/@ark-ui/react/dist/components/steps/steps-trigger.js
var import_jsx_runtime318 = __toESM(require_jsx_runtime(), 1);
var import_react623 = __toESM(require_react(), 1);
var StepsTrigger = (0, import_react623.forwardRef)((props25, ref2) => {
  const steps = useStepsContext();
  const itemProps8 = useStepsItemPropsContext();
  const mergedProps = mergeProps2(steps.getTriggerProps(itemProps8), props25);
  return (0, import_jsx_runtime318.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
StepsTrigger.displayName = "StepsTrigger";

// node_modules/@ark-ui/react/dist/components/steps/steps.js
var steps_exports = {};
__export(steps_exports, {
  CompletedContent: () => StepsCompletedContent,
  Content: () => StepsContent,
  Context: () => StepsContext,
  Indicator: () => StepsIndicator,
  Item: () => StepsItem,
  ItemContext: () => StepsItemContext,
  List: () => StepsList,
  NextTrigger: () => StepsNextTrigger,
  PrevTrigger: () => StepsPrevTrigger,
  Progress: () => StepsProgress,
  Root: () => StepsRoot,
  RootProvider: () => StepsRootProvider,
  Separator: () => StepsSeparator,
  Trigger: () => StepsTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/steps/steps.js
var import_react624 = __toESM(require_react(), 1);
var {
  withProvider: withProvider34,
  withContext: withContext48,
  useStyles: useStepsStyles,
  PropsProvider: PropsProvider51
} = createSlotRecipeContext({ key: "steps" });
var StepsRootProvider2 = withProvider34(steps_exports.RootProvider, "root", { forwardAsChild: true });
var StepsRoot2 = withProvider34(
  steps_exports.Root,
  "root",
  { forwardAsChild: true }
);
var StepsPropsProvider = PropsProvider51;
var StepsList2 = withContext48(
  steps_exports.List,
  "list",
  { forwardAsChild: true }
);
var StepsItem2 = withContext48(
  steps_exports.Item,
  "item",
  { forwardAsChild: true }
);
var StepsTrigger2 = withContext48(
  steps_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var StepsContent2 = withContext48(
  steps_exports.Content,
  "content",
  { forwardAsChild: true }
);
var StepsCompletedContent2 = withContext48(steps_exports.CompletedContent, "content");
var StepsNumber = (0, import_react624.forwardRef)(
  function StepsNumber2(props25, ref2) {
    return (0, import_jsx_runtime319.jsx)(steps_exports.ItemContext, { children: (api) => (0, import_jsx_runtime319.jsx)(chakra.div, { ref: ref2, ...props25, children: api.index + 1 }) });
  }
);
var StepsTitle = withContext48(
  "div",
  "title"
);
var StepsDescription = withContext48("div", "description");
var StepsSeparator2 = withContext48(
  steps_exports.Separator,
  "separator",
  { forwardAsChild: true }
);
var StepsStatus = (props25) => {
  return (0, import_jsx_runtime319.jsx)(steps_exports.ItemContext, { children: (api) => {
    if (api.current) return (0, import_jsx_runtime319.jsx)(import_jsx_runtime319.Fragment, { children: props25.current ?? props25.incomplete });
    if (api.completed) return (0, import_jsx_runtime319.jsx)(import_jsx_runtime319.Fragment, { children: props25.complete });
    return (0, import_jsx_runtime319.jsx)(import_jsx_runtime319.Fragment, { children: props25.incomplete ?? props25.current });
  } });
};
var StepsIndicator2 = withContext48(
  steps_exports.Indicator,
  "indicator",
  {
    forwardAsChild: true,
    defaultProps: {
      children: (0, import_jsx_runtime319.jsx)(StepsStatus, { complete: (0, import_jsx_runtime319.jsx)(CheckIcon, {}), incomplete: (0, import_jsx_runtime319.jsx)(StepsNumber, {}) })
    }
  }
);
var StepsNextTrigger2 = withContext48(steps_exports.NextTrigger, "nextTrigger", { forwardAsChild: true });
var StepsPrevTrigger2 = withContext48(steps_exports.PrevTrigger, "prevTrigger", { forwardAsChild: true });
var StepsContext2 = steps_exports.Context;
var StepsItemContext2 = steps_exports.ItemContext;

// node_modules/@chakra-ui/react/dist/esm/components/steps/namespace.js
var namespace_exports40 = {};
__export(namespace_exports40, {
  CompletedContent: () => StepsCompletedContent2,
  Content: () => StepsContent2,
  Context: () => StepsContext2,
  Description: () => StepsDescription,
  Indicator: () => StepsIndicator2,
  Item: () => StepsItem2,
  ItemContext: () => StepsItemContext2,
  List: () => StepsList2,
  NextTrigger: () => StepsNextTrigger2,
  Number: () => StepsNumber,
  PrevTrigger: () => StepsPrevTrigger2,
  PropsProvider: () => StepsPropsProvider,
  Root: () => StepsRoot2,
  RootProvider: () => StepsRootProvider2,
  Separator: () => StepsSeparator2,
  Status: () => StepsStatus,
  Title: () => StepsTitle,
  Trigger: () => StepsTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/switch/switch.js
var import_jsx_runtime320 = __toESM(require_jsx_runtime(), 1);
var import_react625 = __toESM(require_react(), 1);
var {
  withProvider: withProvider35,
  withContext: withContext49,
  useStyles: useSwitchStyles,
  PropsProvider: PropsProvider52
} = createSlotRecipeContext({ key: "switch" });
var SwitchRootProvider2 = withProvider35(switch_exports.RootProvider, "root", { forwardAsChild: true });
var SwitchRoot2 = withProvider35(
  switch_exports.Root,
  "root",
  { forwardAsChild: true }
);
var SwitchPropsProvider = PropsProvider52;
var SwitchLabel2 = withContext49(
  switch_exports.Label,
  "label",
  { forwardAsChild: true }
);
var SwitchControl2 = withContext49(
  switch_exports.Control,
  "control",
  { forwardAsChild: true }
);
var SwitchThumb2 = withContext49(
  switch_exports.Thumb,
  "thumb",
  { forwardAsChild: true }
);
var SwitchIndicator = (0, import_react625.forwardRef)(function SwitchIndicator2(props25, ref2) {
  const api = useSwitchContext();
  const styles = useSwitchStyles();
  const { fallback: fallback3, children, ...rest } = props25;
  return (0, import_jsx_runtime320.jsx)(
    chakra.span,
    {
      ref: ref2,
      "data-checked": dataAttr2(api.checked),
      ...rest,
      css: [styles.indicator, props25.css],
      children: api.checked ? children : fallback3
    }
  );
});
var SwitchThumbIndicator = (0, import_react625.forwardRef)(function SwitchThumbIndicator2(props25, ref2) {
  const api = useSwitchContext();
  const { fallback: fallback3, children, ...rest } = props25;
  return (0, import_jsx_runtime320.jsx)(chakra.span, { ref: ref2, "data-checked": dataAttr2(api.checked), ...rest, children: api.checked ? children : fallback3 });
});
var SwitchContext2 = switch_exports.Context;
var SwitchHiddenInput2 = switch_exports.HiddenInput;

// node_modules/@chakra-ui/react/dist/esm/components/switch/namespace.js
var namespace_exports41 = {};
__export(namespace_exports41, {
  Context: () => SwitchContext2,
  Control: () => SwitchControl2,
  HiddenInput: () => SwitchHiddenInput2,
  Indicator: () => SwitchIndicator,
  Label: () => SwitchLabel2,
  PropsProvider: () => SwitchPropsProvider,
  Root: () => SwitchRoot2,
  RootProvider: () => SwitchRootProvider2,
  Thumb: () => SwitchThumb2,
  ThumbIndicator: () => SwitchThumbIndicator
});

// node_modules/@chakra-ui/react/dist/esm/components/table/table.js
var import_jsx_runtime321 = __toESM(require_jsx_runtime(), 1);
var import_react626 = __toESM(require_react(), 1);
var {
  StylesProvider,
  ClassNamesProvider,
  useRecipeResult: useRecipeResult5,
  withContext: withContext50,
  useStyles: useTableStyles,
  PropsProvider: PropsProvider53
} = createSlotRecipeContext({ key: "table" });
var TableRoot = (0, import_react626.forwardRef)(
  function TableRoot2({ native, ...props25 }, ref2) {
    const { styles, props: rootProps, classNames } = useRecipeResult5(props25);
    const rootCss = (0, import_react626.useMemo)(() => {
      if (!native) return styles.root;
      return {
        ...styles.root,
        "& thead": styles.header,
        "& tbody": styles.body,
        "& tfoot": styles.footer,
        "& thead th": styles.columnHeader,
        "& tr": styles.row,
        "& td": styles.cell,
        "& caption": styles.caption
      };
    }, [styles, native]);
    return (0, import_jsx_runtime321.jsx)(ClassNamesProvider, { value: classNames, children: (0, import_jsx_runtime321.jsx)(StylesProvider, { value: styles, children: (0, import_jsx_runtime321.jsx)(
      chakra.table,
      {
        ref: ref2,
        ...rootProps,
        css: [rootCss, props25.css],
        className: cx(classNames == null ? void 0 : classNames["root"], props25.className)
      }
    ) }) });
  }
);
var TableRootPropsProvider = PropsProvider53;
var TableRow = withContext50(
  "tr",
  "row"
);
var TableScrollArea = chakra("div", {
  base: {
    display: "block",
    whiteSpace: "nowrap",
    WebkitOverflowScrolling: "touch",
    overflow: "auto",
    maxWidth: "100%"
  }
});
var TableHeader = withContext50("thead", "header");
var TableFooter = withContext50("tfoot", "footer");
var TableColumnHeader = withContext50("th", "columnHeader");
var TableCell = withContext50(
  "td",
  "cell"
);
var TableCaption = withContext50("caption", "caption", {
  defaultProps: {
    captionSide: "bottom"
  }
});
var TableBody = withContext50(
  "tbody",
  "body"
);
var TableColumnGroup = withContext50("colgroup");
var TableColumn = withContext50(
  "col"
);

// node_modules/@chakra-ui/react/dist/esm/components/table/namespace.js
var namespace_exports42 = {};
__export(namespace_exports42, {
  Body: () => TableBody,
  Caption: () => TableCaption,
  Cell: () => TableCell,
  Column: () => TableColumn,
  ColumnGroup: () => TableColumnGroup,
  ColumnHeader: () => TableColumnHeader,
  Footer: () => TableFooter,
  Header: () => TableHeader,
  Root: () => TableRoot,
  RootPropsProvider: () => TableRootPropsProvider,
  Row: () => TableRow,
  ScrollArea: () => TableScrollArea
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var import_jsx_runtime322 = __toESM(require_jsx_runtime(), 1);
var import_react629 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-debounce.js
var import_react627 = __toESM(require_react(), 1);
function useDebounce(value, delay2) {
  const [debouncedValue, setDebouncedValue] = (0, import_react627.useState)(value);
  (0, import_react627.useEffect)(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay2);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay2]);
  return debouncedValue;
}

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs-context.js
var [TabsProvider, useTabsContext] = createContext3({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var TabContent = (0, import_react629.forwardRef)((props25, ref2) => {
  const [contentProps2, localProps] = createSplitProps2()(props25, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: useDebounce(tabs.value === props25.value, 0),
    immediate: true
  });
  const mergedProps = mergeProps2(
    tabs.getContentProps(contentProps2),
    presence.getPresenceProps(),
    localProps
  );
  return (0, import_jsx_runtime322.jsx)(PresenceProvider, { value: presence, children: presence.unmounted ? null : (0, import_jsx_runtime322.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) }) });
});
TabContent.displayName = "TabContent";

// node_modules/@ark-ui/react/dist/components/tabs/tab-indicator.js
var import_jsx_runtime323 = __toESM(require_jsx_runtime(), 1);
var import_react631 = __toESM(require_react(), 1);
var TabIndicator = (0, import_react631.forwardRef)((props25, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getIndicatorProps(), props25);
  return (0, import_jsx_runtime323.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TabIndicator.displayName = "TabIndicator";

// node_modules/@ark-ui/react/dist/components/tabs/tab-list.js
var import_jsx_runtime324 = __toESM(require_jsx_runtime(), 1);
var import_react633 = __toESM(require_react(), 1);
var TabList = (0, import_react633.forwardRef)((props25, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getListProps(), props25);
  return (0, import_jsx_runtime324.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TabList.displayName = "TabList";

// node_modules/@ark-ui/react/dist/components/tabs/tab-trigger.js
var import_jsx_runtime325 = __toESM(require_jsx_runtime(), 1);
var import_react635 = __toESM(require_react(), 1);
var TabTrigger = (0, import_react635.forwardRef)((props25, ref2) => {
  const [tabProps, localProps] = createSplitProps2()(props25, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps2(tabs.getTriggerProps(tabProps), localProps);
  return (0, import_jsx_runtime325.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TabTrigger.displayName = "TabTrigger";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-context.js
var TabsContext = (props25) => props25.children(useTabsContext());

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var import_jsx_runtime326 = __toESM(require_jsx_runtime(), 1);
var import_react639 = __toESM(require_react(), 1);

// node_modules/@zag-js/tabs/dist/index.mjs
var anatomy26 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts29 = anatomy26.build();
var dom26 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `tabs:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.list) ?? `tabs:${ctx.id}:list`;
  },
  getContentId: (ctx, id) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tabs:${ctx.id}:content-${id}`;
  },
  getTriggerId: (ctx, id) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `tabs:${ctx.id}:trigger-${id}`;
  },
  getIndicatorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `tabs:${ctx.id}:indicator`;
  },
  getListEl: (ctx) => dom26.getById(ctx, dom26.getListId(ctx)),
  getContentEl: (ctx, id) => dom26.getById(ctx, dom26.getContentId(ctx, id)),
  getTriggerEl: (ctx, id) => dom26.getById(ctx, dom26.getTriggerId(ctx, id)),
  getIndicatorEl: (ctx) => dom26.getById(ctx, dom26.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom26.getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom26.getListEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom26.getElements(ctx)),
  getLastTriggerEl: (ctx) => last(dom26.getElements(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom26.getElements(ctx), dom26.getTriggerId(ctx, id), ctx.loopFocus),
  getPrevTriggerEl: (ctx, id) => prevById(dom26.getElements(ctx), dom26.getTriggerId(ctx, id), ctx.loopFocus),
  getSelectedContentEl: (ctx) => {
    if (!ctx.value) return;
    return dom26.getContentEl(ctx, ctx.value);
  },
  getSelectedTriggerEl: (ctx) => {
    if (!ctx.value) return;
    return dom26.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el) => {
    return {
      left: (el == null ? void 0 : el.offsetLeft) ?? 0,
      top: (el == null ? void 0 : el.offsetTop) ?? 0,
      width: (el == null ? void 0 : el.offsetWidth) ?? 0,
      height: (el == null ? void 0 : el.offsetHeight) ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = itemById(dom26.getElements(ctx), dom26.getTriggerId(ctx, id));
    return dom26.resolveRect(dom26.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect26(state2, send, normalize2) {
  const translations = state2.context.translations;
  const focused = state2.matches("focused");
  const isVertical = state2.context.orientation === "vertical";
  const isHorizontal = state2.context.orientation === "horizontal";
  const composite = state2.context.composite;
  const indicator = state2.context.indicatorState;
  function getTriggerState(props25) {
    return {
      selected: state2.context.value === props25.value,
      focused: state2.context.focusedValue === props25.value,
      disabled: !!props25.disabled
    };
  }
  return {
    value: state2.context.value,
    focusedValue: state2.context.focusedValue,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = dom26.getTriggerId(state2.context, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    syncTabIndex() {
      send("SYNC_TAB_INDEX");
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      var _a8;
      (_a8 = dom26.getSelectedTriggerEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize2.element({
        ...parts29.root.attrs,
        id: dom26.getRootId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        dir: state2.context.dir
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts29.list.attrs,
        id: dom26.getListId(state2.context),
        role: "tablist",
        dir: state2.context.dir,
        "data-focus": dataAttr(focused),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation,
        "aria-label": translations == null ? void 0 : translations.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            },
            Enter() {
              send({ type: "ENTER" });
            }
          };
          let key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props25) {
      const { value, disabled } = props25;
      const triggerState = getTriggerState(props25);
      return normalize2.button({
        ...parts29.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr(triggerState.selected),
        "data-focus": dataAttr(triggerState.focused),
        "aria-controls": triggerState.selected ? dom26.getContentId(state2.context, value) : void 0,
        "data-ownedby": dom26.getListId(state2.context),
        "data-ssr": dataAttr(state2.context.ssr),
        id: dom26.getTriggerId(state2.context, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if ((target == null ? void 0 : target.getAttribute("role")) !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props25) {
      const { value } = props25;
      const selected = state2.context.value === value;
      return normalize2.element({
        ...parts29.content.attrs,
        dir: state2.context.dir,
        id: dom26.getContentId(state2.context, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": dom26.getTriggerId(state2.context, value),
        role: "tabpanel",
        "data-ownedby": dom26.getListId(state2.context),
        "data-selected": dataAttr(selected),
        "data-orientation": state2.context.orientation,
        hidden: !selected
      });
    },
    getIndicatorProps() {
      var _a8, _b7, _c6, _d6;
      return normalize2.element({
        id: dom26.getIndicatorId(state2.context),
        ...parts29.indicator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": (_a8 = indicator.rect) == null ? void 0 : _a8.left,
          "--top": (_b7 = indicator.rect) == null ? void 0 : _b7.top,
          "--width": (_c6 = indicator.rect) == null ? void 0 : _c6.width,
          "--height": (_d6 = indicator.rect) == null ? void 0 : _d6.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicator.transition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not11 } = guards;
function machine26(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        loopFocus: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...ctx,
        focusedValue: ctx.value ?? null,
        ssr: true,
        indicatorState: {
          rendered: false,
          transition: false,
          rect: { left: "0px", top: "0px", width: "0px", height: "0px" }
        }
      },
      watch: {
        value: ["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        },
        SYNC_TAB_INDEX: {
          actions: "syncTabIndex"
        }
      },
      created: ["syncFocusedValue"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "syncTabIndex", "syncSsr"],
      exit: ["cleanupObserver"],
      states: {
        idle: {
          on: {
            TAB_FOCUS: {
              target: "focused",
              actions: "setFocusedValue"
            },
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_PREV: [
              {
                guard: "selectOnFocus",
                actions: ["focusPrevTab", "selectFocusedTab"]
              },
              {
                actions: "focusPrevTab"
              }
            ],
            ARROW_NEXT: [
              {
                guard: "selectOnFocus",
                actions: ["focusNextTab", "selectFocusedTab"]
              },
              {
                actions: "focusNextTab"
              }
            ],
            HOME: [
              {
                guard: "selectOnFocus",
                actions: ["focusFirstTab", "selectFocusedTab"]
              },
              {
                actions: "focusFirstTab"
              }
            ],
            END: [
              {
                guard: "selectOnFocus",
                actions: ["focusLastTab", "selectFocusedTab"]
              },
              {
                actions: "focusLastTab"
              }
            ],
            ENTER: {
              guard: not11("selectOnFocus"),
              actions: "selectFocusedTab"
            },
            TAB_FOCUS: {
              actions: ["setFocusedValue"]
            },
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        syncFocusedValue(ctx2) {
          if (ctx2.value != null && ctx2.focusedValue == null) {
            ctx2.focusedValue = ctx2.value;
          }
        },
        selectFocusedTab(ctx2) {
          raf(() => {
            const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
            const value = nullable ? null : ctx2.focusedValue;
            set20.value(ctx2, value);
          });
        },
        setFocusedValue(ctx2, evt) {
          if (evt.value == null) return;
          set20.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set20.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          const nullable = ctx2.deselectable && ctx2.value === ctx2.focusedValue;
          const value = nullable ? null : evt.value;
          set20.value(ctx2, value);
        },
        clearValue(ctx2) {
          set20.value(ctx2, null);
        },
        focusFirstTab(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom26.getFirstTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        focusLastTab(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom26.getLastTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom26.getNextTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set20.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom26.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set20.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        checkRenderedElements(ctx2) {
          ctx2.indicatorState.rendered = !!dom26.getIndicatorEl(ctx2);
        },
        syncTabIndex(ctx2) {
          raf(() => {
            const contentEl = dom26.getSelectedContentEl(ctx2);
            if (!contentEl) return;
            const focusables = getFocusables(contentEl);
            if (focusables.length > 0) {
              contentEl.removeAttribute("tabindex");
            } else {
              contentEl.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
        },
        allowIndicatorTransition(ctx2) {
          ctx2.indicatorState.transition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom26.getTriggerEl(ctx2, value);
          if (!triggerEl) return;
          ctx2.indicatorState.rect = dom26.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.indicatorState.transition = false;
          });
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
          const value = ctx2.value;
          if (!ctx2.indicatorState.rendered || !value) return;
          const triggerEl = dom26.getSelectedTriggerEl(ctx2);
          if (!triggerEl) return;
          ctx2.indicatorCleanup = trackElementRect(triggerEl, {
            getRect(el) {
              return dom26.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorState.rect = dom26.resolveRect(rect);
              nextTick(() => {
                ctx2.indicatorState.transition = false;
              });
            }
          });
        },
        navigateIfNeeded(ctx2) {
          const triggerEl = dom26.getSelectedTriggerEl(ctx2);
          if (!isAnchorElement(triggerEl)) return;
          ctx2.navigate({ value: ctx2.value, node: triggerEl });
        }
      }
    }
  );
}
var invoke13 = {
  change: (ctx) => {
    var _a8;
    if (ctx.value == null) return;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
  },
  focusChange: (ctx) => {
    var _a8;
    if (ctx.focusedValue == null) return;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, { focusedValue: ctx.focusedValue });
  }
};
var set20 = {
  value: (ctx, value) => {
    if (isEqual(value, ctx.value)) return;
    ctx.value = value;
    invoke13.change(ctx);
  },
  focusedValue: (ctx, value) => {
    if (isEqual(value, ctx.focusedValue)) return;
    ctx.focusedValue = value;
    invoke13.focusChange(ctx);
  }
};
var props24 = createProps()([
  "activationMode",
  "composite",
  "deselectable",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value"
]);
var splitProps24 = createSplitProps(props24);
var triggerProps = createProps()(["disabled", "value"]);
var splitTriggerProps = createSplitProps(triggerProps);
var contentProps = createProps()(["value"]);
var splitContentProps = createSplitProps(contentProps);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs.js
var import_react637 = __toESM(require_react(), 1);
var useTabs = (props25 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react637.useId)(),
    dir,
    getRootNode,
    value: props25.defaultValue,
    ...props25
  };
  const context = {
    ...initialContext,
    value: props25.value,
    onValueChange: useEvent(props25.onValueChange, { sync: true }),
    onFocusChange: useEvent(props25.onFocusChange)
  };
  const [state2, send] = useMachine(machine26(initialContext), { context });
  return connect26(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var TabsRoot = (0, import_react639.forwardRef)((props25, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props25);
  const [useTabsProps, localprops] = createSplitProps2()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "deselectable",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps2(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime326.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime326.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime326.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRoot.displayName = "TabsRoot";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root-provider.js
var import_jsx_runtime327 = __toESM(require_jsx_runtime(), 1);
var import_react641 = __toESM(require_react(), 1);
var TabsRootProvider = (0, import_react641.forwardRef)((props25, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props25);
  const [{ value: tabs }, localprops] = createSplitProps2()(tabsProps, ["value"]);
  const mergedProps = mergeProps2(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime327.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime327.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime327.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";

// node_modules/@ark-ui/react/dist/components/tabs/tabs.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => TabContent,
  Context: () => TabsContext,
  Indicator: () => TabIndicator,
  List: () => TabList,
  Root: () => TabsRoot,
  RootProvider: () => TabsRootProvider,
  Trigger: () => TabTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tabs/tabs.js
var {
  withProvider: withProvider36,
  withContext: withContext51,
  useStyles: useTabsStyles,
  PropsProvider: PropsProvider54
} = createSlotRecipeContext({ key: "tabs" });
var TabsRootProvider2 = withProvider36(tabs_exports.RootProvider, "root", { forwardAsChild: true });
var TabsRoot2 = withProvider36(
  tabs_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TabsPropsProvider = PropsProvider54;
var TabsTrigger = withContext51(
  tabs_exports.Trigger,
  "trigger",
  { forwardAsChild: true }
);
var TabsContent = withContext51(
  tabs_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TabsContentGroup = withContext51("div", "contentGroup");
var TabsList = withContext51(
  tabs_exports.List,
  "list",
  { forwardAsChild: true }
);
var TabsIndicator = withContext51(
  tabs_exports.Indicator,
  "indicator",
  { forwardAsChild: true }
);
var TabsContext2 = tabs_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tabs/namespace.js
var namespace_exports43 = {};
__export(namespace_exports43, {
  Content: () => TabsContent,
  ContentGroup: () => TabsContentGroup,
  Context: () => TabsContext2,
  Indicator: () => TabsIndicator,
  List: () => TabsList,
  PropsProvider: () => TabsPropsProvider,
  Root: () => TabsRoot2,
  RootProvider: () => TabsRootProvider2,
  Trigger: () => TabsTrigger
});

// node_modules/@chakra-ui/react/dist/esm/components/tag/tag.js
var import_jsx_runtime328 = __toESM(require_jsx_runtime(), 1);
var {
  withProvider: withProvider37,
  withContext: withContext52,
  useStyles: useTagStyles,
  PropsProvider: PropsProvider55
} = createSlotRecipeContext({ key: "tag" });
var TagRoot = withProvider37(
  "div",
  "root"
);
var TagRootPropsProvider = PropsProvider55;
var TagLabel = withContext52(
  "span",
  "label"
);
var TagCloseTrigger = withContext52("button", "closeTrigger", { defaultProps: { children: (0, import_jsx_runtime328.jsx)(CloseIcon, {}) } });
var TagStartElement = withContext52("span", "startElement");
var TagEndElement = withContext52(
  "span",
  "endElement"
);

// node_modules/@chakra-ui/react/dist/esm/components/tag/namespace.js
var namespace_exports44 = {};
__export(namespace_exports44, {
  CloseTrigger: () => TagCloseTrigger,
  EndElement: () => TagEndElement,
  Label: () => TagLabel,
  Root: () => TagRoot,
  RootPropsProvider: () => TagRootPropsProvider,
  StartElement: () => TagStartElement
});

// node_modules/@chakra-ui/react/dist/esm/components/textarea/textarea.js
var { withContext: withContext53, PropsProvider: PropsProvider56 } = createRecipeContext({
  key: "textarea"
});
var Textarea = withContext53(
  field_exports.Textarea
);
var TextareaPropsProvider = PropsProvider56;

// node_modules/@chakra-ui/react/dist/esm/components/timeline/timeline.js
var {
  withProvider: withProvider38,
  withContext: withContext54,
  useStyles: useTimelineStyles,
  PropsProvider: PropsProvider57
} = createSlotRecipeContext({ key: "timeline" });
var TimelineRoot = withProvider38(
  "div",
  "root",
  { defaultProps: { role: "list" } }
);
var TimelineRootPropsProvider = PropsProvider57;
var TimelineItem = withContext54(
  "div",
  "item",
  { defaultProps: { role: "listitem" } }
);
var TimelineSeparator = withContext54("div", "separator");
var TimelineIndicator = withContext54("div", "indicator");
var TimelineContent = withContext54("div", "content");
var TimelineTitle = withContext54(
  "div",
  "title"
);
var TimelineDescription = withContext54("div", "description");
var TimelineConnector = withContext54("div", "connector");

// node_modules/@chakra-ui/react/dist/esm/components/timeline/namespace.js
var namespace_exports45 = {};
__export(namespace_exports45, {
  Connector: () => TimelineConnector,
  Content: () => TimelineContent,
  Description: () => TimelineDescription,
  Indicator: () => TimelineIndicator,
  Item: () => TimelineItem,
  Root: () => TimelineRoot,
  RootPropsProvider: () => TimelineRootPropsProvider,
  Separator: () => TimelineSeparator,
  Title: () => TimelineTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/toast/toast.js
var import_jsx_runtime335 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/toast/dist/index.mjs
var anatomy27 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts30 = anatomy27.build();
var dom27 = createScope({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom27.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom27.getById(ctx, dom27.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
function getToastsByPlacement(toasts, placement) {
  return toasts.filter((toast) => toast.state.context.placement === placement);
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
function getGroupPlacementStyle(ctx, placement) {
  var _a8;
  const offset3 = ctx.offsets;
  const computedOffset = typeof offset3 === "string" ? { left: offset3, right: offset3, bottom: offset3, top: offset3 } : offset3;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${ctx.gap}px`,
    "--first-height": `${((_a8 = ctx.heights[0]) == null ? void 0 : _a8.height) || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset22 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset22})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset22 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset22})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset22 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset22})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset22 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset22})`;
  }
  return styles;
}
function getPlacementStyle(ctx, visible) {
  const [side] = ctx.placement.split("-");
  const sibling = !ctx.frontmost;
  const overlap = !ctx.stacked;
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${ctx.removeDelay}ms`,
    "--duration": `${ctx.type === "loading" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,
    "--initial-height": `${ctx.height}px`,
    "--offset": `${ctx.offset}px`,
    "--index": ctx.index,
    "--z-index": ctx.zIndex,
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (ctx.mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (ctx.stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && ctx.stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (ctx.frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(ctx, visible) {
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (ctx.frontmost && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle(_ctx, _visible) {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(serviceOrState, send, normalize2) {
  function getState() {
    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;
    return result;
  }
  function getToastsByPlacementImpl(placement) {
    return getToastsByPlacement(getState().context.toasts, placement);
  }
  function isVisible(id) {
    const toasts = getState().context.toasts;
    if (!toasts.length) return false;
    return !!toasts.find((toast) => toast.id == id);
  }
  function create(options) {
    const uid = `toast:${uuid()}`;
    const id = options.id ? options.id : uid;
    if (isVisible(id)) return id;
    send({ type: "ADD_TOAST", toast: { ...options, id } });
    return id;
  }
  function update(id, options) {
    if (!isVisible(id)) return id;
    send({ type: "UPDATE_TOAST", id, toast: options });
    return id;
  }
  function upsert(options) {
    const { id } = options;
    const visible = id ? isVisible(id) : false;
    if (visible && id != null) {
      return update(id, options);
    } else {
      return create(options);
    }
  }
  function dismiss(id) {
    if (id == null) {
      send("DISMISS_ALL");
    } else if (isVisible(id)) {
      send({ type: "DISMISS_TOAST", id });
    }
  }
  return {
    getCount() {
      return getState().context.count;
    },
    getPlacements() {
      const toasts = getState().context.toasts;
      const placements2 = toasts.map((toast) => toast.state.context.placement);
      return Array.from(new Set(placements2));
    },
    getToastsByPlacement: getToastsByPlacementImpl,
    isVisible,
    create,
    update,
    upsert,
    dismiss,
    remove(id) {
      if (id == null) {
        send("REMOVE_ALL");
      } else if (isVisible(id)) {
        send({ type: "REMOVE_TOAST", id });
      }
    },
    dismissByPlacement(placement) {
      const toasts = getToastsByPlacementImpl(placement);
      toasts.forEach((toast) => dismiss(toast.id));
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise, options, shared = {}) {
      const id = upsert({ ...shared, ...options.loading, type: "loading" });
      runIfFn(promise).then((response) => {
        const successOptions = runIfFn(options.success, response);
        upsert({ ...shared, ...successOptions, id, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        upsert({ ...shared, ...errorOptions, id, type: "error" });
      }).finally(() => {
        var _a8;
        (_a8 = options.finally) == null ? void 0 : _a8.call(options);
      });
      return id;
    },
    pause(id) {
      if (id == null) {
        send("PAUSE_ALL");
      } else if (isVisible(id)) {
        send({ type: "PAUSE_TOAST", id });
      }
    },
    resume(id) {
      if (id == null) {
        send("RESUME_ALL");
      } else if (isVisible(id)) {
        send({ type: "RESUME_TOAST", id });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      const state2 = getState();
      const hotkeyLabel = state2.context.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const [side, align = "center"] = placement.split("-");
      return normalize2.element({
        ...parts30.group.attrs,
        dir: state2.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: dom27.getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state2.context, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (state2.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {
            send({ type: "REGION.BLUR" });
          }
        }
      });
    },
    subscribe(fn) {
      const state2 = getState();
      return subscribe(state2.context.toasts, () => {
        const toasts = getToastsByPlacementImpl(state2.context.placement);
        const contexts = toasts.map((toast) => toast.getState().context);
        fn(contexts);
      });
    }
  };
}
var { not: not12, and: and10, or: or4 } = guards;
function createToastMachine(options) {
  const { type = "info", duration, id = "1", placement = "bottom", removeDelay = 200, ...restProps } = options;
  const ctx = compact2(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine(
    {
      id,
      context: {
        id,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx,
        height: 0,
        offset: 0,
        frontmost: false,
        mounted: false,
        index: -1,
        zIndex: 0
      },
      initial: type === "loading" ? "visible:persist" : "visible",
      on: {
        UPDATE: [
          {
            guard: and10("hasTypeChanged", "isChangingToLoading"),
            target: "visible:persist",
            actions: ["setContext"]
          },
          {
            guard: or4("hasDurationChanged", "hasTypeChanged"),
            target: "visible:updating",
            actions: ["setContext"]
          },
          {
            actions: ["setContext"]
          }
        ],
        MEASURE: {
          actions: ["measureHeight"]
        }
      },
      entry: ["invokeOnVisible"],
      activities: ["trackHeight"],
      states: {
        "visible:updating": {
          tags: ["visible", "updating"],
          after: {
            0: "visible"
          }
        },
        "visible:persist": {
          tags: ["visible", "paused"],
          on: {
            RESUME: {
              guard: not12("isLoadingType"),
              target: "visible",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        visible: {
          tags: ["visible"],
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "visible:persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnDismiss",
          after: {
            REMOVE_DELAY: {
              target: "unmounted",
              actions: "notifyParentToRemove"
            }
          }
        },
        unmounted: {
          entry: "invokeOnUnmount",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackHeight(ctx2, _evt, { self: self2 }) {
          let cleanup;
          raf(() => {
            const rootEl = dom27.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const ghosts = queryAll(rootEl, "[data-ghost]");
            warn(
              ghosts.length !== 2,
              "[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements"
            );
            const syncHeight = () => {
              const originalHeight = rootEl.style.height;
              rootEl.style.height = "auto";
              const newHeight = rootEl.getBoundingClientRect().height;
              rootEl.style.height = originalHeight;
              ctx2.height = newHeight;
              self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
            };
            syncHeight();
            const win = dom27.getWin(ctx2);
            const observer = new win.MutationObserver(syncHeight);
            observer.observe(rootEl, { childList: true, subtree: true, characterData: true });
            cleanup = () => observer.disconnect();
          });
          return () => cleanup == null ? void 0 : cleanup();
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => {
          var _a8;
          return ((_a8 = evt.toast) == null ? void 0 : _a8.type) === "loading";
        },
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => {
          var _a8;
          return ((_a8 = evt.toast) == null ? void 0 : _a8.type) != null && evt.toast.type !== ctx2.type;
        },
        hasDurationChanged: (ctx2, evt) => {
          var _a8;
          return ((_a8 = evt.toast) == null ? void 0 : _a8.duration) != null && evt.toast.duration !== ctx2.duration;
        }
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        measureHeight(ctx2, _evt, { self: self2 }) {
          raf(() => {
            const rootEl = dom27.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const newHeight = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            ctx2.height = newHeight;
            self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
          });
        },
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self: self2 }) {
          self2.sendParent({ type: "REMOVE_TOAST", id: self2.id });
        },
        invokeOnDismiss(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "dismissing" });
        },
        invokeOnUnmount(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "unmounted" });
        },
        invokeOnVisible(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "visible" });
        },
        setContext(ctx2, evt) {
          var _a8, _b7;
          const duration2 = (_a8 = evt.toast) == null ? void 0 : _a8.duration;
          const type2 = ((_b7 = evt.toast) == null ? void 0 : _b7.type) ?? ctx2.type;
          const computedDuration2 = getToastDuration(duration2, type2);
          Object.assign(ctx2, {
            ...evt.toast,
            duration: computedDuration2,
            remaining: computedDuration2
          });
        }
      }
    }
  );
}
function groupMachine(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "toaster",
      initial: ctx.overlap ? "overlap" : "stack",
      context: {
        dir: "ltr",
        max: Number.MAX_SAFE_INTEGER,
        gap: 16,
        pauseOnPageIdle: false,
        hotkey: ["altKey", "KeyT"],
        offsets: "1rem",
        placement: "bottom",
        removeDelay: 200,
        ...ctx,
        toasts: [],
        lastFocusedEl: null,
        isFocusWithin: false,
        heights: []
      },
      computed: {
        count: (ctx2) => ctx2.toasts.length
      },
      activities: ["trackDocumentVisibility", "trackHotKeyPress"],
      watch: {
        toasts: ["collapsedIfEmpty", "setDismissableBranch"]
      },
      exit: ["removeToasts", "clearDismissableBranch", "clearLastFocusedEl"],
      on: {
        PAUSE_TOAST: {
          actions: ["pauseToast"]
        },
        PAUSE_ALL: {
          actions: ["pauseToasts"]
        },
        RESUME_TOAST: {
          actions: ["resumeToast"]
        },
        RESUME_ALL: {
          actions: ["resumeToasts"]
        },
        ADD_TOAST: {
          guard: "isWithinRange",
          actions: ["createToast", "syncToastIndex"]
        },
        UPDATE_TOAST: {
          actions: ["updateToast"]
        },
        DISMISS_TOAST: {
          actions: ["dismissToast"]
        },
        DISMISS_ALL: {
          actions: ["dismissToasts"]
        },
        REMOVE_TOAST: {
          actions: ["removeToast", "syncToastIndex", "syncToastOffset"]
        },
        REMOVE_ALL: {
          actions: ["removeToasts"]
        },
        UPDATE_HEIGHT: {
          actions: ["syncHeights", "syncToastOffset"]
        },
        "DOC.HOTKEY": {
          actions: ["focusRegionEl"]
        },
        "REGION.BLUR": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          },
          {
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          }
        ]
      },
      states: {
        stack: {
          entry: ["expandToasts"],
          on: {
            "REGION.POINTER_LEAVE": [
              {
                guard: "isOverlapping",
                target: "overlap",
                actions: ["resumeToasts"]
              },
              {
                actions: ["resumeToasts"]
              }
            ],
            "REGION.OVERLAP": {
              target: "overlap"
            },
            "REGION.FOCUS": {
              actions: ["setLastFocusedEl", "pauseToasts"]
            },
            "REGION.POINTER_ENTER": {
              actions: ["pauseToasts"]
            }
          }
        },
        overlap: {
          entry: ["collapseToasts"],
          on: {
            "REGION.STACK": {
              target: "stack"
            },
            "REGION.POINTER_ENTER": {
              target: "stack",
              actions: ["pauseToasts"]
            },
            "REGION.FOCUS": {
              target: "stack",
              actions: ["setLastFocusedEl", "pauseToasts"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2) => ctx2.toasts.length < ctx2.max,
        isOverlapping: (ctx2) => !!ctx2.overlap
      },
      activities: {
        trackHotKeyPress(ctx2, _evt, { send }) {
          const handleKeyDown = (event) => {
            const isHotkeyPressed = ctx2.hotkey.every((key) => event[key] || event.code === key);
            if (!isHotkeyPressed) return;
            send({ type: "DOC.HOTKEY" });
          };
          return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle) return;
          const doc = dom27.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE_ALL" : "RESUME_ALL");
          });
        }
      },
      actions: {
        setDismissableBranch(ctx2) {
          var _a8;
          const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);
          const hasToasts = currentToasts.length > 0;
          if (!hasToasts) {
            (_a8 = ctx2._cleanup) == null ? void 0 : _a8.call(ctx2);
            return;
          }
          if (hasToasts && ctx2._cleanup) {
            return;
          }
          const groupEl = () => dom27.getRegionEl(ctx2, ctx2.placement);
          ctx2._cleanup = trackDismissableBranch(groupEl, { defer: true });
        },
        clearDismissableBranch(ctx2) {
          var _a8;
          (_a8 = ctx2._cleanup) == null ? void 0 : _a8.call(ctx2);
        },
        focusRegionEl(ctx2) {
          queueMicrotask(() => {
            var _a8;
            (_a8 = dom27.getRegionEl(ctx2, ctx2.placement)) == null ? void 0 : _a8.focus();
          });
        },
        expandToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = true;
          });
        },
        collapseToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = false;
          });
        },
        collapsedIfEmpty(ctx2, _evt, { send }) {
          if (!ctx2.overlap || ctx2.toasts.length > 1) return;
          send("REGION.OVERLAP");
        },
        pauseToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("PAUSE", evt.id);
        },
        pauseToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        },
        resumeToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("RESUME", evt.id);
        },
        resumeToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        },
        measureToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("MEASURE"));
        },
        createToast(ctx2, evt, { self: self2, getState }) {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            ...evt.toast,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode,
            stacked: getState().matches("stack")
          };
          const toast = createToastMachine(options);
          const actor = self2.spawn(toast);
          ctx2.toasts = [actor, ...ctx2.toasts];
        },
        updateToast(_ctx, evt, { self: self2 }) {
          self2.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        },
        dismissToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("DISMISS", evt.id);
        },
        dismissToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        },
        removeToast(ctx2, evt, { self: self2 }) {
          self2.stopChild(evt.id);
          ctx2.toasts = ctx2.toasts.filter((toast) => toast.id !== evt.id);
          ctx2.heights = ctx2.heights.filter((height) => height.id !== evt.id);
        },
        removeToasts(ctx2, _evt, { self: self2 }) {
          ctx2.toasts.forEach((toast) => self2.stopChild(toast.id));
          ctx2.toasts = [];
          ctx2.heights = [];
        },
        syncHeights(ctx2, evt) {
          const existing = ctx2.heights.find((height) => height.id === evt.id);
          if (existing) {
            existing.height = evt.height;
            existing.placement = evt.placement;
          } else {
            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement };
            ctx2.heights = [newHeight, ...ctx2.heights];
          }
        },
        syncToastIndex(ctx2) {
          each(ctx2, (toast, index, toasts) => {
            toast.state.context.index = index;
            toast.state.context.frontmost = index === 0;
            toast.state.context.zIndex = toasts.length - index;
          });
        },
        syncToastOffset(ctx2, evt) {
          const placement = evt.placement ?? ctx2.placement;
          each({ ...ctx2, placement }, (toast) => {
            const heightIndex = Math.max(
              ctx2.heights.findIndex((height) => height.id === toast.id),
              0
            );
            const toastsHeightBefore = ctx2.heights.reduce((prev2, curr, reducerIndex) => {
              if (reducerIndex >= heightIndex) return prev2;
              return prev2 + curr.height;
            }, 0);
            toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;
          });
        },
        setLastFocusedEl(ctx2, evt) {
          if (ctx2.isFocusWithin || !evt.target) return;
          ctx2.isFocusWithin = true;
          ctx2.lastFocusedEl = ref(evt.target);
        },
        restoreLastFocusedEl(ctx2) {
          ctx2.isFocusWithin = false;
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
        },
        clearLastFocusedEl(ctx2) {
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
          ctx2.isFocusWithin = false;
        }
      }
    }
  );
}
function each(ctx, fn) {
  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);
  currentToasts.forEach(fn);
}
function connect27(state2, send, normalize2) {
  const visible = state2.hasTag("visible");
  const paused = state2.hasTag("paused");
  const placement = state2.context.placement;
  const type = state2.context.type;
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title: state2.context.title,
    description: state2.context.description,
    placement,
    visible,
    paused,
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    getRootProps() {
      return normalize2.element({
        ...parts30.root.attrs,
        dir: state2.context.dir,
        id: dom27.getRootId(state2.context),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(state2.context.mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(state2.context.frontmost),
        "data-sibling": dataAttr(!state2.context.frontmost),
        "data-stack": dataAttr(state2.context.stacked),
        "data-overlap": dataAttr(!state2.context.stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": state2.context.description ? dom27.getDescriptionId(state2.context) : void 0,
        "aria-labelledby": state2.context.title ? dom27.getTitleId(state2.context) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(state2.context, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send("DISMISS");
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize2.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(state2.context, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize2.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts30.title.attrs,
        id: dom27.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts30.description.attrs,
        id: dom27.getDescriptionId(state2.context)
      });
    },
    getActionTriggerProps() {
      return normalize2.button({
        ...parts30.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          var _a8, _b7;
          if (event.defaultPrevented) return;
          (_b7 = (_a8 = state2.context.action) == null ? void 0 : _a8.onClick) == null ? void 0 : _b7.call(_a8);
          send("DISMISS");
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        id: dom27.getCloseTriggerId(state2.context),
        ...parts30.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("DISMISS");
        }
      });
    }
  };
}
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// node_modules/@ark-ui/react/dist/components/toast/create-toaster.js
var createToaster = (props25) => {
  const machine27 = group.machine({ id: "1", ...props25 });
  const api = group.connect(machine27, machine27.send, normalizeProps);
  return { ...api, machine: machine27 };
};

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var import_jsx_runtime329 = __toESM(require_jsx_runtime(), 1);
var import_react644 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toast/use-toast-context.js
var [ToastProvider, useToastContext] = createContext3({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var ToastActionTrigger = (0, import_react644.forwardRef)(
  (props25, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps2(toast.getActionTriggerProps(), props25);
    return (0, import_jsx_runtime329.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastActionTrigger.displayName = "ToastActionTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-close-trigger.js
var import_jsx_runtime330 = __toESM(require_jsx_runtime(), 1);
var import_react646 = __toESM(require_react(), 1);
var ToastCloseTrigger = (0, import_react646.forwardRef)(
  (props25, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps2(toast.getCloseTriggerProps(), props25);
    return (0, import_jsx_runtime330.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastCloseTrigger.displayName = "ToastCloseTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-context.js
var ToastContext = (props25) => props25.children(useToastContext());

// node_modules/@ark-ui/react/dist/components/toast/toast-description.js
var import_jsx_runtime331 = __toESM(require_jsx_runtime(), 1);
var import_react648 = __toESM(require_react(), 1);
var ToastDescription = (0, import_react648.forwardRef)((props25, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getDescriptionProps(), props25);
  return (0, import_jsx_runtime331.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ToastDescription.displayName = "ToastDescription";

// node_modules/@ark-ui/react/dist/components/toast/toast-root.js
var import_jsx_runtime332 = __toESM(require_jsx_runtime(), 1);
var import_react650 = __toESM(require_react(), 1);
var ToastRoot = (0, import_react650.forwardRef)((props25, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getRootProps(), props25);
  return (0, import_jsx_runtime332.jsxs)("div", { ...mergedProps, ref: ref2, children: [
    (0, import_jsx_runtime332.jsx)("div", { ...toast.getGhostBeforeProps() }),
    props25.children,
    (0, import_jsx_runtime332.jsx)("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot.displayName = "ToastRoot";

// node_modules/@ark-ui/react/dist/components/toast/toast-title.js
var import_jsx_runtime333 = __toESM(require_jsx_runtime(), 1);
var import_react652 = __toESM(require_react(), 1);
var ToastTitle = (0, import_react652.forwardRef)((props25, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps2(toast.getTitleProps(), props25);
  return (0, import_jsx_runtime333.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@ark-ui/react/dist/components/toast/toaster.js
var import_jsx_runtime334 = __toESM(require_jsx_runtime(), 1);
var import_react654 = __toESM(require_react(), 1);
var Toaster = (0, import_react654.forwardRef)((props25, ref2) => {
  const { toaster, children, ...rest } = props25;
  const [state2, send] = useMachine(toaster.machine);
  const placement = state2.context.placement;
  const api = group.connect(state2, send, normalizeProps);
  const toasts = api.getToastsByPlacement(placement);
  const mergedProps = mergeProps2(api.getGroupProps({ placement }), rest);
  return (0, import_jsx_runtime334.jsx)(ark.div, { ...mergedProps, ref: ref2, children: toasts.map((toast2) => (0, import_jsx_runtime334.jsx)(ToastActor, { value: toast2, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster.displayName = "Toaster";
var ToastActor = (props25) => {
  const [state2, send] = useActor(props25.value);
  const api = connect27(state2, send, normalizeProps);
  return (0, import_jsx_runtime334.jsx)(ToastProvider, { value: api, children: props25.children(state2.context) });
};

// node_modules/@ark-ui/react/dist/components/toast/toast.js
var toast_exports = {};
__export(toast_exports, {
  ActionTrigger: () => ToastActionTrigger,
  CloseTrigger: () => ToastCloseTrigger,
  Context: () => ToastContext,
  Description: () => ToastDescription,
  Root: () => ToastRoot,
  Title: () => ToastTitle
});

// node_modules/@chakra-ui/react/dist/esm/components/toast/toast.js
var import_react655 = __toESM(require_react(), 1);
var {
  withProvider: withProvider39,
  withContext: withContext55,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
var Toaster2 = chakra(
  Toaster,
  {},
  { forwardAsChild: true }
);
var ToastRoot2 = withProvider39(
  toast_exports.Root,
  "root",
  { forwardAsChild: true }
);
var ToastCloseTrigger2 = withContext55(toast_exports.CloseTrigger, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: (0, import_jsx_runtime335.jsx)(CloseIcon, {})
  }
});
var ToastTitle2 = withContext55(
  toast_exports.Title,
  "title",
  { forwardAsChild: true }
);
var ToastDescription2 = withContext55(toast_exports.Description, "description", { forwardAsChild: true });
var ToastActionTrigger2 = withContext55(toast_exports.ActionTrigger, "actionTrigger", { forwardAsChild: true });
var iconMap2 = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
var ToastIndicator = (0, import_react655.forwardRef)(
  function ToastIndicator2(props25, ref2) {
    const api = useToastContext();
    const styles = useToastStyles();
    const Component = iconMap2[api.type];
    if (!Component) return null;
    return (0, import_jsx_runtime335.jsx)(Component, { ref: ref2, ...props25, css: [styles.indicator, props25.css] });
  }
);

// node_modules/@chakra-ui/react/dist/esm/components/toast/namespace.js
var namespace_exports46 = {};
__export(namespace_exports46, {
  ActionTrigger: () => ToastActionTrigger2,
  CloseTrigger: () => ToastCloseTrigger2,
  Description: () => ToastDescription2,
  Indicator: () => ToastIndicator,
  Root: () => ToastRoot2,
  Title: () => ToastTitle2
});

// node_modules/@ark-ui/react/dist/components/toggle/toggle.js
var toggle_exports = {};
__export(toggle_exports, {
  Context: () => ToggleContext,
  Indicator: () => ToggleIndicator,
  Root: () => ToggleRoot,
  toggleAnatomy: () => toggleAnatomy
});

// node_modules/@ark-ui/react/dist/components/toggle/use-toggle-context.js
var [ToggleProvider, useToggleContext] = createContext3({
  name: "ToggleContext",
  hookName: "useToggleContext",
  providerName: "<ToggleProvider />"
});

// node_modules/@ark-ui/react/dist/components/toggle/toggle-context.js
var ToggleContext = (props25) => props25.children(useToggleContext());

// node_modules/@ark-ui/react/dist/components/toggle/toggle-indicator.js
var import_jsx_runtime336 = __toESM(require_jsx_runtime(), 1);
var import_react657 = __toESM(require_react(), 1);
var ToggleIndicator = (0, import_react657.forwardRef)((props25, ref2) => {
  const { children, fallback: fallback3, ...restProps } = props25;
  const toggle = useToggleContext();
  const mergedProps = mergeProps2(toggle.getIndicatorProps(), restProps);
  return (0, import_jsx_runtime336.jsx)(ark.div, { ...mergedProps, ref: ref2, children: toggle.pressed ? children : fallback3 });
});
ToggleIndicator.displayName = "ToggleIndicator";

// node_modules/@ark-ui/react/dist/components/toggle/toggle-root.js
var import_jsx_runtime337 = __toESM(require_jsx_runtime(), 1);
var import_react659 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toggle/toggle.anatomy.js
var toggleAnatomy = createAnatomy("toggle", ["root", "indicator"]);
var parts31 = toggleAnatomy.build();

// node_modules/@ark-ui/react/dist/components/toggle/use-toggle.js
function useToggle(props25) {
  const { defaultPressed, pressed, onPressedChange, disabled } = props25;
  const [pressedState, setPressedState] = useControllableState2({
    defaultValue: !!defaultPressed,
    value: pressed,
    onChange: onPressedChange
  });
  return {
    pressed: pressedState,
    disabled: !!disabled,
    setPressed: setPressedState,
    getRootProps() {
      return {
        ...parts31.root.attrs,
        type: "button",
        disabled,
        "aria-pressed": pressedState,
        "data-state": pressedState ? "on" : "off",
        "data-pressed": dataAttr(pressedState),
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          setPressedState(!pressedState);
        }
      };
    },
    getIndicatorProps() {
      return {
        ...parts31.indicator.attrs,
        "data-disabled": dataAttr(disabled),
        "data-pressed": dataAttr(pressedState),
        "data-state": pressedState ? "on" : "off"
      };
    }
  };
}

// node_modules/@ark-ui/react/dist/components/toggle/toggle-root.js
var ToggleRoot = (0, import_react659.forwardRef)((props25, ref2) => {
  const [useToggleProps, localProps] = createSplitProps2()(props25, [
    "pressed",
    "defaultPressed",
    "disabled",
    "onPressedChange"
  ]);
  const toggle = useToggle(useToggleProps);
  const mergedProps = mergeProps2(toggle.getRootProps(), localProps);
  return (0, import_jsx_runtime337.jsx)(ToggleProvider, { value: toggle, children: (0, import_jsx_runtime337.jsx)(ark.button, { ...mergedProps, ref: ref2 }) });
});
ToggleRoot.displayName = "ToggleRoot";

// node_modules/@chakra-ui/react/dist/esm/components/toggle/toggle.js
var {
  withProvider: withProvider40,
  withContext: withContext56,
  useStyles: useToggleStyles,
  PropsProvider: PropsProvider58
} = createSlotRecipeContext({ key: "toggle" });
var ToggleRootProvider = withProvider40(toggle_exports.Root, "root", { forwardAsChild: true });
var ToggleRoot2 = withProvider40(
  toggle_exports.Root,
  "root",
  { forwardAsChild: true }
);
var TogglePropsProvider = PropsProvider58;
var ToggleIndicator2 = withContext56(toggle_exports.Indicator, "indicator", { forwardAsChild: true });
var ToggleContext2 = toggle_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/toggle/namespace.js
var namespace_exports47 = {};
__export(namespace_exports47, {
  Context: () => ToggleContext2,
  Indicator: () => ToggleIndicator2,
  PropsProvider: () => TogglePropsProvider,
  Root: () => ToggleRoot2
});

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/tooltip.js
var {
  withRootProvider: withRootProvider7,
  withContext: withContext57,
  useStyles: useTooltipStyles,
  PropsProvider: PropsProvider59
} = createSlotRecipeContext({ key: "tooltip" });
var TooltipRootProvider2 = withRootProvider7(
  tooltip_exports.RootProvider
);
var TooltipRoot2 = withRootProvider7(tooltip_exports.Root);
var TooltipPropsProvider = PropsProvider59;
var TooltipTrigger2 = withContext57(tooltip_exports.Trigger, "trigger", { forwardAsChild: true });
var TooltipPositioner2 = withContext57(tooltip_exports.Positioner, "positioner", { forwardAsChild: true });
var TooltipContent2 = withContext57(
  tooltip_exports.Content,
  "content",
  { forwardAsChild: true }
);
var TooltipArrow2 = withContext57(
  tooltip_exports.Arrow,
  "arrow",
  { forwardAsChild: true }
);
var TooltipArrowTip2 = withContext57(tooltip_exports.ArrowTip, "arrowTip", { forwardAsChild: true });
var TooltipContext2 = tooltip_exports.Context;

// node_modules/@chakra-ui/react/dist/esm/components/tooltip/namespace.js
var namespace_exports48 = {};
__export(namespace_exports48, {
  Arrow: () => TooltipArrow2,
  ArrowTip: () => TooltipArrowTip2,
  Content: () => TooltipContent2,
  Context: () => TooltipContext2,
  Positioner: () => TooltipPositioner2,
  PropsProvider: () => TooltipPropsProvider,
  Root: () => TooltipRoot2,
  RootProvider: () => TooltipRootProvider2,
  Trigger: () => TooltipTrigger2
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/heading.js
var { withContext: withContext58, PropsProvider: PropsProvider60 } = createRecipeContext({
  key: "heading"
});
var Heading = withContext58("h2");
var HeadingPropsProvider = PropsProvider60;

// node_modules/@chakra-ui/react/dist/esm/components/typography/text.js
var { withContext: withContext59, PropsProvider: PropsProvider61 } = createRecipeContext({
  key: "text"
});
var Text = withContext59("p");
var TextPropsProvider = PropsProvider61;

// node_modules/@chakra-ui/react/dist/esm/components/typography/em.js
var Em = chakra("em", {
  base: {
    fontStyle: "italic"
  }
});

// node_modules/@chakra-ui/react/dist/esm/components/typography/strong.js
var Strong = chakra("strong", {
  base: { fontWeight: "semibold" }
});

// node_modules/@chakra-ui/react/dist/esm/components/visually-hidden/visually-hidden.js
var visuallyHiddenStyle2 = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var VisuallyHidden = chakra("span", {
  base: visuallyHiddenStyle2
});
VisuallyHidden.displayName = "VisuallyHidden";
export {
  AbsoluteCenter,
  namespace_exports as Accordion,
  AccordionContext2 as AccordionContext,
  AccordionItem2 as AccordionItem,
  AccordionItemBody,
  AccordionItemContent2 as AccordionItemContent,
  AccordionItemContext2 as AccordionItemContext,
  AccordionItemIndicator2 as AccordionItemIndicator,
  AccordionItemTrigger2 as AccordionItemTrigger,
  AccordionPropsProvider,
  AccordionRoot2 as AccordionRoot,
  AccordionRootProvider2 as AccordionRootProvider,
  namespace_exports2 as ActionBar,
  ActionBarCloseTrigger,
  ActionBarContent,
  ActionBarContext,
  ActionBarPositioner,
  ActionBarPropsProvider,
  ActionBarRoot,
  ActionBarRootProvider,
  ActionBarSelectionTrigger,
  ActionBarSeparator,
  namespace_exports3 as Alert,
  AlertContent,
  AlertDescription,
  AlertIndicator,
  AlertPropsProvider,
  AlertRoot,
  AlertTitle,
  AspectRatio,
  namespace_exports4 as Avatar,
  AvatarContext2 as AvatarContext,
  AvatarFallback2 as AvatarFallback,
  AvatarIcon,
  AvatarImage2 as AvatarImage,
  AvatarPropsProvider,
  AvatarRoot2 as AvatarRoot,
  AvatarRootProvider2 as AvatarRootProvider,
  Badge,
  BadgePropsProvider,
  Bleed,
  namespace_exports5 as Blockquote,
  BlockquoteCaption,
  BlockquoteContent,
  BlockquoteIcon,
  BlockquotePropsProvider,
  BlockquoteRoot,
  Box,
  namespace_exports6 as Breadcrumb,
  BreadcrumbCurrentLink,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPropsProvider,
  BreadcrumbRoot,
  BreadcrumbSeparator,
  Button,
  ButtonGroup,
  ButtonPropsProvider,
  namespace_exports7 as Card,
  CardBody,
  CardDescription,
  CardFooter,
  CardHeader,
  CardPropsProvider,
  CardRoot,
  CardTitle,
  Center,
  ChakraProvider,
  namespace_exports8 as Checkbox,
  namespace_exports9 as CheckboxCard,
  CheckboxCardAddon,
  CheckboxCardContent,
  CheckboxCardContext,
  CheckboxCardControl,
  CheckboxCardDescription,
  CheckboxCardHiddenInput,
  CheckboxCardIndicator,
  CheckboxCardLabel,
  CheckboxCardRoot,
  CheckboxCardRootPropsProvider,
  CheckboxCardRootProvider,
  CheckboxContext2 as CheckboxContext,
  CheckboxControl2 as CheckboxControl,
  CheckboxGroup2 as CheckboxGroup,
  CheckboxHiddenInput2 as CheckboxHiddenInput,
  CheckboxIndicator2 as CheckboxIndicator,
  CheckboxLabel2 as CheckboxLabel,
  CheckboxPropsProvider,
  CheckboxRoot2 as CheckboxRoot,
  CheckboxRootProvider2 as CheckboxRootProvider,
  Checkmark,
  Circle,
  ClientOnly,
  namespace_exports10 as Clipboard,
  ClipboardContext2 as ClipboardContext,
  ClipboardControl2 as ClipboardControl,
  ClipboardIndicator2 as ClipboardIndicator,
  ClipboardInput2 as ClipboardInput,
  ClipboardLabel2 as ClipboardLabel,
  ClipboardPropsProvider,
  ClipboardRoot2 as ClipboardRoot,
  ClipboardRootProvider2 as ClipboardRootProvider,
  ClipboardTrigger2 as ClipboardTrigger,
  ClipboardValueText2 as ClipboardValueText,
  Code,
  CodePropsProvider,
  namespace_exports11 as Collapsible,
  CollapsibleContent2 as CollapsibleContent,
  CollapsibleContext2 as CollapsibleContext,
  CollapsiblePropsProvider,
  CollapsibleRoot2 as CollapsibleRoot,
  CollapsibleRootProvider2 as CollapsibleRootProvider,
  CollapsibleTrigger2 as CollapsibleTrigger,
  namespace_exports12 as ColorPicker,
  ColorPickerArea2 as ColorPickerArea,
  ColorPickerAreaBackground2 as ColorPickerAreaBackground,
  ColorPickerAreaThumb2 as ColorPickerAreaThumb,
  ColorPickerChannelInput2 as ColorPickerChannelInput,
  ColorPickerChannelSlider2 as ColorPickerChannelSlider,
  ColorPickerChannelSliderLabel2 as ColorPickerChannelSliderLabel,
  ColorPickerChannelSliderThumb2 as ColorPickerChannelSliderThumb,
  ColorPickerChannelSliderTrack2 as ColorPickerChannelSliderTrack,
  ColorPickerChannelSliderValueText2 as ColorPickerChannelSliderValueText,
  ColorPickerContent2 as ColorPickerContent,
  ColorPickerContext2 as ColorPickerContext,
  ColorPickerControl2 as ColorPickerControl,
  ColorPickerEyeDropperTrigger2 as ColorPickerEyeDropperTrigger,
  ColorPickerFormatSelect2 as ColorPickerFormatSelect,
  ColorPickerFormatTrigger2 as ColorPickerFormatTrigger,
  ColorPickerHiddenInput2 as ColorPickerHiddenInput,
  ColorPickerLabel2 as ColorPickerLabel,
  ColorPickerPositioner2 as ColorPickerPositioner,
  ColorPickerPropsProvider,
  ColorPickerRoot2 as ColorPickerRoot,
  ColorPickerRootProvider2 as ColorPickerRootProvider,
  ColorPickerSwatch2 as ColorPickerSwatch,
  ColorPickerSwatchGroup2 as ColorPickerSwatchGroup,
  ColorPickerSwatchIndicator2 as ColorPickerSwatchIndicator,
  ColorPickerSwatchTrigger2 as ColorPickerSwatchTrigger,
  ColorPickerTransparencyGrid2 as ColorPickerTransparencyGrid,
  ColorPickerTrigger2 as ColorPickerTrigger,
  ColorPickerValueSwatch2 as ColorPickerValueSwatch,
  ColorPickerValueText2 as ColorPickerValueText,
  ColorPickerView2 as ColorPickerView,
  ColorSwatch,
  ColorSwatchMix,
  ColorSwatchPropsProvider,
  Container,
  ContainerPropsProvider,
  namespace_exports13 as DataList,
  DataListItem,
  DataListItemLabel,
  DataListItemValue,
  DataListPropsProvider,
  DataListRoot,
  namespace_exports14 as Dialog,
  DialogActionTrigger,
  DialogBackdrop2 as DialogBackdrop,
  DialogBody,
  DialogCloseTrigger2 as DialogCloseTrigger,
  DialogContent2 as DialogContent,
  DialogContext2 as DialogContext,
  DialogDescription2 as DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogPositioner2 as DialogPositioner,
  DialogPropsProvider,
  DialogRoot2 as DialogRoot,
  DialogRootProvider2 as DialogRootProvider,
  DialogTitle2 as DialogTitle,
  DialogTrigger2 as DialogTrigger,
  namespace_exports15 as Drawer,
  DrawerActionTrigger,
  DrawerBackdrop,
  DrawerBody,
  DrawerCloseTrigger,
  DrawerContent,
  DrawerContext,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerPositioner,
  DrawerRoot,
  DrawerRootPropsProvider,
  DrawerRootProvider,
  DrawerTitle,
  DrawerTrigger,
  EMPTY_SLOT_STYLES,
  EMPTY_STYLES,
  namespace_exports16 as Editable,
  EditableArea2 as EditableArea,
  EditableCancelTrigger2 as EditableCancelTrigger,
  EditableContext2 as EditableContext,
  EditableControl2 as EditableControl,
  EditableEditTrigger2 as EditableEditTrigger,
  EditableInput2 as EditableInput,
  EditablePreview2 as EditablePreview,
  EditablePropsProvider,
  EditableRoot2 as EditableRoot,
  EditableRootProvider2 as EditableRootProvider,
  EditableSubmitTrigger2 as EditableSubmitTrigger,
  EditableTextarea,
  Em,
  namespace_exports17 as EmptyState,
  EmptyStateContent,
  EmptyStateDescription,
  EmptyStateIndicator,
  EmptyStatePropsProvider,
  EmptyStateRoot,
  EmptyStateTitle,
  EnvironmentProvider,
  namespace_exports18 as Field,
  FieldErrorIcon,
  FieldErrorText2 as FieldErrorText,
  FieldHelperText2 as FieldHelperText,
  FieldLabel2 as FieldLabel,
  FieldPropsProvider,
  FieldRequiredIndicator2 as FieldRequiredIndicator,
  FieldRoot2 as FieldRoot,
  namespace_exports19 as Fieldset,
  FieldsetContent,
  FieldsetContext2 as FieldsetContext,
  FieldsetErrorText2 as FieldsetErrorText,
  FieldsetHelperText2 as FieldsetHelperText,
  FieldsetLegend2 as FieldsetLegend,
  FieldsetRoot2 as FieldsetRoot,
  namespace_exports20 as FileUpload,
  FileUploadClearTrigger2 as FileUploadClearTrigger,
  FileUploadContext2 as FileUploadContext,
  FileUploadDropzone2 as FileUploadDropzone,
  FileUploadDropzoneContent,
  FileUploadHiddenInput2 as FileUploadHiddenInput,
  FileUploadItem2 as FileUploadItem,
  FileUploadItemContent,
  FileUploadItemDeleteTrigger2 as FileUploadItemDeleteTrigger,
  FileUploadItemGroup2 as FileUploadItemGroup,
  FileUploadItemName2 as FileUploadItemName,
  FileUploadItemPreview2 as FileUploadItemPreview,
  FileUploadItemPreviewImage2 as FileUploadItemPreviewImage,
  FileUploadItemSizeText2 as FileUploadItemSizeText,
  FileUploadLabel2 as FileUploadLabel,
  FileUploadPropsProvider,
  FileUploadRoot2 as FileUploadRoot,
  FileUploadRootProvider2 as FileUploadRootProvider,
  FileUploadTrigger2 as FileUploadTrigger,
  Flex,
  Float,
  For,
  FormatByte2 as FormatByte,
  FormatNumber2 as FormatNumber,
  Grid,
  GridItem,
  Group,
  HStack,
  Heading,
  HeadingPropsProvider,
  Highlight2 as Highlight,
  namespace_exports21 as HoverCard,
  HoverCardArrow2 as HoverCardArrow,
  HoverCardArrowTip2 as HoverCardArrowTip,
  HoverCardContent2 as HoverCardContent,
  HoverCardContext2 as HoverCardContext,
  HoverCardPositioner2 as HoverCardPositioner,
  HoverCardPropsProvider,
  HoverCardRoot2 as HoverCardRoot,
  HoverCardRootProvider2 as HoverCardRootProvider,
  HoverCardTrigger2 as HoverCardTrigger,
  Icon,
  IconButton,
  IconPropsProvider,
  Image,
  Input,
  InputAddon,
  InputElement,
  InputPropsProvider,
  Kbd,
  Link,
  LinkBox,
  LinkOverlay,
  LinkPropsProvider,
  namespace_exports22 as List,
  ListIndicator,
  ListItem,
  ListRoot,
  ListRootPropsProvider,
  Loader,
  LoaderOverlay,
  LocaleProvider,
  Mark,
  MarkPropsProvider,
  namespace_exports23 as Menu,
  MenuArrow2 as MenuArrow,
  MenuArrowTip2 as MenuArrowTip,
  MenuCheckboxItem2 as MenuCheckboxItem,
  MenuContent2 as MenuContent,
  MenuContext2 as MenuContext,
  MenuContextTrigger2 as MenuContextTrigger,
  MenuIndicator2 as MenuIndicator,
  MenuItem2 as MenuItem,
  MenuItemCommand,
  MenuItemContext2 as MenuItemContext,
  MenuItemGroup2 as MenuItemGroup,
  MenuItemGroupLabel2 as MenuItemGroupLabel,
  MenuItemIndicator2 as MenuItemIndicator,
  MenuItemText2 as MenuItemText,
  MenuPositioner2 as MenuPositioner,
  MenuPropsProvider,
  MenuRadioItem2 as MenuRadioItem,
  MenuRadioItemGroup2 as MenuRadioItemGroup,
  MenuRoot2 as MenuRoot,
  MenuRootProvider2 as MenuRootProvider,
  MenuSeparator2 as MenuSeparator,
  MenuTrigger2 as MenuTrigger,
  MenuTriggerItem2 as MenuTriggerItem,
  namespace_exports24 as NativeSelect,
  NativeSelectField,
  NativeSelectIndicator,
  NativeSelectPropsProvider,
  NativeSelectRoot,
  namespace_exports25 as NumberInput,
  NumberInputContext2 as NumberInputContext,
  NumberInputControl2 as NumberInputControl,
  NumberInputDecrementTrigger2 as NumberInputDecrementTrigger,
  NumberInputIncrementTrigger2 as NumberInputIncrementTrigger,
  NumberInputInput2 as NumberInputInput,
  NumberInputLabel2 as NumberInputLabel,
  NumberInputPropsProvider,
  NumberInputRoot2 as NumberInputRoot,
  NumberInputRootProvider2 as NumberInputRootProvider,
  NumberInputScrubber2 as NumberInputScrubber,
  NumberInputValueText2 as NumberInputValueText,
  namespace_exports26 as Pagination,
  PaginationContext2 as PaginationContext,
  PaginationEllipsis2 as PaginationEllipsis,
  PaginationItem2 as PaginationItem,
  PaginationNextTrigger2 as PaginationNextTrigger,
  PaginationPrevTrigger2 as PaginationPrevTrigger,
  PaginationPropsProvider,
  PaginationRoot2 as PaginationRoot,
  PaginationRootProvider2 as PaginationRootProvider,
  namespace_exports27 as PinInput,
  PinInputContext2 as PinInputContext,
  PinInputControl2 as PinInputControl,
  PinInputHiddenInput2 as PinInputHiddenInput,
  PinInputInput2 as PinInputInput,
  PinInputLabel2 as PinInputLabel,
  PinInputPropsProvider,
  PinInputRoot2 as PinInputRoot,
  PinInputRootProvider2 as PinInputRootProvider,
  namespace_exports28 as Popover,
  PopoverAnchor2 as PopoverAnchor,
  PopoverArrow2 as PopoverArrow,
  PopoverArrowTip2 as PopoverArrowTip,
  PopoverBody,
  PopoverCloseTrigger2 as PopoverCloseTrigger,
  PopoverContent2 as PopoverContent,
  PopoverContext2 as PopoverContext,
  PopoverDescription2 as PopoverDescription,
  PopoverFooter,
  PopoverHeader,
  PopoverPositioner2 as PopoverPositioner,
  PopoverPropsProvider,
  PopoverRoot2 as PopoverRoot,
  PopoverRootProvider2 as PopoverRootProvider,
  PopoverTitle2 as PopoverTitle,
  PopoverTrigger2 as PopoverTrigger,
  Portal,
  Presence2 as Presence,
  namespace_exports29 as Progress,
  namespace_exports30 as ProgressCircle,
  ProgressCircleCircle,
  ProgressCircleContext,
  ProgressCircleLabel,
  ProgressCirclePropsProvider,
  ProgressCircleRange2 as ProgressCircleRange,
  ProgressCircleRoot,
  ProgressCircleRootProvider,
  ProgressCircleTrack2 as ProgressCircleTrack,
  ProgressCircleValueText,
  ProgressContext2 as ProgressContext,
  ProgressLabel2 as ProgressLabel,
  ProgressPropsProvider,
  ProgressRange2 as ProgressRange,
  ProgressRoot2 as ProgressRoot,
  ProgressRootProvider2 as ProgressRootProvider,
  ProgressTrack2 as ProgressTrack,
  ProgressValueText2 as ProgressValueText,
  namespace_exports31 as QrCode,
  QrCodeFrame2 as QrCodeFrame,
  QrCodeOverlay2 as QrCodeOverlay,
  QrCodePattern2 as QrCodePattern,
  QrCodePropsProvider,
  QrCodeRoot2 as QrCodeRoot,
  QrCodeRootProvider2 as QrCodeRootProvider,
  namespace_exports32 as RadioCard,
  RadioCardContext,
  RadioCardItem,
  RadioCardItemAddon,
  RadioCardItemContent,
  RadioCardItemControl,
  RadioCardItemDescription,
  RadioCardItemHiddenInput,
  RadioCardItemIndicator,
  RadioCardItemText,
  RadioCardLabel,
  RadioCardPropsProvider,
  RadioCardRoot,
  RadioCardRootProvider,
  namespace_exports33 as RadioGroup,
  RadioGroupContext2 as RadioGroupContext,
  RadioGroupItem2 as RadioGroupItem,
  RadioGroupItemControl2 as RadioGroupItemControl,
  RadioGroupItemHiddenInput2 as RadioGroupItemHiddenInput,
  RadioGroupItemIndicator2 as RadioGroupItemIndicator,
  RadioGroupItemText2 as RadioGroupItemText,
  RadioGroupLabel2 as RadioGroupLabel,
  RadioGroupPropsProvider,
  RadioGroupRoot2 as RadioGroupRoot,
  RadioGroupRootProvider2 as RadioGroupRootProvider,
  Radiomark,
  namespace_exports34 as RatingGroup,
  RatingGroupContext2 as RatingGroupContext,
  RatingGroupControl2 as RatingGroupControl,
  RatingGroupHiddenInput2 as RatingGroupHiddenInput,
  RatingGroupItem2 as RatingGroupItem,
  RatingGroupItemContext2 as RatingGroupItemContext,
  RatingGroupItemIndicator,
  RatingGroupLabel2 as RatingGroupLabel,
  RatingGroupPropsProvider,
  RatingGroupRoot2 as RatingGroupRoot,
  RatingGroupRootProvider2 as RatingGroupRootProvider,
  RecipePropsProvider,
  namespace_exports35 as SegmentGroup,
  SegmentGroupContext2 as SegmentGroupContext,
  SegmentGroupIndicator2 as SegmentGroupIndicator,
  SegmentGroupItem2 as SegmentGroupItem,
  SegmentGroupItemContext2 as SegmentGroupItemContext,
  SegmentGroupItemHiddenInput2 as SegmentGroupItemHiddenInput,
  SegmentGroupItemText2 as SegmentGroupItemText,
  SegmentGroupPropsProvider,
  SegmentGroupRoot2 as SegmentGroupRoot,
  SegmentGroupRootProvider2 as SegmentGroupRootProvider,
  namespace_exports36 as Select,
  SelectClearTrigger2 as SelectClearTrigger,
  SelectContent2 as SelectContent,
  SelectContext2 as SelectContext,
  SelectControl2 as SelectControl,
  SelectHiddenSelect2 as SelectHiddenSelect,
  SelectIndicator2 as SelectIndicator,
  SelectIndicatorGroup,
  SelectItem2 as SelectItem,
  SelectItemContext2 as SelectItemContext,
  SelectItemGroup2 as SelectItemGroup,
  SelectItemGroupLabel2 as SelectItemGroupLabel,
  SelectItemIndicator2 as SelectItemIndicator,
  SelectItemText2 as SelectItemText,
  SelectLabel2 as SelectLabel,
  SelectPositioner2 as SelectPositioner,
  SelectPropsProvider,
  SelectRoot2 as SelectRoot,
  SelectRootProvider2 as SelectRootProvider,
  SelectTrigger2 as SelectTrigger,
  SelectValueText2 as SelectValueText,
  Separator,
  SeparatorPropsProvider,
  Show,
  SimpleGrid,
  Skeleton,
  SkeletonPropsProvider,
  SkipNavContent,
  SkipNavLink,
  namespace_exports37 as Slider,
  SliderContext2 as SliderContext,
  SliderControl2 as SliderControl,
  SliderDraggingIndicator2 as SliderDraggingIndicator,
  SliderHiddenInput2 as SliderHiddenInput,
  SliderLabel2 as SliderLabel,
  SliderMarker2 as SliderMarker,
  SliderMarkerGroup2 as SliderMarkerGroup,
  SliderMarkerIndicator,
  SliderPropsProvider,
  SliderRange2 as SliderRange,
  SliderRoot2 as SliderRoot,
  SliderRootProvider2 as SliderRootProvider,
  SliderThumb2 as SliderThumb,
  SliderTrack2 as SliderTrack,
  SliderValueText2 as SliderValueText,
  Spacer,
  Span,
  Spinner,
  SpinnerPropsProvider,
  Square,
  Stack,
  StackSeparator,
  namespace_exports38 as Stat,
  StatDownIndicator,
  StatHelpText,
  StatLabel,
  StatPropsProvider,
  StatRoot,
  StatUpIndicator,
  StatValueText,
  StatValueUnit,
  namespace_exports39 as Status,
  StatusIndicator,
  StatusPropsProvider,
  StatusRoot,
  namespace_exports40 as Steps,
  StepsCompletedContent2 as StepsCompletedContent,
  StepsContent2 as StepsContent,
  StepsContext2 as StepsContext,
  StepsDescription,
  StepsIndicator2 as StepsIndicator,
  StepsItem2 as StepsItem,
  StepsItemContext2 as StepsItemContext,
  StepsList2 as StepsList,
  StepsNextTrigger2 as StepsNextTrigger,
  StepsNumber,
  StepsPrevTrigger2 as StepsPrevTrigger,
  StepsPropsProvider,
  StepsRoot2 as StepsRoot,
  StepsRootProvider2 as StepsRootProvider,
  StepsSeparator2 as StepsSeparator,
  StepsStatus,
  StepsTitle,
  StepsTrigger2 as StepsTrigger,
  Sticky,
  Strong,
  namespace_exports41 as Switch,
  SwitchContext2 as SwitchContext,
  SwitchControl2 as SwitchControl,
  SwitchHiddenInput2 as SwitchHiddenInput,
  SwitchIndicator,
  SwitchLabel2 as SwitchLabel,
  SwitchPropsProvider,
  SwitchRoot2 as SwitchRoot,
  SwitchRootProvider2 as SwitchRootProvider,
  SwitchThumb2 as SwitchThumb,
  SwitchThumbIndicator,
  namespace_exports42 as Table,
  TableBody,
  TableCaption,
  TableCell,
  TableColumn,
  TableColumnGroup,
  TableColumnHeader,
  TableFooter,
  TableHeader,
  TableRoot,
  TableRootPropsProvider,
  TableRow,
  TableScrollArea,
  namespace_exports43 as Tabs,
  TabsContent,
  TabsContentGroup,
  TabsContext2 as TabsContext,
  TabsIndicator,
  TabsList,
  TabsPropsProvider,
  TabsRoot2 as TabsRoot,
  TabsRootProvider2 as TabsRootProvider,
  TabsTrigger,
  namespace_exports44 as Tag,
  TagCloseTrigger,
  TagEndElement,
  TagLabel,
  TagRoot,
  TagRootPropsProvider,
  TagStartElement,
  Text,
  TextPropsProvider,
  Textarea,
  TextareaPropsProvider,
  Theme,
  namespace_exports45 as Timeline,
  TimelineConnector,
  TimelineContent,
  TimelineDescription,
  TimelineIndicator,
  TimelineItem,
  TimelineRoot,
  TimelineRootPropsProvider,
  TimelineSeparator,
  TimelineTitle,
  namespace_exports46 as Toast,
  ToastActionTrigger2 as ToastActionTrigger,
  ToastCloseTrigger2 as ToastCloseTrigger,
  ToastDescription2 as ToastDescription,
  ToastIndicator,
  ToastRoot2 as ToastRoot,
  ToastTitle2 as ToastTitle,
  Toaster2 as Toaster,
  namespace_exports47 as Toggle,
  ToggleContext2 as ToggleContext,
  ToggleIndicator2 as ToggleIndicator,
  TogglePropsProvider,
  ToggleRoot2 as ToggleRoot,
  namespace_exports48 as Tooltip,
  TooltipArrow2 as TooltipArrow,
  TooltipArrowTip2 as TooltipArrowTip,
  TooltipContent2 as TooltipContent,
  TooltipContext2 as TooltipContext,
  TooltipPositioner2 as TooltipPositioner,
  TooltipPropsProvider,
  TooltipRoot2 as TooltipRoot,
  TooltipRootProvider2 as TooltipRootProvider,
  TooltipTrigger2 as TooltipTrigger,
  VStack,
  VisuallyHidden,
  chakra,
  createContext,
  createIcon,
  createListCollection,
  createRecipeContext,
  createSlotRecipeContext,
  createSystem,
  createToaster,
  defaultBaseConfig,
  defaultConfig,
  defaultSystem,
  defineAnimationStyles,
  defineConditions,
  defineConfig,
  defineGlobalStyles,
  defineKeyframes,
  defineLayerStyles,
  defineRecipe,
  defineSemanticTokens,
  defineSlotRecipe,
  defineStyle,
  defineTextStyles,
  defineTokens,
  isValidSystem,
  mergeConfigs,
  mergeProps,
  mergeRefs,
  parse2 as parseColor,
  useAccordion,
  useAccordionContext,
  useAccordionItemContext,
  useAccordionStyles,
  usePopover as useActionBar,
  usePopoverContext as useActionBarContext,
  useActionBarStyles,
  useAlertStyles,
  useAvatar,
  useAvatarContext,
  useAvatarStyles,
  useBlockquoteStyles,
  useBreadcrumbStyles,
  useBreakpoint,
  useBreakpointValue,
  useCallbackRef,
  useCardStyles,
  useChakraContext,
  useCheckbox,
  useCheckbox as useCheckboxCard,
  useCheckboxContext as useCheckboxCardContext,
  useCheckboxCardStyles,
  useCheckboxContext,
  useCheckboxGroup,
  useCheckboxGroupContext,
  useCheckboxStyles,
  useClipboard,
  useClipboardContext,
  useClipboardStyles,
  useCollapsible,
  useCollapsibleContext,
  useCollapsibleStyles,
  useColorPicker,
  useColorPickerContext,
  useColorPickerStyles,
  useControllableProp,
  useControllableState,
  useDataListStyles,
  useDialog,
  useDialogContext,
  useDialogStyles,
  useDisclosure,
  useDialog as useDrawer,
  useDialogContext as useDrawerContext,
  useDrawerStyles,
  useEditable,
  useEditableContext,
  useEditableStyles,
  useEmptyStateStyles,
  useEnvironmentContext,
  useFieldContext,
  useFieldStyles,
  useFieldsetContext,
  useFileUpload,
  useFileUploadContext,
  useFileUploadStyles,
  useHighlight,
  useHoverCard,
  useHoverCardContext,
  useHoverCardStyles,
  useListStyles,
  useLocaleContext,
  useMediaQuery,
  useMenu,
  useMenuContext,
  useMenuItemContext,
  useMenuStyles,
  useNativeSelectStyles,
  useNumberInput,
  useNumberInputContext,
  useNumberInputStyles,
  usePagination,
  usePaginationContext,
  usePaginationStyles,
  useParentRecipeProps,
  usePinInput,
  usePinInputContext,
  usePinInputStyles,
  usePopover,
  usePopoverContext,
  usePopoverStyles,
  useProgress,
  useProgressCircleStyles,
  useProgressContext,
  useProgressStyles,
  useQrCode,
  useQrCodeContext,
  useQrCodeStyles,
  useRadioGroupContext as useRadioCardContext,
  useRadioGroup as useRadioCardGroup,
  useRadioGroupItemContext as useRadioCardItemContext,
  useRadioCardStyles,
  useRadioGroup,
  useRadioGroupContext,
  useRadioGroupItemContext,
  useRadioGroupStyles,
  useRatingGroup,
  useRatingGroupContext,
  useRatingGroupItemContext,
  useRatingGroupStyles,
  useRecipe,
  useSegmentGroup,
  useSegmentGroupContext,
  useSegmentGroupItemContext,
  useSegmentGroupStyles,
  useSelect,
  useSelectContext,
  useSelectItemContext,
  useSelectStyles,
  useSlider,
  useSliderContext,
  useSliderStyles,
  useSlotRecipe,
  useStatStyles,
  useStatusStyles,
  useSteps,
  useStepsContext,
  useStepsItemContext,
  useStepsStyles,
  useSwitch,
  useSwitchContext,
  useSwitchStyles,
  useTableStyles,
  useTabs,
  useTabsContext,
  useTabsStyles,
  useTagStyles,
  useTimelineStyles,
  useToastStyles,
  useToggle,
  useToggleContext,
  useToggleStyles,
  useToken,
  useTooltip,
  useTooltipContext,
  useTooltipStyles,
  visuallyHiddenStyle2 as visuallyHiddenStyle
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@chakra-ui_react.js.map
